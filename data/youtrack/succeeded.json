{
    "count": 1850,
    "success": true,
    "codes": [
        {
            "code": "\nclass BrokenReified {\n    @Test\n    fun `reified doesn't work as expected`() {\n        run {\n            // this TypeToken is what we expect, and its generic is of type String\n            val listGenericType = typeToken<List<String>>().getListGenericType()\n            assertEquals(String::class.java, listGenericType)\n        }\n        run {\n            // this generic on List was lost because reification doesn't seem to work 2 layers deep\n            val listGenericType = listTypeToken<String>().getListGenericType()\n            // This listGenericType is NOT a Class like we would expect, it's a TypeVariable with no upper bounds (upper bound is Object)\n            val listGenericTypeVariable = listGenericType as TypeVariable<*>\n            assertEquals(\"T\", listGenericTypeVariable.name)\n            assertEquals(1, listGenericTypeVariable.bounds.size)\n            assertEquals(Object::class.java, listGenericTypeVariable.bounds[0])\n        }\n    }\n}\nprivate fun TypeToken<*>.getListGenericType(): Type =\n        ((this.type as ParameterizedType).actualTypeArguments[0] as WildcardType).upperBounds[0]\n\ninline fun <reified T> listTypeToken(): TypeToken<List<T>> = typeToken<List<T>>()\n\ninline fun <reified T> typeToken() = object : TypeToken<T>() {}\n"
        },
        {
            "code": "\nexpect interface I {\n    suspend fun f(p: Int = 1)\n}\n"
        },
        {
            "code": "\nactual interface I {\n    actual suspend fun f(p: Int)\n}\n\nclass II : I {\n    override suspend fun f(p: Int) {\n    }\n}\n"
        },
        {
            "code": "\n@Test\n    fun testII() = runTest {\n        II().f()\n    }\n"
        },
        {
            "code": "\n// in js\nvar AbstractTester = Class(ITester)\n"
        },
        {
            "code": "\n            val resource = object : StreamResource({ getHtmlContent(currentNode!!).byteInputStream() }, \"topic.html\") {\n                    }\n                    Page.getCurrent().open(resource, \"_blank\", false)\n"
        },
        {
            "code": "\n                currentNode?.let { node ->\n                    val resource = object : StreamResource({ getHtmlContent(node).byteInputStream() }, \"topic.html\") {\n                    }\n                    Page.getCurrent().open(resource, \"_blank\", false)\n                }\n"
        },
        {
            "code": "\ninterface CookieJar {\n    companion object {\n        @JvmField\n        val NO_COOKIES: CookieJar = object : CookieJar { }\n    }\n}\n"
        },
        {
            "code": "\nclass Test(private val capture: Map<String, Any>) {\n  fun foo(appendable: Appendable) {\n    appendable.apply {\n      appendln(outer {\n        inner {\n          function(1, capture[\"2\"], capture[\"3\"])\n        }\n        inner {\n        }\n      }.toString())\n      appendln()\n    }\n  }\n}\n\ninterface InnerReceiver {\n  fun function(vararg stuff: Any?)\n}\ninterface OuterReceiver {\n  fun inner(body: InnerReceiver.() -> Unit)\n}\n\nclass InnerReceiverImpl : InnerReceiver {\n  override fun function(vararg stuff: Any?) {}\n}\nclass OuterReceiverImpl : OuterReceiver {\n  override fun inner(body: InnerReceiver.() -> Unit) {}\n}\n\nfun outer(body: OuterReceiver.() -> Unit): Any {\n  return Any()\n}\n"
        },
        {
            "code": "\ninterface A {\n    fun foo(): String = { \"\" }()\n}\n"
        },
        {
            "code": "\nclass CountingString(private val s: String) : CharSequence {\n    var lengthCtr = 0\n    var getCtr = 0\n\n    override val length: Int\n    \tget() = s.length.also { lengthCtr++ }\n    override fun subSequence(startIndex: Int, endIndex: Int) = TODO(\"not implemented\")\n    override fun get(index: Int) = s.get(index).also { getCtr++ }\n\n    fun reset() {\n        lengthCtr = 0\n        getCtr = 0\n    }\n\n    fun printCtrs() {\n        println(\"getCtr: ${getCtr}\")\n        println(\"lengthCtr: ${lengthCtr}\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val cs = CountingString(\"abcd\")\n\n    // INCORRECT behavior\n    for ((_, _) in cs.withIndex()) {}\n    cs.printCtrs()\n    cs.reset()\n\n    // CORRECT behavior\n    val cswi = cs.withIndex()\n    for ((_, _) in cswi) {}\n    cs.printCtrs()\n    cs.reset()\n\n    // Intended behavior of iterating over CharSequence\n    val csit = cs.iterator()\n    while (csit.hasNext()) {\n        csit.next()\n    }\n    cs.printCtrs()\n    cs.reset()    \n\n    // CORRECT behavior when element variable is present in destructuring declaration\n    for ((_, v) in cs.withIndex()) {}\n    cs.printCtrs()\n    cs.reset()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(ButtonState.DOWN)\n}\n\nenum class ButtonState(\n\t\tval isUp: Boolean = false,\n\t\tval isOver: Boolean = false,\n\t\tval isDown: Boolean = false,\n\t\tval isToggled: Boolean = false,\n\t\tval isIndeterminate: Boolean = false,\n\t\tval fallback: ButtonState? = null\n) {\n\tUP(isUp = true, fallback = null),\n\tOVER(isOver = true, fallback = UP),\n\tDOWN(isDown = true, isOver = true, fallback = OVER),\n\tTOGGLED_UP(isUp = true, isToggled = true, fallback = UP),\n\tTOGGLED_OVER(isOver = true, isToggled = true, fallback = TOGGLED_UP),\n\tTOGGLED_DOWN(isDown = true, isOver = true, isToggled = true, fallback = TOGGLED_UP),\n\tINDETERMINATE_UP(isUp = true, isIndeterminate = true, fallback = UP),\n\tINDETERMINATE_OVER(isOver = true, isIndeterminate = true, fallback = INDETERMINATE_UP),\n\tINDETERMINATE_DOWN(isDown = true, isOver = true, isIndeterminate = true, fallback = INDETERMINATE_UP),\n\tDISABLED(fallback = UP);\n}\n"
        },
        {
            "code": " Marker\n// plugin will add synthetic\nabstract class Marker: MyExternalInterface1, MyExternalInterface2\n\nclass SimpleMarker : Marker\n"
        },
        {
            "code": "\nimport kotlin.math.absoluteValue\n\nfun main() {\n    1.let(Int::absoluteValue)\n}\n"
        },
        {
            "code": "\nimport kotlin.math.*\n\nfun main() {\n    println(listOf(1L).map(Long::absoluteValue))  // broken (IllegalAccessError)\n    println(listOf(1L).map(Long::sign))  // ok\n}\n"
        },
        {
            "code": "\nsuspend fun main() {\n    (0..5).asFlow().map { runCatching { 1 / it } }.count()\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.map\n\nfun Flow<String>.abc() = map { line ->\n    try {\n        line\n    } catch (e: Exception) {\n        e.message\n    }\n}\n"
        },
        {
            "code": "\npublic suspend inline fun hang(onCancellation: (Throwable) -> Unit) {\n    var exception: Throwable? = null\n    try {\n        suspendCancellableCoroutine<Unit> { }\n    } catch (e: Throwable) {\n        exception = e\n    } finally {\n        onCancellation(exception!!)\n    }\n}\n"
        },
        {
            "code": "\n/**\n * This example is minified.\n *\n * Moving `inner` outside `outer` or removing `suspend` modifier should make compilation to succeed.\n * Removing `run` also solves the issue.\n */\nfun outer() {\n  suspend fun inner(): Int = run { inner() }\n}\n"
        },
        {
            "code": "\n// The issue persists even without inlining.\n// I suspect that a recursive suspending call of a local function in a Î» expr is essentially the problem.\nsuspend fun eval(f: suspend () -> Int): Int = f()\nfun outer() {\n    suspend fun inner(): Int = eval { inner() }\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.*\n\nfun main() {\n    suspend fun test() {\n        GlobalScope.run {\n            test()\n        }\n    }\n}\n"
        },
        {
            "code": "\n@Target(AnnotationTarget.TYPE)\nannotation class Foo\n\nclass A {\n    fun foo(): @Foo String = \"OK\"\n}\n"
        },
        {
            "code": "\npackage project.net\n\nimport org.junit.Test\nimport org.junit.runner.RunWith\nimport org.robolectric.RobolectricTestRunner\n\n@RunWith(RobolectricTestRunner::class)\nclass CompilerBugTest {\n\n    class Other() {}\n    class TestClassWithoutLazy(val client: Other) {}\n    class TestClass(val client: Lazy<Other> ) { }\n\n    @Test\n    fun `* works just fine`() {\n        val instance = TestClassWithoutLazy(Other())\n        println(instance)\n    }\n\n    @Test\n    fun `* fails to compile`() {\n        // Note: If I remove '*' from the test name this doesn't fail anymore.\n        val instance = TestClass(lazy { Other() })\n        println(instance)\n    }\n}\n\n"
        },
        {
            "code": "\n@ExperimentalContracts\nfun runOnce(action: () -> Unit) {\n    contract {\n        callsInPlace(action, InvocationKind.EXACTLY_ONCE)\n    }\n    action()\n}\n\n@ExperimentalContracts\nclass Foo(foo: Boolean) {\n    init {\n        runOnce { foo }\n    }\n}\n"
        },
        {
            "code": "\nimport java.lang.invoke.MethodHandles\nimport java.lang.invoke.MethodType\n\nclass C {\n    fun foo(s: String) {\n        println(s)\n    }\n}\n\nfun main() {\n    val mh = MethodHandles.lookup().findVirtual(\n        C::class.java, \"foo\",\n        MethodType.methodType(Void.TYPE, String::class.java)\n    )\n\n    // Problem here:\n    // invokevirtual java/lang/invoke/MethodHandle.invokeExact:(LC;Ljava/lang/String;)Ljava/lang/Object;\n    mh.invokeExact(C(), \"Hello\")\n}\n"
        },
        {
            "code": "\nfun qwe_withoutCast_1() {\n    val d: dynamic = null // Something coming from outside\n    // .....\n    val s: String = d\n    clog(\"sssss\", s)\n}\n\nfun qwe_withCast_1() {\n    val d: dynamic = null // Something coming from outside\n    // .....\n    val s: String = d as String\n    //                ^~~~~~~~~ Incorrect warning: No cast needed\n    clog(\"sssss\", s)\n}\n\nfun qwe_withoutCast_2() {\n    val d: dynamic = 123 // Something coming from outside\n    // .....\n    val s: String = d\n    clog(\"sssss\", s)\n}\n\nfun qwe_withCast_2() {\n    val d: dynamic = 123 // Something coming from outside\n    // .....\n    val s: String = d as String\n    //                ^~~~~~~~~ Incorrect warning: No cast needed\n    clog(\"sssss\", s)\n}\n"
        },
        {
            "code": "\ninline fun some(\n   param1:()->String = {\"$param2 vasya\"},\n   param2:String=\"Hello,\"\n) = println(param1())\n\nfun main(){\n    some()\n}\n"
        },
        {
            "code": "\ninline fun f(crossinline g: () -> Unit) = object {\n    fun <T> f() = g()\n    fun <T> h() {}\n}\nval x = f { }\n"
        },
        {
            "code": "\nclass Person(\n    val firstName: String,\n    val secondName: String\n) {\n    val fullName by lazy { firstName + \" \" + secondName }\n}\n"
        },
        {
            "code": "\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n"
        },
        {
            "code": "\nfor (key in 0..array.size-1) {\n  val value = array[i]\n  // user code\n}\n"
        },
        {
            "code": "\nvar idx = 0\nfor (value in collection) {\n  val key = idx++\n  // user code\n}\n"
        },
        {
            "code": "\nfor (_entry in map) {\n  val key = _entry.key\n  val value = _entry.value\n  // user code\n}\n"
        },
        {
            "code": "\npackage test\n\nclass C {\n    lateinit var a: String\n\n    fun ref() = ::a::isInitialized\n}\n\nfun main() {\n    println(C().ref().get())\n}\n"
        },
        {
            "code": "\nclass Luxer() {\n    tailrec fun lux(l: String?): String {\n        l?.let {\n            return if(it.isBlank()) \"\"\n            else lux(l.drop(1))\n        }\n        return \"\"\n    }\n}\n"
        },
        {
            "code": "\nfun listOfFactor(number: Int): List<Int> {\n  tailrec fun listOfFactor(number: Int, acc: List<Int>): List<Int> {\n    (2..number).forEach {\n      if (number % it == 0) return listOfFactor(number / it, acc + it)\n    }\n    return acc\n  }\n  return listOfFactor(number, emptyList())\n}\n\nfun main(args: Array<String>) {\n  println(listOfFactor(60))\n}\n"
        },
        {
            "code": "\nprivate fun List<String>.toPredicate(): (File) -> Boolean =\n  map { PatternUtil.fromMask(it) }\n    .let { patterns ->\n      fun(probe: File) = patterns.any { pattern -> pattern.matcher(probe.name).matches() }\n    }\n"
        },
        {
            "code": "\n{ probe: File -> patterns.any { pattern -> pattern.matcher(probe.name).matches() } }\n"
        },
        {
            "code": "\nfun foo(x: Int = 42, y: String = \"\", b: Boolean = true) {}\n"
        },
        {
            "code": "\n@JvmOverloads \nfun foo(x: Int = 42, y: String = \"\", b: Boolean = true) {}\n"
        },
        {
            "code": "\n\n// File: A.kt\nopen class A {\n    @JvmOverloads\n    open fun foo(x: Any = 1) {\n        println(\"From Kotlin\")\n    }\n}\n"
        },
        {
            "code": "\nfun test(a: A) {\n    a.foo()\n}\n\nfun main() {\n    test(A())\n    test(JavaA())\n}\n"
        },
        {
            "code": "\nfun test(a: A) {\n    a.foo()\n}\n"
        },
        {
            "code": "\nfun main() {\n    println()\n}\n"
        },
        {
            "code": "\npackage test\n\nclass C(var string: String)\n\nval c: C? = null\n\nfun test(m: String) {\n    c?.string += m\n}\n\nfun main(args: Array<String>) {\n    test(\"xx\")\n}\n"
        },
        {
            "code": "\nclass Foo(var bar: String)\n\nfun main(){\n\tvar baz: Foo? = Foo(\"test\")\n\tbaz?.bar += \"test\"\n\tprintln(baz)\n}\n"
        },
        {
            "code": "\nenum inline class C(val x: Int) // Error: Modifier 'inline' is not applicable to 'enum class'\n"
        },
        {
            "code": "\nprivate val replacements: Map<Char, String> = mapOf(\n            '<' to \"&lt;\",\n            '>' to \"&gt;\"\n    )\n\nprintln(\"${replacements[60.toChar()]} ${60.toChar().let {replacements[it]}} ${60.toChar()?.let {replacements[it]}}\")\n"
        },
        {
            "code": "\nfun Array<Array<Array<Array<Array<Array<Array<Array<Array<Array<Array<Array<Array<Array<Array<LongArray>>>>>>>>>>>>>>>.dimensions() = 16\n"
        },
        {
            "code": "\nfun String.isNotWorking() = true\n\nopen class Base {\n    fun foo() {\n        \"\".isNotWorking()\n    }\n}\n\nclass Bar() : Base()\n\n"
        },
        {
            "code": "\nval debugPort = \"8000\"\n\nenum class JreVersion( \nval value: String, val debugString: String = \"\",\n val additionalDependencies: DependencyHandlerScope.() -> Unit = {} ) {\n    Eleven(value = \"11.0.2-jre-slim\",\n        debugString = \"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:$debugPort\",\n        additionalDependencies = {\n            implementation(\"org.glassfish.jaxb:jaxb-runtime\")\n        }\n    )\n}\n"
        },
        {
            "code": "\n\n/**\n * A FIFO (First In First Out) structure.\n */\nclass Queue<TGen>() : Collection<TGen> {\n  private val items = TGenDeque<TGen>()\n\n  override val size: Int get() = items.size\n  override fun isEmpty() = size == 0\n\n  constructor(vararg items: TGen) : this() {\n    for (item in items) enqueue(item)\n  }\n\n  fun enqueue(v: TGen) = run { items.addLast(v) }\n  fun dequeue(): TGen = items.removeFirst()\n  fun remove(v: TGen) = run { items.remove(v) }\n  fun toList() = items.toList()\n\n  override fun contains(element: TGen): Boolean = items.contains(element)\n  override fun containsAll(elements: Collection<TGen>): Boolean = items.containsAll(elements)\n  override fun iterator(): Iterator<TGen> = items.iterator()\n}\n\n\n// Int\n\n/**\n * A FIFO (First In First Out) structure.\n */\nclass IntQueue() : Collection<Int> {\n  private val items = IntDeque()\n\n  override val size: Int get() = items.size\n  override fun isEmpty() = size == 0\n\n  constructor(vararg items: Int) : this() {\n    for (item in items) enqueue(item)\n  }\n\n  fun enqueue(v: Int) = run { items.addLast(v) }\n  fun dequeue(): Int = items.removeFirst()\n  fun remove(v: Int) = run { items.remove(v) }\n  fun toList() = items.toList()\n\n  override fun contains(element: Int): Boolean = items.contains(element)\n  override fun containsAll(elements: Collection<Int>): Boolean = items.containsAll(elements)\n  override fun iterator(): Iterator<Int> = items.iterator()\n}\n\n\n// Double\n\n/**\n * A FIFO (First In First Out) structure.\n */\nclass DoubleQueue() : Collection<Double> {\n  private val items = DoubleDeque()\n\n  override val size: Int get() = items.size\n  override fun isEmpty() = size == 0\n\n  constructor(vararg items: Double) : this() {\n    for (item in items) enqueue(item)\n  }\n\n  fun enqueue(v: Double) = run { items.addLast(v) }\n  fun dequeue(): Double = items.removeFirst()\n  fun remove(v: Double) = run { items.remove(v) }\n  fun toList() = items.toList()\n\n  override fun contains(element: Double): Boolean = items.contains(element)\n  override fun containsAll(elements: Collection<Double>): Boolean = items.containsAll(elements)\n  override fun iterator(): Iterator<Double> = items.iterator()\n}\n\n\n// Float\n\n/**\n * A FIFO (First In First Out) structure.\n */\nclass FloatQueue() : Collection<Float> {\n  private val items = FloatDeque()\n\n  override val size: Int get() = items.size\n  override fun isEmpty() = size == 0\n\n  constructor(vararg items: Float) : this() {\n    for (item in items) enqueue(item)\n  }\n\n  fun enqueue(v: Float) = run { items.addLast(v) }\n  fun dequeue(): Float = items.removeFirst()\n  fun remove(v: Float) = run { items.remove(v) }\n  fun toList() = items.toList()\n\n  override fun contains(element: Float): Boolean = items.contains(element)\n  override fun containsAll(elements: Collection<Float>): Boolean = items.containsAll(elements)\n  override fun iterator(): Iterator<Float> = items.iterator()\n}\n"
        },
        {
            "code": "\n    fun foo() {\n        when(val foo = 42UL) {\n            42UL -> println(\"42!\")\n            else -> throw IllegalStateException()\n        }\n    }\n    "
        },
        {
            "code": "\nvar counter = 0\nfun inc() = counter++\n\ntailrec fun test(x: Int = 0, y: Int = inc(), z: Int = inc()) {\n    println(\"y: $y, z: $z\")\n    if (x > 0) test(x - 1)\n}\n\nfun main() {\n    test(1)\n}\n"
        },
        {
            "code": "\nfor (i in 0..0 step 0) {}   // Any literal progression with step <= 0\n"
        },
        {
            "code": "\nfun main() {\n    A.GOO\n}\n\nenum class A {\n    GOO;\n    val a by lazy { 42 }\n    val b = a\n}\n"
        },
        {
            "code": "\nclass BrokenImplementation : Interface {\n    override fun myOperation(myFlag: Boolean) = \"Hello World\"\n}\n"
        },
        {
            "code": "\nimport interfaces.Interface\nimport org.glassfish.jersey.server.ResourceConfig\nimport org.glassfish.jersey.test.JerseyTest\nimport org.junit.Assert.assertEquals\nimport org.junit.Test\n\nclass BrokenImplementation : Interface {\n    override fun myOperation(myFlag: Boolean) = \"Hello World\"\n}\nclass GoodImplementation : Interface {\n    override fun myOperation(myFlag: Boolean?) = \"Hello World\"\n}\n\nabstract class AbstractTest(c: ResourceConfig) : JerseyTest(c) {\n    @Test\n    fun testIt() =\n        assertEquals(\"Hello World\", target(\"/\").queryParam(\"myFlag\", false).request().get(String::class.java))\n}\n\nclass BrokenTest : AbstractTest(ResourceConfig(BrokenImplementation::class.java))\n\nclass GoodTest : AbstractTest(ResourceConfig(GoodImplementation::class.java))\n"
        },
        {
            "code": "\nclass KotlinTest {\n\n    private val unit get() = Unit\n\n    fun onCreate() {\n        val scope = CoroutineScope(Dispatchers.Unconfined)\n        val channel = Channel<Unit>()\n\n        scope.launchCrossinlineFunction(\n            Unit,\n            channel\n        )\n\n        channel.sendBlocking(Unit)\n    }\n}\n\ninternal inline fun CoroutineScope.launchCrossinlineFunction(\n    unit: Unit,\n    receiveChannel: ReceiveChannel<Unit>,\n    crossinline block: (String) -> Unit = { println(it) }\n) {\n    launch {\n        receiveChannel\n            .map { } // <-- adding this map causes the proguard compilation issue. Removing it fixes it\n            .consumeEach {\n                block(\"String\")\n            }\n    }\n}\n"
        },
        {
            "code": "\nfun main() {\n    for (c: Any in doubleArrayOf(1.0)) {}\n}\n"
        },
        {
            "code": "\npackage test\n\nimport kotlin.reflect.KFunction1\n\nval samCtor: KFunction1<() -> Unit, Runnable> = ::Runnable\n"
        },
        {
            "code": "\nclass Queue<T>(override val size: Int) : Collection<T> {\n    override fun contains(element: T): Boolean = TODO()\n\n    override fun containsAll(elements: Collection<T>): Boolean = TODO()\n\n    override fun isEmpty(): Boolean = TODO()\n\n    override fun iterator(): Iterator<T> = TODO()\n\n    fun remove(v: T): Any = v as Any // Return-type is Any, it's important\n}\n\nfun box(): String {\n    (Queue<String>(1) as java.util.Collection<String>).remove(\"\") // throws CCE\n\n    return \"OK\"\n}\n\nfun main() {\n    println(box())\n}\n"
        },
        {
            "code": "\nclass X {\n\n    suspend fun suspending() {}\n\n    suspend fun test() {\n        logError(::suspending)\n    }\n\n    suspend inline fun runBlock(block: suspend () -> Unit) {\n        logError(block)\n    }\n\n    suspend inline fun logError(block: suspend () -> Unit) {\n        try {\n            block()\n        } catch (e: Exception) {\n            //Log Exception\n        }\n    }\n}\n\n"
        },
        {
            "code": "\n//This breaks suspend behavior\nsuspend fun <T : Vertex> T.save(\n    timestamp: Timestamp = Timestamp.now(),\n    tenant: Long? = null,\n    beforeSaveVertex: suspend (T) -> Unit = {},\n    afterSaveVertex: suspend (T) -> Unit = {}\n): T = this.apply {\n    this.saveElement(timestamp, tenant, { beforeSaveVertex(it as T) }, { afterSaveVertex(it as T) }) \n}\n\n//Here suspend behavior work properly\nsuspend fun <T : Vertex> T.save(\n    timestamp: Timestamp = Timestamp.now(),\n    tenant: Long? = null,\n    beforeSaveVertex: suspend (T) -> Unit = {},\n    afterSaveVertex: suspend (T) -> Unit = {}\n): T = this.apply {\n    this.saveElement(timestamp, tenant, { beforeSaveVertex(it as T) }, { afterSaveVertex(it as T) })\n    this //This makes suspend behavior work properly\n}\n"
        },
        {
            "code": "\nsuspend fun dummy(): Unit = Unit\n\nsuspend fun test(): Int = 1.also { \n    dummy()\n}\n"
        },
        {
            "code": "\n// Test.kt\n\nabstract class A<T>\n\nclass B : A<Callable<String>>()\n"
        },
        {
            "code": "\n// Test.kt\n\nabstract class A<T>\n\ninline fun <reified T> a() = object : A<T>() {}\n\nval B = a<Callable<String>>()\n"
        },
        {
            "code": "\ninterface D<T> {\n    fun doSomething(a: T): T\n}\n\ninline fun foo<reified T>() = object {\n    fun doSomething(a: T): T = a\n}\n\ninline fun bar<reified T>() = object : D<T> {\n    override fun doSomething(a: T): T = a\n}\n\nfun main(args: Array<String>) {\n// the doSomething not specialized\n    foo<String>()\n    foo<Int>()\n\n// the doSomething not specialized and compiler didn't generate bridges\n    bar<String>()\n    bar<Int>()\n}\n"
        },
        {
            "code": "\npackage test.pkg\nimport android.widget.TextView\nclass Test : android.app.Activity {\n    private suspend fun setUi() {\n        val x = R.string.hello\n    }\n}\n"
        },
        {
            "code": "\n@file: Suppress(\"NOTHING_TO_INLINE\")\npackage ru.spbstu.wheels\n\ninline fun Int.asBits() = IntBits(this)\n\ninline class IntBits(val data: Int) {\n    companion object {\n        val Zero = 0.asBits()\n    }\n\n    inline fun asInt() = data\n\n    inline infix fun andNot(that: IntBits): IntBits = IntBits(data and that.data.inv())\n\n    inline val popCount: Int get() = Integer.bitCount(data)\n    inline val lowestBitSet get() = Integer.lowestOneBit(data).asBits()\n\n    inline fun forEachOneBit(body: (IntBits) -> Unit) {\n        var mask = this\n        while(mask != Zero) {\n            val bit = mask.lowestBitSet\n            body(bit)\n            mask = mask andNot bit\n        }\n    }\n}\n\ninline fun Bits(data: Int) = data.asBits()\n"
        },
        {
            "code": "\npackage ru.spbstu.wheels\n\nimport org.junit.Test\nimport kotlin.test.assertEquals\n\nclass BitsTest {\n    @Test\n    fun smokeTest() {\n\n        Bits(0b11001100000).forEachOneBit { bit ->\n            assertEquals(1, bit.popCount)\n        }\n\n    }\n}\n"
        },
        {
            "code": "\ninline fun <reified T> topMethod() {\n        innerMethod {\n            accessClass<T>()\n        }\n    }\n\n    fun innerMethod(block: () -> Unit) {\n        block()\n    }\n\n    inline fun <reified Z> accessClass() { Z::class.java }\n"
        },
        {
            "code": "\n@JvmName(\"main\")\nfun Array<String?>.foo() { }\n\nfun Array<String?>.main() { }\n\n@JvmName(\"main\")\nfun foo(args: Array<String?>) { }\n\nfun main(args: Array<String?>) { }\n\nfun <T, S> main(args: Array<String>) { }\n"
        },
        {
            "code": "\nprintln(floatArrayOf(Float.MAX_VALUE)[0])   // prints Infinity\n"
        },
        {
            "code": "\ninline val <reified T> T.foo: () -> Unit\n    get() {\n        println(this is T)\n        return {}\n    }\n\nfun main(args: Array<String>) {\n    6.foo()\n}\n"
        },
        {
            "code": "\npackage demo;\n\nimport rx.Observable\nimport java.util.stream.IntStream\n\nfun <X, Y> Observable<X>.indexedMap(combiner: (X, Int) -> Y): Observable<Y> {\n    val naturals = Iterable<Int> { IntStream.iterate(0, { i -> i + 1 }).iterator() }\n    return this.zipWith(naturals, combiner)\n}\n\nopen class HelloWorldKt {\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n           Observable.just(1,2,3).indexedMap{a,b -> a + b}.toBlocking()\n        }\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.contracts.*\n\n@ExperimentalContracts\nfun runOnce(action: () -> Unit) {\n    contract {\n        callsInPlace(action, InvocationKind.EXACTLY_ONCE)\n    }\n    action()\n}\n\n@ExperimentalContracts\nclass Foo(foo: Boolean) {\n    val res: String\n    init {\n        runOnce {\n            foo\n            res = \"OK\"\n        }\n    }\n}\n\n@ExperimentalContracts\nfun box(): String {\n    val foo = Foo(true)\n    return foo.res\n}\n\n@ExperimentalContracts\nfun main() {\n    box()\n}\n"
        },
        {
            "code": "\nimport kotlin.contracts.InvocationKind.EXACTLY_ONCE\nimport kotlin.contracts.contract\n\nclass Foo {\n    val x: String\n    init {\n        call {\n            x = \"\"\n        }\n    }\n}\n\nfun call(action: () -> Unit) {\n    contract { callsInPlace(action, EXACTLY_ONCE) }\n    action()\n}\n\nfun main() {\n    Foo()\n}\n"
        },
        {
            "code": "\npublic class A {\n    fun get() {\n        listOf(str, str, str)\n    }\n\n    companion object {\n        lateinit var str: String\n    }\n}\n"
        },
        {
            "code": "\nclass Foo {\n\n    private lateinit var baz: Baz\n    \n    init {\n        baz = Baz().apply {\n            {\n                baz.counter++\n            }::invoke\n        }\n        \n    }\n}\n\nclass Baz {\n    var counter = 0\n}\n\n"
        },
        {
            "code": "\nimport kotlin.contracts.InvocationKind.EXACTLY_ONCE\nimport kotlin.contracts.contract\n\nabstract class Bar(val text: String)\n\nclass Foo(text: String): Bar(text) {\n    init {\n        // val text = text\n        call {\n            println(text)\n        }\n    }\n}\n\nfun <R> call(action: () -> R): R {\n    contract { callsInPlace(action, EXACTLY_ONCE) }\n    return action()\n}\n\nfun main() {\n    Foo(\"\")\n    println(\"Done\")\n}\n"
        },
        {
            "code": "\n\n\nfun main() {\n    run {\n        val (a, b) = getPair()\n        run {\n            println(\"1: \" + a)\n        }\n    }\n    run {\n        var (a, b) = getPair()  // If these variables have different names than the previous block, bug is not reproduced.\n        println(\"2: \" + a!!)\n        a = null   // Interferes with value from first block.\n    }   \n}\n\nprivate fun getPair(): Pair<Float?, Float> {\n    return Pair(1f, 2f)\n}\n\n"
        },
        {
            "code": "\nfun main() {\n val lk = java.lang.invoke.MethodHandles.lookup()\n val obj = \"test\"\n val mt = java.lang.invoke.MethodType.methodType(Int::class.java)\n val mh = lk.bind(obj, \"length\", mt);\n val len = mh.invoke()\n}\n"
        },
        {
            "code": "\nenableFeaturePreview('GRADLE_METADATA')\n"
        },
        {
            "code": "\nsuspend fun main() {\n    // Don't throw exceptions\n    exampleFun(null)\n    exampleFun()\n    exampleSuspendFun(null)\n\n    // Throws an exception\n    exampleSuspendFun()\n}\n"
        },
        {
            "code": "\nexpect suspend fun exampleSuspendFun(param: Any? = null)\n\nexpect fun exampleFun(param: Any? = null)\n"
        },
        {
            "code": "\nactual suspend fun exampleSuspendFun(param: Any?) {\n}\n\nactual fun exampleFun(param: Any?) {\n}\n"
        },
        {
            "code": "\nobject O {\n    @JvmStatic\n    tailrec fun gcd(value: Int, other: Int): Int {\n        if (other == 0) {\n            return value\n        }\n        return gcd(other, value.rem(other))\n    }\n}\n\nfun main() {\n    O.gcd(5, 15)\n}\n"
        },
        {
            "code": "\npackage sample\n\nexpect fun foo(x: (Int) -> Int): Int\n\nfun bar() {\n    foo { x: Int ->\n        return@foo x\n    }\n}\n"
        },
        {
            "code": "\n@file:JvmName(\"MainKtJvm\")\n\npackage sample\n\nactual fun foo(x: Int.() -> Int): Int {\n    return 10\n}\n\nfun main() {\n    println(bar())\n}\n"
        },
        {
            "code": "\nexpect fun ByteArray.asUTF8String(offset: Int = 0, length: Int = size - offset): String //line #0\n"
        },
        {
            "code": "\nactual fun ByteArray.asUTF8String(offset: Int, length: Int): String {\n    val sb = StringBuilder()\n    var cur = 0\n    while (cur < size) {\n        val size = UTF8.utf8CharSize(this[cur])\n        sb.append(UTF8.utf8toUnicode(this[cur], this, cur + 1))\n        cur += size + 1\n    }\n\n    return sb.toString()\n}\n"
        },
        {
            "code": "\nsealed class Example {\n    constructor(vararg s: String) {\n        println(s)\n    }\n\n    class Examples(vararg s: String) : Example(*s)\n}\n"
        },
        {
            "code": "\nsuspend fun anotherOuterSuspendFun(){\n}\nsuspend fun outerSuspendFun() {\n    suspend fun anotherInnerSuspendFun(){\n    }\n    suspend fun doInnerSuspend() {\n        //case 1: use inline fun and recurse, CompilationException\n        Unit.let {\n            doInnerSuspend()\n        }\n\n        //case 2: no inline fun but recurse, works well\n        doInnerSuspend()\n\n        //case 3: use inline fun, but no recurse, works well\n        Unit.let {\n            println()\n        }\n\n        //case 4: use inline fun, and call another outer suspend fun, works well\n        Unit.let {\n            anotherOuterSuspendFun()\n        }\n\n        //case 5: use inline fun, and call another inner suspend fun, works well\n        Unit.let {\n            anotherInnerSuspendFun()\n        }\n    }\n    doInnerSuspend()\n}\n"
        },
        {
            "code": "\nclass MyTest {\n    @Test\n    fun foo() {\n        assertTrue { false }\n    }\n}\n"
        },
        {
            "code": "\npackage com.michaelschlies.test\n\nimport java.lang.ref.WeakReference\n\nfun main(vararg args: String) {\n    val main = Main()\n    val t = Thread(Main())\n    t.run()\n    t.join()\n}\n\nclass Main : Runnable {\n    fun randomThing(lambdaLiteral: () -> Any) {\n        lambdaLiteral.invoke()\n    }\n\n    companion object {\n        @JvmStatic\n        fun x(): String {\n            return \"\"\n        }\n    }\n\n    override fun run() {\n        class MainTwo {\n            var ssid: String? = null\n        }\n\n        val someField = \"random\"\n        while (true) {\n            randomThing {\n                x()\n                var v: WeakReference<MainTwo>? = WeakReference(MainTwo().apply { ssid = \"asdf\" })\n                v?.get()?.ssid\n                val someLastField = \"blagblahblah\"\n                v = null\n                someLastField.length\n            };\n            { fieldOne: String, fieldTwo: String ->\n                someField.length\n            }.invoke(someField, someOtherField);\n            randomThing {\n                this.someOtherField.length\n            }\n            Thread.sleep(30)\n        }\n    }\n    private val someOtherField = String(StringBuilder(\"random2\"))\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class Z(val x: Int)\n"
        },
        {
            "code": "\nval map = mapOf<String, Any?>(\"x\" to null)\n\nval x: String by map\n\nfun main(args: Array<String>) {\n    println(x) // silently prints null, but should be NPE\n}\n"
        },
        {
            "code": "\ninline class Optional<out T> @Deprecated(\n    message = \"Not type-safe, use factory method\",\n    replaceWith = ReplaceWith(\"Inlined.of(_value)\")\n) constructor(private val _value: Any?) {\n    val value: T?\n        get() =\n            @Suppress(\"UNCHECKED_CAST\")\n            if (isPresent) _value as T\n            else null\n\n    val isPresent: Boolean\n        get() = _value != NULL\n\n    companion object {\n        @Suppress(\"DEPRECATION\")\n        fun <T> of(value: T) = Optional<T>(value)\n\n        fun <T : Any> ofNullable(value: T?): Optional<T> =\n            if (value == null) EMPTY\n            else of(value)\n\n        @Suppress(\"DEPRECATION\")\n        val EMPTY = Optional<Nothing>(NULL)\n    }\n\n    private object NULL\n}\n\ninline fun <T> Optional<T>.ifPresent(code: (T) -> Unit) {\n    @Suppress(\"UNCHECKED_CAST\")\n    if (isPresent) return code(value as T)\n}\n\nfun <T> Optional<T>.or(code: () -> T): T {\n    ifPresent { return it }\n    return code()\n}\n\nfun main() {\n    emptyOr { Optional.EMPTY }.value == null\n}\n\nfun <T> emptyOr(other: () -> T): T = Optional.EMPTY.or(other)\n"
        },
        {
            "code": "\nclass Test(map: Map<String, String>) {\n    var test by map\n}\n"
        },
        {
            "code": "\npublic inline operator fun <V, V1 : V> Map<in String, @Exact V>.getValue(thisRef: Any?, property: KProperty<*>): V1 =\n    getOrImplicitDefault(property.name) as V1\n\npublic inline operator fun <V, V1 : V> MutableMap<in String, out @Exact V>.getValue(thisRef: Any?, property: KProperty<*>): V1 =\n    getOrImplicitDefault(property.name) as V1\n\npublic inline fun <V> MutableMap<in String, in V>.getValue(thisRef: Any?, property: KProperty<*>): V =\n    getOrImplicitDefault(property.name) as V\n\npublic inline operator fun <V> MutableMap<in String, in V>.setValue(thisRef: Any?, property: KProperty<*>, value: V) {\n    this.put(property.name, value)\n}\n"
        },
        {
            "code": "\nfun main() {\n    sendTeamCityRequest {\n        val a = \"2\" // <==\n        val list = getList(ii, dd, ff, cc, ec.foo()).toMutableList()\n        if (list.isEmpty()) {\n            println(\"Empty list\")\n            var c = 2\n            c++\n        }\n        a.toInt()\n    }\n}\n"
        },
        {
            "code": "\nclass Region(\n    val width: Int,\n    val height: Int\n) {\n    fun contains1(x: Int, y: Int) =\n        x in 0 until width && y in 0 until height\n\n    fun contains2(x: Int, y: Int) =\n        x >= 0 && x < width && y >= 0 && y < height\n}\n"
        },
        {
            "code": "\nimport com.fasterxml.jackson.core.util.DefaultIndenter\nimport com.fasterxml.jackson.core.util.DefaultPrettyPrinter\nimport com.fasterxml.jackson.databind.ObjectMapper\nimport com.fasterxml.jackson.databind.SerializationFeature\nimport com.fasterxml.jackson.datatype.joda.JodaModule\nimport com.fasterxml.jackson.datatype.jsr310.JavaTimeModule\nimport com.fasterxml.jackson.module.kotlin.KotlinModule\nimport com.fasterxml.jackson.module.kotlin.readValue\nimport io.ktor.http.cio.websocket.Frame\nimport io.ktor.http.cio.websocket.readText\nimport kotlinx.coroutines.channels.ReceiveChannel\n\nobject Jackson {\n    val mapper = ObjectMapper()\n\n    fun configure() : ObjectMapper {\n        Jackson.configure(mapper)\n        return mapper\n    }\n\n    fun configure(mapper: ObjectMapper) {\n        mapper.configure(SerializationFeature.INDENT_OUTPUT, true)\n        mapper.setDefaultPrettyPrinter(DefaultPrettyPrinter().apply {\n            indentArraysWith(DefaultPrettyPrinter.FixedSpaceIndenter.instance)\n            indentObjectsWith(DefaultIndenter(\"  \", \"\\n\"))\n        })\n        mapper.registerModule(KotlinModule())\n        mapper.registerModule(JavaTimeModule())\n        mapper.registerModule(JodaModule())\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n    }\n\n    suspend inline fun <reified T> translate(incoming: ReceiveChannel<Frame>) : T {\n        return mapper.readValue((incoming.receive() as Frame.Text).readText())\n    }\n}\n"
        },
        {
            "code": "\n        when (val v:Char? = reader.readNoSpace()) {\n            '{' -> {\n                parseObject(visiter.objectValue());\n            }\n            null -> throw EOFException()\n            else -> reader.addFirst(v)\n        }\n"
        },
        {
            "code": "\nfun f<T>(): T = null as T\nval s = f<String>()\n"
        },
        {
            "code": "\nval map = mapOf<String, Any?>(\"x\" to null)\n\nval x: String by map\n\nfun main(args: Array<String>) {\n    println(x) // silently prints null, but should be NPE\n}\n"
        },
        {
            "code": "\nval isNaN = js(\"isNaN\") as (Double) -> Boolean\nprintln(isNaN(3.0))\n"
        },
        {
            "code": "\nval isNotANumber = js(\"isNaN\")(3.0) as Boolean\nprintln(isNotANumber) // false\n"
        },
        {
            "code": "\nfun isNaN(d: Double): Boolean = js(\"isNaN\")(d)\nprintln(isNaN(3.0)) // false\n"
        },
        {
            "code": "\nval isNotANumber = js(\"isNaN\") as (Double) -> Boolean\nprintln(isNotANumber(3.0)) // false\n"
        },
        {
            "code": "\nfun foo(channel: Int): ReceiveChannel<String> = GlobalScope.produce<String> {\n    val ch = Channel<Channel<String>>(1)\n    ch.send(Channel<String>())\n    ch.consumeEach {\n        try {\n            it.consumeEach {\n\n            }\n        } finally {\n            withContext(NonCancellable) {\n                println(\"$channel\")\n            }\n        }\n    }\n}\n\n@Test\nfun bar() = runBlocking<Unit> {\n    val x = foo(1)\n    delay(2000)\n    x.cancel()\n    delay(2000)\n}\n"
        },
        {
            "code": "\nval a: Int\nwithContext(coroutineContext) {\n    a = 7\n}\nassertEquals(expected = 7, actual = a)\n"
        },
        {
            "code": "\nval a: dynamic = \"1\"\nval b: Int = 1\nprintln(a == b) // true - ERROR?\nprintln(b == a) // false\nprintln(a.equals(b)) // false\nprintln(b.equals(a)) // false\n"
        },
        {
            "code": "\nfun test2(): String = when (String::class) {\n    Int::class -> \"1\"\n    String::class -> \"2\"\n    else -> \"0\"\n}\n"
        },
        {
            "code": "\nval map = mutableMapOf<String, String>()\n\ninline fun <reified T> get(key: String): T? =\n    map[key]?.let {\n        when (T::class) {\n            String::class -> it as T\n            Int::class -> it.toInt() as T\n            Float::class -> it.toFloat() as T\n            Double::class -> it.toDouble() as T\n            else -> throw IllegalArgumentException(\"Not implemented for the given type.\")\n        }\n    }\n\nfun test() {\n    map[\"count\"] = \"1\"\n\n    assert(getAsInt(\"count\") == 1)\n    assert(getAsIntOptimal(\"count\") == 1)\n}\n\n//inlined will all when branches, ~50 lines of bytecode\nprivate fun getAsInt(key: String) = get<Int>(key)\n\n//ideal result, ~10 lines of bytecode\nprivate fun getAsIntOptimal(key: String) = map[key]?.toInt()\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.runBlocking\n\n// { x: Int -> max(0, x) }\ntailrec suspend fun max0_outer(x: Int): Int = if(x > 0) max0_outer(x - 1) else x\n\n// local suspend\nsuspend fun outer_1(_x: Int): Int {\n    suspend fun max0_inner(x: Int): Int = if(x > 0) max0_inner(x - 1) else x\n    return max0_inner(_x)\n}\n\n// local tailrec\nfun outer_2(_x: Int): Int {\n    tailrec fun max0_inner(x: Int): Int = if(x > 0) max0_inner(x - 1) else x\n    return max0_inner(_x)\n}\n\n// local tailrec suspend\nsuspend fun outer_3(_x: Int): Int {\n    tailrec suspend fun max0_inner(x: Int): Int = if(x > 0) max0_inner(x - 1) else x\n    return max0_inner(_x)\n}\n\nfun main(args: Array<String>) {\n    runBlocking {\n        println(max0_outer(3)) // -> 0\n        println(outer_1(3))    // -> 0\n        println(outer_2(3))    // -> 0\n        println(outer_3(3))    // -> [program does not halt]\n    }\n}\n"
        },
        {
            "code": "\nprivate data class Box(val i: Int)\n\nprivate suspend fun foo(channel: ReceiveChannel<Box>) {\n    while (true) {\n        val value = channel.receive()\n        println(\"Received $value\")\n    }\n\n    yield()\n}\n\n@Test\nfun foo() = runBlocking<Unit> {\n    val channel = Channel<Box>(2)\n    launch {\n        foo(channel)\n        yield()\n    }\n\n    yield()\n    channel.send(Box(1)) // launched coroutine will be resumed with this value\n    channel.send(Box(2)) // This call won't suspend\n    yield()\n    val a =  2 // Put breakpoint here and inspect 'channel' state\n}\n"
        },
        {
            "code": "\ninline fun foo(x: () -> Any) = Pair(x(), x())\n\nfun main() {\n    val (x, y) = foo {\n        class C\n        C()\n    }\n    val (a, b) = foo {\n        object {}\n    }\n\n    println(x.javaClass == y.javaClass) // should print \"true\"\n    println(a.javaClass == b.javaClass) // should print \"true\"\n}\n"
        },
        {
            "code": "\ninline fun <reified E : Enum<E>> Configuration.enum(default: E, key: String? = null) = object : ReadWriteProperty<Configuration, E> {\n    override fun getValue(thisRef: Configuration, property: KProperty<*>): E {\n        return (thisRef[key ?: property.name].string)?.let { enumValueOf<E>(it) } ?: default\n    }\n\n    override fun setValue(thisRef: Configuration, property: KProperty<*>, value: E) {\n        thisRef[key ?: property.name] = value.name\n    }\n}\n"
        },
        {
            "code": "\ndata class Obj(val x: String)\nsuspend fun useWeak(ref: WeakReference<Obj>) = ref.get()\nfun main(args: Array<String>) {\n    runBlocking {\n        val ref = WeakReference(Obj(\"VALUE\"))\n\n        var value = useWeak(ref) // (1)\n        println(value)\n        value = null // (2)\n\n        System.gc()\n        Thread.sleep(100)\n        System.gc()\n        System.gc()\n\n        println(useWeak(ref))\n    }\n}\n"
        },
        {
            "code": "\n        println(useWeak(ref))\n"
        },
        {
            "code": "\nfun Char.toDigit() = this - '0'\n\nclass MyNumber(val s: String) {\n    companion object {\n        fun fromString(s: String) = MyNumber(s)\n    }\n\n    fun getDigit(index: Int) = s[index].toDigit()\n}\n"
        },
        {
            "code": "\nclass C {\n  val map: Map<String, Any> = mapOf<String, Any>()\n  fun f() {\n    for ((a, b) in map) {\n      println(\"$a $b\")\n    }\n  }\n}\n"
        },
        {
            "code": "\next.kotlin_version = '1.3.0-rc-146'\next.coroutines_version = '0.30.1-eap13'\n"
        },
        {
            "code": "\nrun(\"test\", f = { i -> })\n"
        },
        {
            "code": "\nval hi = \"hi\"\n\nfun main() {\n    println(hi?.length) // unnecessary safe call warning\n}\n"
        },
        {
            "code": "\n// IGNORE_BACKEND: JVM_IR, JVM\nfun i(): Boolean = null.equals(\"non-primitive\")\n\n//0 ACONST_NULL\n//0 INVOKESTATIC\n//1 ICONST_0\n"
        },
        {
            "code": "\nprivate fun foo(s: String?): String? = s?.trim() \n"
        },
        {
            "code": "\nclass KotlinConstPool {\n  init {\n    val x = java.lang.Byte.SIZE\n  }\n}\n"
        },
        {
            "code": "\nfun main() {\n    val x = Thing(42)\n    when (x) {\n        Thing(42) -> {\n            println(\"foo\")\n            x\n        }\n        else -> {\n            println(\"bar\")\n        }\n    }\n}\n\ninline class Thing(val value: Int)\n"
        },
        {
            "code": "\nfun main() {\n    when (val x = Thing(42)) {\n        Thing(42) -> {\n            println(\"foo\")\n            x\n        }\n        else -> {\n            println(\"bar\")\n        }\n    }\n}\n\ninline class Thing(val value: Int)\n"
        },
        {
            "code": "\npublic fun <T> Flow<T>.fastPathTake(count: Int): Flow<T> {\n    suspend fun FlowCollector<T>.emitAbort(value: T) {\n        emit(value)\n        throw CancellationException()\n    }\n\n    return unsafeFlow {\n        var consumed = 0\n        try {\n            collect { value ->\n                if (++consumed < count) {\n                    return@collect emit(value)\n                } else {\n                    return@collect emitAbort(value)\n                }\n            }\n        } catch (e: CancellationException) {\n            // Nothing, bail out\n        }\n    }\n}\n"
        },
        {
            "code": "\nprivate val xCache = mutableMapOf<String, X>()\n\nfun String.asX(): X = xCache.getOrPut(this) { X(this) }\n"
        },
        {
            "code": "\nval result = Result.success(\"yes!\")\nval other = Result.success(\"nope\")\n\nresult == other\nresult != other\n\nresult.equals(other)\n!result.equals(other)\n"
        },
        {
            "code": "\nval ans1 = runCatching { 42 }\nprintln(ans1)\n\nval ans2 = 42.runCatching { this }\nprintln(ans2)\n"
        },
        {
            "code": " kotlin\ninterface KotlinInterface {\n    val value: String?\n}\n"
        },
        {
            "code": "\nclass TheIssue : JavaMiddleAbstractClass(), KotlinInterface\n"
        },
        {
            "code": "\nclass Foo {\n  fun foo() {\n    \"crashMe\".let {\n      object : Any() {\n        override fun toString() = this@Foo.toString()\n      }\n    }.toString()\n  }\n}\n\nfun main() {\n  Foo().foo()\n}\n"
        },
        {
            "code": "\npackage foo\n\ninterface A\nclass B : A\n\ninline fun <T : A> foo(a: Any) = (a as? T != null).toString()[0]\n\nfun box(): String {\n    val s = \"\" + foo<B>(Any()) + foo<B>(object : A {}) + foo<B>(B())\n    if (s != \"ftt\") return \"fail: $s\"\n    return \"OK\"\n}\n\nfun main(args: Array<String>) {\n    println(box())\n}\n"
        },
        {
            "code": "\ninline class Z(val x: Int)\ninline class S(val s: String)\n\nfun test(a: Z, b: Z) = a == b\nfun test(a: S, b: S) = a == b\n"
        },
        {
            "code": "\npublic suspend inline fun <T> Flow<T>.collect(crossinline action: suspend (value: T) -> Unit): Unit =\n    collect(object : FlowCollector<T> {\n        override suspend fun emit(value: T) = action(value)\n    })\n"
        },
        {
            "code": "\nflow.collect {\n     foo() // suspend\n     bar() // do something else\n}\n"
        },
        {
            "code": "\npublic suspend inline fun <T> Flow<T>.collect(crossinline action: suspend (value: T) -> Unit): Unit =\n    collect(object : FlowCollector<T> {\n        @NoConcurrentCalls\n        override suspend fun emit(value: T) = action(value)\n    })\n"
        },
        {
            "code": "\nclass KotlinTest  {\n\n    var outerScopeVariable = \"test\"\n\n    val obj = object : Foo1 by Bar1(\n        object : Foo2 {\n            override fun getAccessible(): String {\n                return outerScopeVariable\n            }\n        }\n    ) {\n    }\n\n    @Test\n    fun `try to outerScopeVariable`() {\n        assertEquals(outerScopeVariable, obj.foo2.getAccessible())\n    }\n}\n\nclass Bar1(\n    override val foo2: Foo2\n) : Foo1\n\n\ninterface Foo1 {\n    val foo2: Foo2\n}\n\ninterface Foo2 {\n    fun getAccessible(): String\n}\n"
        },
        {
            "code": "\ninterface ParentInterface {\n    val child: ChildInterface\n}\n\ninterface ChildInterface {\n    val field: String\n}\n\nfun crash(data: String): ParentInterface =\n    Unit.let {\n        object : ParentInterface {\n            override val child = object : ChildInterface {\n                override val field = data\n            }\n        }\n    }\n\nfun main(arg: Array<String>) {\n    crash(\"test\")\n}\n"
        },
        {
            "code": "\n    @Suppress(\"INAPPLICABLE_JVM_NAME\")\n    @JvmName(\"monoMarkNow\")\n    override fun markNow(): MonoClockMark\n"
        },
        {
            "code": "\npackage kotlinjs.test\n\nclass Wrapper() {\n    inline fun someInline(x: Int, f: (Int) -> Unit) = f(x*x)\n    fun chainc(): Wrapper {\n        println(\"omitted?\")\n        return Wrapper()\n    }\n}\n\nfun main(args: Array<String>) {\n    Wrapper()\n        .chainc()\n        .someInline(2) {\n            print(\"in lambda $it\")\n        }\n}\n"
        },
        {
            "code": "\nobject `?` // compiles in Linux/JVM, compile crash in Windows/JVM, compile error in JS\nobject `*` // compiles in Linux/JVM, compile crash in Windows/JVM, compile error in JS\nobject `\"` // compiles in Linux/JVM, compile crash in Windows/JVM, compile error in JS\nobject `%JAVA_HOME%` // compiles in Linux/JVM, compiles in Windows/JVM, compile error in JS - but in Windows there can be problems with such file\n"
        },
        {
            "code": "\nimport org.junit.Test\n\nclass SampleTest {\n\n    @Test\n    fun `should crash with \"double quotes\" here test`() = lazy {\n        assert(true)\n    }.value\n}\n"
        },
        {
            "code": "\n@Test\nfun `break take(n)`() {\n    val numberOfThreads = 100\n\n    repeat(10000) {\n        val publishSubject = PublishSubject.create<Int>()\n        val actuallyReceived = AtomicInteger()\n\n        publishSubject.take(1).subscribe { actuallyReceived.incrementAndGet() }\n\n        val latch = CountDownLatch(numberOfThreads)\n        var threads = listOf<Thread>()\n\n        (0..numberOfThreads).forEach {\n            threads += thread(start = false) {\n                publishSubject.onNext(it)\n                latch.countDown()\n            }\n        }\n\n        threads.forEach { it.start() }\n\n        latch.await()\n\n        assertThat(actuallyReceived.get()).isEqualTo(1)\n    }\n}\n"
        },
        {
            "code": "\nannotation class Anno(val x: Array<String> = [\"\"])\n"
        },
        {
            "code": "\npackage test.p1\n\nabstract class Base {\n    protected var x = 42\n        private set\n\n    protected abstract fun foo()\n}\n"
        },
        {
            "code": "\npackage test.p2\n\nimport test.p1.Base\n\nclass Derived : Base() {\n    override fun foo() {\n        {\n            x.toString()\n        }()\n    }\n}\n"
        },
        {
            "code": "\n// just lo-o-o-ong name\nclass A012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678\n// the same for interface and object\ninterface I012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678\nobject O012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678\n\n// Plain long name aren't true problem - this case is rare and synthetic. \n// More problematic is the case with nested classes:\nclass A012345678901234567890123456789 { // just only 31 symbol and 8 nested levels\n    class A012345678901234567890123456789 {\n        class A012345678901234567890123456789 {\n            class A012345678901234567890123456789 {\n                class A012345678901234567890123456789 {\n                    class A012345678901234567890123456789 {\n                        class A012345678901234567890123456789 {\n                            class A012345678901234567890123456789 {\n\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun test() {\n   channelFlow {\n      send(run {\n         yield()\n      })\n   }\n}\n"
        },
        {
            "code": "\npackage com.example\n\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.runBlocking\n\nopen class Base {\n    private suspend fun wait() {\n        delay(500)\n    }\n\n    fun callBase() = runBlocking {\n        wait()\n    }\n}\n\nclass Derived: Base() {\n    private suspend fun wait() {\n        delay(100)\n    }\n\n    fun callDerived() = runBlocking {\n        wait()\n    }\n}\n\nfun main() {\n    Base().callBase()\n    Derived().callDerived()\n}\n\n"
        },
        {
            "code": "\npackage flow\n\ninterface FlowCollector<T> {\n    suspend fun emit(value: T)\n}\n\ninterface Flow<T : Any> {\n    suspend fun collect(collector: FlowCollector<T>)\n}\n\nabstract class FuseableFlow<T : Any, R : Any>() : Flow<R> {}\n\ntypealias Transformer<T, R> = suspend (T) -> R?\n\npublic inline fun <T : Any> flow(crossinline block: suspend FlowCollector<T>.() -> Unit) = object : Flow<T> {\n    override suspend fun collect(collector: FlowCollector<T>) = collector.block()\n}\n\nsuspend inline fun <T : Any> Flow<T>.collect(crossinline action: suspend (T) -> Unit): Unit =\n    collect(object : FlowCollector<T> {\n        override suspend fun emit(value: T) = action(value)\n    })\n\npublic suspend fun <T: Any> Flow<T>.awaitSingle(): T {\n    var result: T? = null\n    collect {\n        if (result != null) error(\"Expected only one element\")\n        result = it\n    }\n\n    return result ?: throw NoSuchElementException(\"Expected at least one element\")\n}\n"
        },
        {
            "code": "\ninline fun <T : Any, R : Any> Flow<T>.transform(crossinline transformer: Transformer<T, R>): Flow<R> =\n    object : FuseableFlow<T, R>() {\n        override suspend fun collect(collector: FlowCollector<R>)=\n            this@transform.collect { value: T ->\n                val r = transformer(value)\n                if (r != null) collector.emit(r)\n            }\n    }\n"
        },
        {
            "code": "\ninline fun <T : Any, R : Any> Flow<T>.fusedMap(\n    crossinline transform: suspend (T) -> R\n) = transform { transform(it) }\n\ninline fun <T : Any> Flow<T>.fusedFilter(crossinline predicate: suspend (T) -> Boolean) =\n    transform { if (predicate(it)) it else it }\n\nsuspend fun main() {\n    println(flow<Int> {\n        repeat(1) {\n            emit(it)\n        }\n    }.fusedMap { it + 1 }\n        .fusedFilter { true }.awaitSingle())\n}\n"
        },
        {
            "code": "\ninline fun <T : Any, R : Any> Flow<T>.transform(crossinline transformer: Transformer<T, R>): Flow<R> =\n    object : FuseableFlow<T, R>() {\n        override suspend fun collect(collector: FlowCollector<R>)=\n            this@transform.collect { value: T ->\n                val r = transformer(value)\n                collector.emit(r!!)\n            }\n    }\n"
        },
        {
            "code": "\n\nexpect class ByteBuffer {\n    fun order(order: ByteOrder): ByteBuffer\n    //...\n}\n"
        },
        {
            "code": "\nactual class ByteBuffer {\n    var order: ByteOrder = ByteOrder.BIG_ENDIAN\n\n    actual fun order(order: ByteOrder): ByteBuffer {\n        this.order = order\n        return this\n    }\n}\n"
        },
        {
            "code": "\ninternal class JsonReader(private val source: String) {\n    private var tokenPosition: Int = 0\n\n    internal inline fun requireTokenClass(expected: Byte, errorMessage: (Char) -> String) {\n        if (tokenClass != expected) fail(errorMessage(tokenClass.toChar()), tokenPosition)\n    }\n}\n"
        },
        {
            "code": "\n@Suppress(\"REDUNDANT_INLINE_SUSPEND_FUNCTION_TYPE\")\nsuspend inline fun <reified R : Resource> PipelineContext<Unit, ApplicationCall>.handleSimpleResourceCreation (\n    creationFunction: suspend (res: R) -> Boolean\n) {\n    try {\n        val rec = call.receive<R>()\n        val res = creationFunction.invoke(rec)\n        if (res) {\n            call.respond(HttpStatusCode.Created)\n        } else {\n            call.respond(HttpStatusCode.InternalServerError)\n        }\n    } catch (e: ContentTransformationException) {\n        call.respond(HttpStatusCode.BadRequest)\n    }\n}\n"
        },
        {
            "code": "\npost(\"/user\") {\n        handleSimpleResourceCreation<User> { UserService.add(it) }\n}\n"
        },
        {
            "code": "\nassertFileContains(\"$pathPrefix/exampleapp.js.map\", \"\\\"../../src/main/kotlin/exampleapp/main.kt\\\"\")\n"
        },
        {
            "code": "\nassertFileContains(\"$pathPrefix/examplelib.js.map\", \"\\\"../../../libraryProject/src/main/kotlin/examplelib/lib.kt\\\"\")\n"
        },
        {
            "code": "\nkotlinOptions.sourceMapPrefix = \"./\"\n"
        },
        {
            "code": "\nfun main() {\n    val obj = \"Hello World\"\n    val engine = ScriptEngineManager().getEngineByExtension(\"kts\")\n    engine.put(\"binding\", obj)\n    engine.eval(\n    \"\"\"\n        Thread({ \n            try {\n                println(binding)\n            } catch(ex: Throwable) {\n                ex.printStackTrace()\n            }\n        }).start()\n    \"\"\".trimIndent())\n}\n"
        },
        {
            "code": "\nimport java.io.*\nimport java.lang.reflect.*\n\ninterface A {\n    @JvmDefault @Throws(IOException::class)\n    fun foo(): Any = \"\"\n}\n\ninterface B : A {\n    @JvmDefault @Throws(IOException::class)\n    override fun foo(): String = \"\"\n}\n\nfun main() {\n    val bc = B::class.java\n    val p = Proxy.newProxyInstance(bc.classLoader, arrayOf(bc)) { proxy, method, args ->\n        throw IOException(\"Test on $method\")\n    }\n    val result = runCatching { (p as A).foo() }\n    println(result)\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.runBlocking\n\nclass Test {\n    fun foo() {\n        suspend fun connectToSocket() {\n            suspend fun process() {\n                connectToSocket()\n            }\n            process()\n        }\n        runBlocking {\n            connectToSocket()\n        }\n    }\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\nfun main() {\n    suspend fun test() {\n        withContext(Dispatchers.Default) {\n            test()\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun main() {\n    val list = arrayOf(1)\n    println(list[4])\n}\n"
        },
        {
            "code": "\npublic inline fun <reified T : Throwable> assertFailsWith(block: () -> Unit) {\n    try {\n        block()\n        error(\"Should not be reached\")\n    } catch (e: Throwable) {\n        assertTrue(e is T)\n    }\n}\n"
        },
        {
            "code": "\nfun myRun(block: () -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\nfun case_1() {\n    val tt: Int\n    myRun {\n        tt = 10\n    }\n}\n\n/* Without initialization in lambda is OK\nfun case_1() {\n    val tt: Int\n    myRun { }\n}\n*/\n\nfun main(args : Array<String>) {\n    case_1()\n}\n"
        },
        {
            "code": "\nprivate fun main(args: Array<String>) {\n  if (undefined === null) {\n    println(\"lol\")\n  }\n}\n"
        },
        {
            "code": "\nfun bar(x: String? = \"hello\") {\n    println(x)\n}\n\nprivate fun main(args: Array<String>) {\n    val x: String? = undefined\n    bar(x)\n}\n"
        },
        {
            "code": "\nimport java.util.function.Supplier\n\nfun main() {\n    printAndGetBean {\n        object : AbstractBean() {\n            override fun value() = 42\n        }\n    }\n}\n\nabstract class AbstractBean {\n    abstract fun value(): Int\n}\n\ninline fun <reified T : Any> printAndGetBean(crossinline function: () -> T): T {\n    println(T::class.java.name)\n    return Supplier { function.invoke() }.get()\n}\n"
        },
        {
            "code": "\nfun f() =\n    g { x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24 -> x3 }\n\ninline fun g(h: (Int,Int,Int,Int,Int,Int,Int,Int,Int,Int,Int,Int,Int,Int,Int,Int,Int,Int,Int,Int,Int,Int,Int,Int) -> Int) =\n    h(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24)\n"
        },
        {
            "code": "\n\nclass TestCase{\n    var stop = false\n\n    suspend fun start() {\n        coroutineScope {\n            repeat(\n                1\n            ) {\n                launch {\n                    while (!stop) {\n                        try {\n\n                        } finally {\n                            withContext(Dispatchers.Default) {\n                                println(1)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nfun main() = runBlocking {\n    TestCase().start()\n}\n"
        },
        {
            "code": "\nfun call(block: () -> Unit): Unit = TODO()\n\nclass A {\n    \n    private fun a(x: String) = run {\n        {\n            x\n            call {\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\npackage code\n\nimport utils.doSomething\n\nfun main(args: Array<String>) {\n    doSomething(Path())\n}\n\nclass Path {\n    val events: String = \"hello\"\n}\n"
        },
        {
            "code": "\npackage utils\n\nimport code.Path\n\ninline fun doSomething(path: Path) {\n    path::events\n}\n"
        },
        {
            "code": "\npackage com.testapp.ui.common.test\n\nimport android.os.Bundle\n\nfun launch() {\n    DerivedFragment().onActivityCreated(null)\n}\n\nabstract class BaseFragment<TViewModel : BaseViewModel> {\n\n    protected lateinit var viewModel: TViewModel\n        private set\n\n    open fun onActivityCreated(savedInstanceState: Bundle?) {\n        viewModel = retrieveViewModel()\n    }\n\n    protected abstract fun retrieveViewModel(): TViewModel\n}\n\nclass DerivedFragment : BaseFragment<DerivedViewModel>() {\n\n    override fun onActivityCreated(savedInstanceState: Bundle?) {\n        super.onActivityCreated(savedInstanceState)\n\n        // Change to this for function refs to work:\n//        val vm = viewModel\n//        bind(vm::property)\n\n        // Comment out to work:\n        bind(viewModel::property)\n    }\n\n    override fun retrieveViewModel(): DerivedViewModel = DerivedViewModel()\n\n    private inline fun <T> bind(crossinline viewModelGet: () -> T?) {\n        setOnFocusChangeListener { viewModelGet() }\n    }\n\n    private fun setOnFocusChangeListener(l: () -> Unit) {\n    }\n}\n\nabstract class BaseViewModel\n\nclass DerivedViewModel : BaseViewModel() {\n\n    var property: String? = null\n}\n"
        },
        {
            "code": "\n@kotlin.internal.InlineOnly\npublic inline val prop: Int\n    get() = 5\n\npublic inline fun method(f: (Int) -> Unit) {\n    f(prop)\n}\n"
        },
        {
            "code": "\npackage ca.cutterslade.kotlin.bug.suspendinlineuse\n\nimport kotlinx.coroutines.runBlocking\n\nclass CloseableThing : AutoCloseable {\n  override fun close() = Unit\n}\n\nfun main() {\n  runBlocking {\n    CloseableThing().doSomethingAndClose(::something)\n  }\n}\n\nsuspend fun something(thing: CloseableThing) {\n  println(thing)\n}\n\nsuspend inline fun CloseableThing.doSomethingAndClose(\n    something: suspend (CloseableThing) -> Unit\n): Unit = use { something(this) }\n"
        },
        {
            "code": "\npackage a.b.c\n\nfun main() {\n  Class.forName(\"a.b.c.X\")\n}\n\nclass X {\n  val num = 42\n  val map: Int = 1.apply {\n    object : Y({ true }) {\n      override fun fun1() {\n        println(num)\n      }\n    }\n  }\n}\n\nabstract class Y(val lambda: () -> Boolean) {\n  abstract fun fun1()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    Foo().run {\n        object : Abstract(arrayOf(\"\").map {\n            buildString {\n                append(getString(it))\n            }\n        }) {\n        }\n    }\n}\n\nfun Foo.getString(it: String) = \"\"\n\nabstract class Abstract(val list: List<String>)\nclass Foo\n"
        },
        {
            "code": "\nopen class A {\n    fun toto() {\n        if (this is B) {\n            C()\n        }\n    }\n}\n\nclass B: A() { inner class C }\n\nfun main(args: Array<String>) {\n    B().toto()\n}\n"
        },
        {
            "code": "\nval x = foo()\nfun foo() {\n    notYetInitialized // val is null due to initialization order, but static analyzer sees 'Nothing' and thinks control flow ends up here\n    println(\"Static analyzer thinks that this code is unreachable, but you will see it in output anyway\") // [UNREACHABLE_CODE] Unreachable code\n}\nval notYetInitialized: Nothing = throw Exception()\n\nfun main() {}\n"
        },
        {
            "code": "\nfun <T> Any?.asGeneric() = this as? T //There is warning about unchecked cast here\n\nfun main()\n{\n\t42.asGeneric<Nothing>()!!\n\tprintln(\"Static analyzer thinks that this code is unreachable, but you will see it in output anyway\") //Unreachable code, but will be executed\n}\n"
        },
        {
            "code": "\nval tryExecUnreachable = execUnreachable() //Initialized before notYetInitialized\nfun execUnreachable()\n{\n\tnotYetInitialized //This variable is null right now, because of initialization order. No access to this variable, so there is no NPE, but static analyzer see 'Nothing' and thinks control flow ends up here\n\tprintln(\"Static analyzer thinks that this code is unreachable, but you will see it in output anyway\") //Unreachable code, but will be executed\n}\n\nval notYetInitialized : Nothing = initFail() //'Instance' of Nothing, by the way, it is meant to be impossible\nfun initFail() : Nothing = throw Exception(\"Crash with exception eventually\") //This example will crash here when it will be time to initialize 'notYetInitialized' variable\n\nfun main()\n{\n\ttryExecUnreachable //Use it somehow\n}\n"
        },
        {
            "code": "\nclass KotlinCode : JavaCode() {\n\n    val inputStreamAdvanced: java.io.InputStream = instance.AdvancedInputStream()\n\n    companion object {\n        val instance = KotlinCode()\n    }\n\n    override fun process() {\n        print(\"\")\n    }\n}\n\nfun main() {\n    KotlinCode.instance.inputStreamAdvanced.read()\n}\n"
        },
        {
            "code": " kotlin\ninterface Foo {\n    @Synchronized\n    fun foo() {}\n}\n"
        },
        {
            "code": " kotlin\nclass C : Foo\n"
        },
        {
            "code": "\nclass A<T>{}\nfun <T: Any> A<T>.foo(expected: T) : A<T> = TODO()\ninline fun <reified T : Any> A<T?>.foo(expected: T?) : A<T?> = TODO()\n"
        },
        {
            "code": "\ninterface A\n\ninterface B : A {\n    fun f(s: String = \"default\"): String\n}\n\nclass C : B {\n    override fun f(s: String): String = s\n}\n"
        },
        {
            "code": "\nfun callF(c: C) {\n    // invokestatic B$DefaultImpls.f$default(...)\n    c.f()\n}\n"
        },
        {
            "code": "\nfun getSomeString(): String {\n    val x: String? = null\n    return x.allowNull()\n}\n\nfun <T> T?.allowNull(): T = this as T\n\n\nvar nullableString: String? = \"some value\"\nnullableString = getSomeString()\nprintln(nullableString == null)\n"
        },
        {
            "code": "\nclass C{\n    open inner class A\n    fun f(): A{\n        open class B : A()\n    \tval v = object : B() {}\n        return v\n    }\n}\n"
        },
        {
            "code": "\nfun <T> foo(num: T): String = when (num) {\n        is Int -> \"int\"\n        is Double -> \"dbl\"\n\telse -> \"else\"\n}\n\n\nfun main() {\n    val a = 5\n    val d = 3.141593\n    println(foo(a))\n    println(foo(d))\n}\n"
        },
        {
            "code": "\nint\nint\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    var a : Any = 1 // Int\n    if (a is Double) {\n        a += 1.5\n    }\n    println(a)\n}\n"
        },
        {
            "code": "\n@Serializable\ninline class Age(val inner: Int)\n"
        },
        {
            "code": "\nfun main() {\n    println(JSON.parse(User.serializer(), \"\"\" {\"s\":\"2\"} \"\"\"))\n}\n\n@Serializable\ndata class User(\n    val age: Age\n)\n\ninline class Age(val value: String)\n"
        },
        {
            "code": "\n@Serializable\ndata class User(\n  @Serializable(with = AgeSerializer::class)\n  val age: Age\n)\n\n@Serializer(forClass = Age::class)\nobject AgeSerializer : KSerializer<Age> {\n    override val descriptor: SerialDescriptor = StringDescriptor.withName(\"Age\")\n\n    override fun deserialize(input: Decoder): Age {\n        val age = input.decodeString()\n        return Age(age)\n    }\n\n    override fun serialize(output: Encoder, obj: Age) {\n        output.encodeString(obj.age)\n    }\n}\n"
        },
        {
            "code": "\ninline class Age(val value: Int)\n"
        },
        {
            "code": "\nclass Category(val id: CategoryId, private val usersWithAccess: Set<UserId>) {\n    fun isAccessibleBy(user: User): Boolean = usersWithAccess.any { it == user.id }\n}\n"
        },
        {
            "code": "\nprivate class Impl(val foo: Int)\n"
        },
        {
            "code": "\nfun <T: Any> foo(t: T): List<T> = TODO()\n@JsName(\"bar\")\nfun <T: Any> foo(t: T?): List<T?> = TODO()\n"
        },
        {
            "code": "\nfun <T: Any> foo(t: T): List<T> = TODO()\n@JsName(\"bar\")\ninline fun <T: Any> foo(t: T?): List<T?> = TODO()\n"
        },
        {
            "code": "\nList(10) { 1_500_000 }.asSequence().map { size ->\n    List(size, Int::toString)\n}.forEach {\n    println(\"size: ${it.size}\")\n}\n"
        },
        {
            "code": "\nval sequence = List(10) { 1_500_000 }.asSequence().map { size ->\n    List(size, Int::toString)\n}\nval iterator = sequence.iterator()\nwhile (iterator.hasNext()) {\n    val next = iterator.next()\n    println(\"size: ${next.size}\")\n}\n"
        },
        {
            "code": "\n@Deprecated(\"\")\n@get:JvmName(\"mapIntIntHex\")\nval Map<Int, Int>.hex: String get() = TODO()\n\n@Deprecated(\"\")\n@get:JvmName(\"mapIntByteHex\")\nval Map<Int, Byte>.hex: String get() = TODO()\n"
        },
        {
            "code": "\ninline  class Texture(val id: Int) {\n\tfun generate() {\n\t\tcheckBound()\n\t}\n\tcompanion object {\n\t\tprivate inline fun Texture.checkBound(){\n\t\t\tcheck(boundTexture == this)\n\t\t}\n\t\tprivate var boundTexture: Texture? = null\n\t}\n}\n"
        },
        {
            "code": "\ninline class ResultOrClosed(val x: Any?)\ninterface A<T> {\n    fun foo(): T\n}\n\nclass B : A<ResultOrClosed> {\n    override fun foo(): ResultOrClosed = ResultOrClosed(\"\")\n}\n\nfun main() {\n    val foo1: Any = ResultOrClosed(\"\")\n    val foo2: Any = (B() as A<ResultOrClosed>).foo()\n\n    println(foo1 is ResultOrClosed) // prints true\n    println(foo2 is ResultOrClosed) // prints false\n}\n"
        },
        {
            "code": "\ninterface A {\n    fun foo(): Any\n}\n\nclass B : A {\n    override fun foo(): String { // Covariant override, return type is more specialized than in the parent\n        return \"\"\n    }\n}\n"
        },
        {
            "code": "\ninterface GenericA<T> {\n    fun foo(): T\n}\n\nclass SpecializedB : GenericA<String> {\n    override fun foo(): String {\n        return \"\"\n    }\n}\n"
        },
        {
            "code": "\ninline class ICAny(val a: Any)\n"
        },
        {
            "code": "\nfun foo(i: ICAny) {}\n"
        },
        {
            "code": "\ninline class ICAny(val a: Any)\n\ninterface A {\n    fun foo(): Any\n}\n\nclass B : A {\n    override fun foo(): ICAny {\n        TODO()\n    }\n}\n"
        },
        {
            "code": "\ninterface A {\n    fun foo(): Any\n}\n\nclass B : A {\n    override fun foo(): ICAny {\n        return ICAny(4)\n    }\n}\n\nfun test() {\n    val foo1: Any = ICAny(42)\n    val foo2: Any = (B() as A).foo()\n    println(foo1 is ICAny) // prints true\n    println(foo2 is ICAny) // prints false\n}\n"
        },
        {
            "code": "\nfun bar(a: Any) {}\n\nfun test(ic: ICAny) { // ic has type of Object in JVM-signature\n    bar(ic) // OK, but value of ic will be boxed into ICAny before passing to bar\n}\n"
        },
        {
            "code": "\nfun test() {\n    val foo1: Any = ICAny(42) // boxed version of ICAny because we assign it to variable of type Any\n    val foo2: Any = (B() as A).foo() // unboxed version because of a bug and return type of foo in A is Any\n    println(foo1 is ICAny) // prints true\n    println(foo2 is ICAny) // prints false\n}\n"
        },
        {
            "code": "\ninterface PrimitiveA {\n    fun foo(): Any\n}\n\nclass PrimitiveB : PrimitiveA {\n    override fun foo(): Int {\n        return 42\n    }\n}\n"
        },
        {
            "code": "\ninline class ICAny(val a: Any)\n\ninterface A {\n    fun foo(): Any\n}\n\nclass B : A {\n    override fun foo(): ICAny {\n        TODO()\n    }\n}\n"
        },
        {
            "code": "\ninterface GenericA<T> {\n    fun foo(): T\n}\n\nclass SpecializedB : GenericA<ICAny> {\n    override fun foo(): ICAny { \n        return \"\"\n    }\n}\n"
        },
        {
            "code": "\ninline class InlineClass(val i: Int)\n\n@Test\nfun foo() = runBlocking {\n    val result = InlineClass(42)\n    flowOf(result)\n        .combineLatest(\n            flowOf(42)\n        ) { f, _ -> f }\n        .collect()\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.intrinsics.*\n\nsuspend inline fun foo() = suspendCoroutineUninterceptedOrReturn<String> {\n    error(\"Failed\")\n}\n\n// Extra     INVOKESTATIC kotlin/jvm/internal/InlineMarker.mark (I)V invocation in here\nsuspend fun bar() {\n    foo() \n}\n"
        },
        {
            "code": "\n// Kotlin\nfun main() {\n    val intFoo = IntFoo(42)\n    println(intFoo.getFoo()) // 42\n\n    val stringFoo = StringFoo(\"foo\") \n    println(stringFoo.getFoo()) // ERROR: Expected: \"foo\", Actual: undefined\n\n    val intFoo2 = IntFoo2(73) \n    println(intFoo2.getFoo()) // 73\n}\n\nclass IntFoo(foo: Int) : Foo(foo)\n\nclass StringFoo(foo: String) : Foo(foo)\n\nclass IntFoo2 : Foo {\n    constructor(foo: Int) : super(foo)\n}\n\nopen external class Foo(foo: Int) {\n    constructor(foo: String)\n\n    fun getFoo(): String\n}\n"
        },
        {
            "code": "\n// JS\nfunction Foo(foo) {\n    this.foo = foo;\n}\n\nFoo.prototype.constructor = Foo;\n\nFoo.prototype.getFoo = function () {\n    return this.foo;\n}\n"
        },
        {
            "code": "\nopen class A\n\ninline fun <T> call(lambda: () -> T): T {\n    return lambda()\n}\n\nfun main(args: Array<String>) {\n    val x = 1\n    val result = call {\n        object : A() {\n            val p = x\n        }\n    }\n\n    result.p\n}\n"
        },
        {
            "code": "\n@JvmOverloads\nfun defFun(d: Boolean = false) { println(d) }\nfun defUse() { defFun() }\n"
        },
        {
            "code": "\nfun defFun() { defFun(d = false) }\n"
        },
        {
            "code": "\n/*\n * Execution fails due to a type error on trying to get the\n * prototype of undefined. It turns out, it tries to access\n * \"Kotlin.kotlin.Number\" (In my own gradle-based build, exact path\n * may vary), which is never actually defined.\n */\n\nfun main(args: Array<String>) {\n    // This should just print \"2\"\n    println(CustomInteger(2))\n}\n\n// Class that extends \"kotlin.Number\"\nclass CustomInteger(private var value: Int = 0) : Number() {\n    override fun toString() = value.toString()\n    override fun toByte() = value.toByte()\n    override fun toShort() = value.toShort()\n    override fun toInt() = value\n    override fun toLong() = value.toLong()\n    override fun toFloat() = value.toFloat()\n    override fun toDouble() = value.toDouble()\n    override fun toChar() = value.toChar()\n}\n"
        },
        {
            "code": "\nexternal open class Foo {\n    open fun foo(foo: String)\n    \n    open fun foo(foo: Int)\n}\n\nopen class Bar : Foo()\n\nclass Baz : Bar() // ERROR: JavaScript name foo is generated for different inherited members: fun foo(foo: String): Unit and fun foo(foo: Int): Unit\n"
        },
        {
            "code": "\nfun main() {\n    MyMap<Unit,Unit>().entries\n}\n\nclass MyMap<K,V>: AbstractMap<K, V>() {\n    override val entries: HashSet<Map.Entry<K, V>>\n        get() = hashSetOf()\n    override val keys: Set<K>\n        get() = setOf()\n    override val values: Collection<V>\n        get() = listOf()\n}\n"
        },
        {
            "code": "\nfun main() {\n    MyMap<Unit,Unit>().entries\n}\n\nclass MyMap<K,V>: AbstractMap<K, V>() {\n    fun getEntries(): Set<Map.Entry<K, V>> {\n        println(\"getEntries\")\n        return createEntries()\n    }\n    override val entries: HashSet<Map.Entry<K, V>>\n        get() {\n            println(\"entries\")\n            return createEntries()\n        }\n    private fun createEntries(): HashSet<Map.Entry<K, V>> {\n        return hashSetOf()\n    }\n\n    override val keys: Set<K>\n        get() = hashSetOf()\n    override val values: Collection<V>\n        get() = listOf()\n}\n"
        },
        {
            "code": "\nclass MyMap : AbstractMap<String, String>() {\n    override val entries: HashSet<Map.Entry<String, String>> = HashSet()\n}\n"
        },
        {
            "code": "\nclass MyMap : AbstractMap<String, String>() {\n    override val entries: Set<Map.Entry<String, String>> = HashSet()\n}\n"
        },
        {
            "code": "\nclass Foo {\n\n    @Test\n    fun testStart() {\n        start()\n    }\n\n    fun start() {\n        runBlocking {\n            launch {\n                try {\n                    doWork()\n                } catch (e: Throwable) {\n                    e.printStackTrace()\n                }\n            }\n        }\n    }\n\n    private suspend fun doWork() {\n        var i = 0\n        while (++i != 2) {\n            yield() // <- this line\n        }\n        fail()\n    }\n\n    private fun fail() {\n        throw RuntimeException()\n    }\n}\n"
        },
        {
            "code": "\ninterface A\nfun main(vararg args: String){\n    println(object: A{}::class.java.simpleName)\n}\n"
        },
        {
            "code": "\n    class C {\n        var s: String = \"aaa\"\n    }\n\n    fun F(c: C?): String\n    {\n        return c?.s ?: \"null\"\n    }\n"
        },
        {
            "code": "\nfun foo(s: String) =\n    s.indexOf(\"foo\").takeIf { it >= 0 } ?: s.length\n"
        },
        {
            "code": "\nclass C(val s: String?)\n\nfun test1(x: C?) =\n        x?.run { s?.length } ?: 0\n\nfun test2(x: C?) =\n        x?.s?.length ?: 0\n"
        },
        {
            "code": "\nfun main(args: Array<String>) = runBlocking {\n    launch(CommonPool) {\n        val startMs = System.currentTimeMillis()\n        while (isActive) {\n            val timeMs = System.currentTimeMillis()\n            val diffMs = timeMs - startMs\n            val elapsedSecs = Math.round(diffMs / 1000f)\n            println(\"Time: $elapsedSecs\")\n            delay((elapsedSecs + 1) * 1000 - diffMs)    // startMs, timeMs, diffMs and elapsedSecs stored here\n        }\n    }\n    delay(20000L)\n}\n"
        },
        {
            "code": "\ninline fun foo(crossinline cb: () -> Unit) {\nval lambda = { cb() }\nlambda()\n}\n\nfoo { println(\"hello\") }\n"
        },
        {
            "code": "\nclass Test : HashSet<Int>()\n{\n\toverride fun remove(element: Int): Boolean\n\t{\n\t\tsynchronized(this)\n\t\t{\n\t\t\treturn super.remove(element)\n\t\t}\n\t}\n}\n"
        },
        {
            "code": "\ninline class WrappingInt(val value: Int) {\n    operator fun inc(): WrappingInt = plus(1)\n    operator fun plus(num: Int): WrappingInt = WrappingInt((value + num) and 0xFFFF)\n}\n\nfun main() {\n    var x = WrappingInt(65535)\n    x++\n    println(x) // prints 0 (correct)\n\n    var y = WrappingInt(65535)\n    ++y\n    println(y) // prints 65536\n}\n"
        },
        {
            "code": "\npackage c\n\nclass Derived : b.Base() {\n  fun accessor1() = { a.Base.name }\n  fun accessor2() = { b.Base.name }\n}\n"
        },
        {
            "code": "\npublic class Goo {\n    private val boo = object : Any() {\n        public inline fun <reified T> foo(): T? {\n            return null\n        }\n    }\n    \n    fun goo():String? {return boo.foo()}\n}\n\nfun main(args: Array<String>) {\n    var x : String? = Goo().goo()\n    println(x)\n}\n"
        },
        {
            "code": "\nclass SomeClass {\n    private val innerObject = object {\n        private inline fun bar(action: () -> Unit) {\n            action()\n        }\n\n        fun foo() {\n            bar { println(\"foo\") }\n        }\n    }\n}\n"
        },
        {
            "code": "\nclass SomeClass {\n    private val innerObject = InnerObject()\n    class InnerObject {\n        private inline fun bar(action: () -> Unit) {\n            action()\n        }\n\n        fun foo() {\n            bar { println(\"foo\") }\n        }\n    }\n}\n"
        },
        {
            "code": "\nsuspend fun foo() {\n    suspendCoroutineUninterceptedOrReturn<Unit> {\n        COROUTINE_SUSPENDED\n    }\n}\n"
        },
        {
            "code": "\nsuspend fun foo() =\n    suspendCoroutineUninterceptedOrReturn<Unit> {\n        COROUTINE_SUSPENDED\n    }\n"
        },
        {
            "code": "\ninterface HasValue {\n    val value: Int\n\n    fun defaultParameter(withParameter: Int = 1) {\n        println(\"defaultParameter call with $withParameter\")\n    }\n    fun noDefaultParameter(withParameter: Int) {\n        println(\"noDefaultParameter call with $withParameter\")\n    }\n}\n\ninline class InlinedCertainValue(override val value: Int): HasValue\n\nfun main() {\n    val a = InlinedCertainValue(100)\n    a.defaultParameter() // Comment this line out and you will not get a code generation exception\n    a.noDefaultParameter(25)\n    a.defaultParameter(66)\n}\n"
        },
        {
            "code": "\nprivate fun foo() {}\n\nprivate suspend fun bar() = suspendCoroutine<Unit> {\n    foo()\n}\n"
        },
        {
            "code": "\nfun main() {\n  suspend fun innerFunction() {\n    suspend {\n      innerFunction()\n    }\n  }\n}\n"
        },
        {
            "code": "\nclass SimpleTest {\n    suspend fun testInvoke(action: suspend () -> Unit) {\n        action()\n    }\n\n    @Test\n    fun first() = runBlocking {\n        testInvoke {\n            returnResult()\n                ?: throw RuntimeException(\"fail\") // Line 18\n        }\n    }\n\n    @Test\n    fun second() = runBlocking {\n        testInvoke { // line 24\n            returnResult() ?: throw RuntimeException(\"fail\") // line 25\n        }\n    }\n\n    suspend fun returnResult(): Boolean? {\n        return null\n    }\n}\n"
        },
        {
            "code": "\n/* generated by dukat */ external open class A {\n    open fun foo()\n    open fun foo(p: Int)\n}\n\n/* abstract or */ open class B : A() // <--- OK. No errors\n\nclass C : B() // <--- Error: JavaScript name foo is generated for different inherited members: fun foo(): Unit and fun foo(p: Int): Unit\n"
        },
        {
            "code": "\nopen external class MyJsClass(\n    a: Int,\n    b: Int = definedExternally,\n    c: Int = definedExternally\n)\n\nval obj = object : MyJsClass(3) {}\n"
        },
        {
            "code": "\nexternal interface Test {\n  fun removeAsync(vararg keys: String, callback: () -> Unit)\n}\n\nsuspend fun Test.remove(vararg keys: String) = suspendCoroutine<Unit> { c ->\n  removeAsync(*keys) {\n    c.resume(Unit)\n  }\n}\n"
        },
        {
            "code": "\nclass X {\n    open inner class Y\n\n    fun foo() {\n        with(X()) {\n            object : Y() {}\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    X().foo()\n}\n"
        },
        {
            "code": "\nfun <T, R> with2(receiver: T, block: T.() -> R): R = receiver.block()\n\nclass X {\n    open inner class Y\n\n    fun foo() {\n        with2(X()) {\n            object : Y() {}\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    X().foo()\n}\n"
        },
        {
            "code": "\ninterface Base {\n    fun value(): String\n}\n\ninterface SubA : Base\n\ninterface SubB : Base {\n    @JvmDefault\n    override fun value(): String = \"value\"\n}\n\ninterface SubAB : SubA, SubB\n"
        },
        {
            "code": "\nclass Environment(\n    val fieldAccessedInsideChild: Int,\n    val how: Environment.() -> Unit\n)\n\nfun main(args: Array<String>) {\n    Environment(\n        3,\n        {\n            class Child {\n                val a = fieldAccessedInsideChild\n            }\n\n            class Parent {\n                val children: List<Child> =\n                    (0..4).map { Child() }\n            }\n        }\n    )\n}\n\n"
        },
        {
            "code": "\ninterface Inf\n\nclass KotlinBugCase0 {\n    private val outVar = \"ok\"\n\n    val foo = \"anything\".let {\n        object : Inf {\n            init {\n                println(outVar)\n            }\n        }\n    }\n}\n\nclass KotlinBugCase1 {\n    val foo = \"anything\"?.let {\n        object : Inf {\n            init {\n                println(\"ok\")\n            }\n        }\n    }\n}\n\nclass KotlinBugCase2 {\n    private val outVar = \"wrong\"\n\n    val foo = \"anything\"?.let {\n        object : Inf {\n            init {\n                println(outVar)\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    KotlinBugCase0()\n    KotlinBugCase1()\n    KotlinBugCase2()\n}\n"
        },
        {
            "code": "\npackage com.example.myapplication\n\nimport io.reactivex.Observable\nimport io.reactivex.Observer\nimport io.reactivex.disposables.Disposable\n\nclass Foo {\n    val runnable: () -> Unit = {\n        val value = 0\n        val flag: Int? = 0\n\n        flag?.let {\n            Observable.empty<Int>().subscribeWith(object : Observer<Int> {\n                override fun onSubscribe(d: Disposable) {}\n\n                override fun onComplete() {\n                    value.toString()\n                }\n\n                override fun onError(e: Throwable) {}\n\n                override fun onNext(data: Int) {}\n            })\n        }\n    }\n}\n\nfun main() {\n    Foo().runnable()\n}\n"
        },
        {
            "code": " kotlin\nabstract class A(val x : Any?)\nobject B : A(C)\nobject C : A(B)\n\nfun main(args: Array<String>) {\n    println(B.x)\n    println(C.x) // null\n}\n"
        },
        {
            "code": "\ntypealias Lambda = (\n    Int, Int, Int, Int, Int, Int, Int, Int,\n    Int, Int, Int, Int, Int, Int, Int, Int,\n    Int, Int, Int, Int, Int, Int, Int\n) -> Unit // 23 arguments\n\nclass A : Lambda {\n    override fun invoke(\n        p1: Int, p2: Int, p3: Int, p4: Int,\n        p5: Int, p6: Int, p7: Int, p8: Int,\n        p9: Int, p10: Int, p11: Int, p12: Int,\n        p13: Int, p14: Int, p15: Int, p16: Int,\n        p17: Int, p18: Int, p19: Int, p20: Int,\n        p21: Int, p22: Int, p23: Int\n    ) {\n    }\n}\n\nfun main() {\n    val a = A()\n    println(a is Lambda)\n}\n"
        },
        {
            "code": "\nobject Sum : (Int, Int) -> Int, (Int, Int, Int) -> Int {\n    // looks like I'm reinventing Clojure, but actually I don't\n    override fun invoke(p1: Int, p2: Int) = p1 + p2\n    override fun invoke(p1: Int, p2: Int) = p1 + p2 + p3\n}\n"
        },
        {
            "code": "\nSum is Function<*> // true, as expected â it's just INSTANCEOF\nSum is Function1<*, *> // false, as expected, our arities are 2 and 3\nSum is Function2<*, *> // true, as expected\nSum is Function3<*, *> // false! Despite IDE shows that expression is always true\n"
        },
        {
            "code": "\nfun doit() {\n    print(3)\n}\n"
        },
        {
            "code": "\nfun Double.coerceToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"NaN\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> toLong()\n}\n"
        },
        {
            "code": "\nfun main() {\n    val iter = J.NULL_ARRAY.iterator()\n    println(iter.hasNext())\n}\n"
        },
        {
            "code": "\nfun main() = println(true xor false) // prints '1'\n"
        },
        {
            "code": "\nclass Test {\n    fun test() {\n        guard(true).otherwise {\n            println(\"guard failed!\")\n            return\n        }\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private fun guard(condition: Boolean) = object {\n        inline fun otherwise(otherwise: () -> Unit) {\n            if (!condition) {\n                otherwise()\n            }\n        }\n    }\n}\n\nTest().test()\n"
        },
        {
            "code": "\ndata class Example @JvmOverloads constructor(\n        var one: String = \"\",\n        var two: String = \"\",\n        var three: String = \"\",\n        var four: String = \"\",\n        var five: String = \"\",\n        var six: String = \"\",\n        var seven: String = \"\",\n        var eight: String = \"\",\n        var nine: String = \"\",\n        var ten: String = \"\",\n        var eleven: String = \"\",\n        var twelve: String = \"\",\n        var thirteen: String = \"\",\n        var fourteen: String = \"\",\n        var fifteen: String = \"\",\n        var sixteen: String = \"\",\n        var seventeen: String = \"\",\n        var eighteen: String = \"\",\n        var nineteen: String = \"\",\n        var twenty: String = \"\",\n        var twentyOne: String = \"\",\n        var twentyTwo: String = \"\",\n        var twentyThree: String = \"\",\n        var twentyFour: String = \"\",\n        var twentyFive: String = \"\",\n        var twentySix: String = \"\",\n        var twentySeven: String = \"\",\n        var twentyEight: String = \"\",\n        var twentyNine: String = \"\",\n        var thirty: String = \"\",\n        var thirtyOne: String = \"\",\n        var thirtyTwo: String = \"\",\n        var thirtyThree: String = \"\",\n        var thirtyFour: String = \"\"\n)\n"
        },
        {
            "code": "\nclass A {\n    companion object {\n// public final static synthetic access$getFoo$cp()I\n        private val foo = 1\n        \n        fun bar() = foo\n    }\n}\n"
        },
        {
            "code": "\nfun <T: Int> cast(origin: Any): T? = origin as? T\n\nfun main() {\n    val castFun = cast<Int>(\"123\")\n    println(castFun)\n}\n"
        },
        {
            "code": "\ninline class Foo(val value: Int)\n\nclass Bar {\n    fun <F: Foo> F.foo() = \"Hello World\"\n    val foo = Foo(0).foo()      // this line will throw error\n}\n"
        },
        {
            "code": "\ninline fun <reified T, reified R>T.castTo(): R = this as R\n\nfun case1(): Int = \n    null.castTo<Int?, Int>()\n\nfun case2(): Int = \n    (null as Int?) as Int\n\nfun main(args: Array<String>) {\n    val cases = listOf(::case1, ::case2)\n    \n    for ((i, fn) in cases.withIndices()) {\n        try {\n            val x = fn()\n        } \n        catch (x: Throwable) {\n            println(\"case${i+1}: $x\")\n        }\n    }\n}\n"
        },
        {
            "code": "\nval a : Int? = null\nprint(a!!)\n"
        },
        {
            "code": "\n    class K<T>() where T : Any, T : CharSequence? {\n        fun f(x: T) {} // No null check\n    }\n    "
        },
        {
            "code": "\n    class K<T>() where T : Any?, T : CharSequence {\n        fun cast(x: Any?) {\n            val a = x as T // No null check\n            println(a)\n        }\n    }\n    "
        },
        {
            "code": "\n    fun <T> foo(s: T): Int where T : String?, T : CharSequence =\n        when (s) { // No null check\n            \"1\" -> 1\n            else -> 0\n        }\n    "
        },
        {
            "code": "\n    class K<T>(var x: T) where T : Any, T : CharSequence?\n\n    val prop = K<String>(\"\")::x as KMutableProperty0<Any?>\n    prop.set(null)  // No exception\n    "
        },
        {
            "code": "\nfun main() {\n    // BUG IS HERE. Expected: [1], Actual []\n    println(\n        sequenceOf(1, 2, 3)\n            .filterNot { (it == 2) or (it == 3) }\n            .toList()\n    )\n    \n    // NOTE 1: Replacing the 'or' operator by || fixes the problem\n    println(\n        sequenceOf(1, 2, 3)\n            .filterNot { (it == 2) || (it == 3) }\n            .toList()\n    )\n\n    // NOTE 2: Using lists rather than sequences also fixes the problem\n    println(\n        listOf(1, 2, 3)\n            .filterNot { (it == 2) || (it == 3) }\n    )\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.*\n\nfun test(k: KClass<*>, a: Any) {\n    println(k.toString())\n    println(k.hashCode())\n    val c = a::class\n    println(c.toString())\n    println(c.hashCode())\n    println()\n}\n\nfun main(args: Array<String>){\ntest(1::class, 1)\ntest(1L::class, 1L)\ntest(1.0::class, 1.0)\ntest(1.1::class, 1.1)\ntest(1.0f::class, 1.0f)\ntest(1.1f::class, 1.1f)\ntest(\"\"::class, \"\")\ntest({}::class, {})\ntest(A()::class, A())\n}\n\nclass A\n"
        },
        {
            "code": "\nclass Int\n73679\nclass Int\n73679\n\nclass Long\n2374300\nclass Long\n2374300\n\nclass Double\n2052876273\nclass Int\n73679\n\nclass Double\n2052876273\nclass Double\n2052876273\n\nclass Float\n67973692\nclass Int\n73679\n\nclass Float\n67973692\nclass Double\n2052876273\n\nclass String\n-1808118735\nclass String\n-1808118735\n\nclass Function0\n1863395128\nclass Function0\n1863395128\n\nclass A\n65\nclass A\n65\n"
        },
        {
            "code": "\nfun main() {\n    println(foo(Result.runCatching { 1 }) + 1)\n}\n\nfun <T> foo(a: Result<T>): T = bar(a) { \n    println(it)\n    it.getOrThrow()\n}\n\nfun <T, R> bar(value: T, f: (T) -> R): R {\n    return f(value)\n}\n"
        },
        {
            "code": "\nclass A\n\nprintln(1::class.toString())\nprintln(1::class.hashCode())\nprintln(1L::class.toString())\nprintln(1L::class.hashCode())\nprintln(1.0::class.toString())\nprintln(1.0::class.hashCode())\nprintln(1.0f::class.toString())\nprintln(1.0f::class.hashCode())\nprintln(\"\"::class.toString())\nprintln(\"\"::class.hashCode())\nprintln({}::class.toString())\nprintln({}::class.hashCode())\nprintln(A()::class.toString())\nprintln(A()::class.hashCode())\n"
        },
        {
            "code": "\n//import java.util.*\n\nval testData = mapOf (\n        \"Annotation\" to {Annotation::class},\n        \"Any\" to {Any::class},\n        \"Array\" to {Array<Any>::class}, //<Any>\n        \"AssertionError\" to {AssertionError::class},\n        \"Boolean\" to {Boolean::class},\n        \"BooleanArray\" to {BooleanArray::class},\n        \"Byte\" to {Byte::class},\n        \"ByteArray\" to {ByteArray::class},\n        \"Char\" to {Char::class},\n        \"CharArray\" to {CharArray::class},\n        \"CharSequence\" to {CharSequence::class},\n        \"ClassCastException\" to {ClassCastException::class},\n        \"Comparable\" to {Comparable::class},\n        \"Comparator\" to {Comparator::class},\n        \"ConcurrentModificationException\" to {ConcurrentModificationException::class}, //java.util\n        \"Deprecated\" to {Deprecated::class},\n        \"DeprecationLevel\" to {DeprecationLevel::class},\n        \"Double\" to {Double::class},\n        \"DoubleArray\" to {DoubleArray::class},\n        \"DslMarker\" to {DslMarker::class},\n        \"Enum\" to {Enum::class},\n        \"Error\" to {Error::class},\n        \"Exception\" to {Exception::class},\n        \"ExtensionFunctionType\" to {ExtensionFunctionType::class},\n        \"Float\" to {Float::class},\n        \"FloatArray\" to {FloatArray::class},\n        \"Function\" to {Function::class},\n        \"IllegalArgumentException\" to {IllegalArgumentException::class},\n        \"IllegalStateException\" to {IllegalStateException::class},\n        \"IndexOutOfBoundsException\" to {IndexOutOfBoundsException::class},\n        \"Int\" to {Int::class},\n        \"IntArray\" to {IntArray::class},\n        \"KotlinVersion\" to {KotlinVersion::class},\n        \"Lazy\" to {Lazy::class},\n        \"LazyThreadSafetyMode\" to {LazyThreadSafetyMode::class},\n        \"Long\" to {Long::class},\n        \"LongArray\" to {LongArray::class},\n        \"NoSuchElementException\" to {NoSuchElementException::class},\n        \"Nothing\" to {Nothing::class},\n        \"NotImplementedError\" to {NotImplementedError::class},\n        \"NoWhenBranchMatchedException\" to {NoWhenBranchMatchedException::class},\n        \"NullPointerException\" to {NullPointerException::class},\n        \"Number\" to {Number::class},\n        \"NumberFormatException\" to {NumberFormatException::class},\n        \"Pair\" to {Pair::class},\n        \"ParameterName\" to {ParameterName::class},\n        \"PublishedApi\" to {PublishedApi::class},\n        \"ReplaceWith\" to {ReplaceWith::class},\n        \"RuntimeException\" to {RuntimeException::class},\n        \"Short\" to {Short::class},\n        \"ShortArray\" to {ShortArray::class},\n        \"SinceKotlin\" to {SinceKotlin::class},\n        \"String\" to {String::class},\n        \"Suppress\" to {Suppress::class},\n        \"Synchronized\" to {Synchronized::class},\n        \"Throwable\" to {Throwable::class},\n        \"Triple\" to {Triple::class},\n        \"Unit\" to {Unit::class},\n        \"UnsafeVariance\" to {UnsafeVariance::class},\n        \"UnsupportedOperationException\" to {UnsupportedOperationException::class},\n        \"Volatile\" to {Volatile::class}\n)\nfun test(name : String, f: () -> Any) : String = try {\n    f().toString()\n} catch (e : Throwable) {\n    \"!!! - $e\"\n}\n\nfun main(args: Array<String>) {\n\n    for ((name, function) in testData) {\n        val res = test(name, function).toString()\n        val comment = when {\n            res.startsWith(\"!!!\") -> \"Exception!\"\n            !res.contains(name) -> \"No real name\"\n            else -> \"OK\"\n        }\n\n        println(\"|$name|$res|$comment|\")\n    }\n\n}\n"
        },
        {
            "code": "\n    fun main(args: Array<String>) {\n        try {\n            try {\n                return //or break, continue + for\n            } catch (fail: Throwable) {\n                println(\"catch\")\n            }\n        } finally {\n            println(\"finally\")\n            throw RuntimeException()\n        }\n    }\n"
        },
        {
            "code": "\ninline fun inlineFun(block: (String)-> String) {\n    try {\n        try {\n            block(\"lambda\")\n        } catch (fail: Throwable) {\n            println(\"catch\")\n        }\n    } finally {\n        println(\"finally\")\n        throw RuntimeException()\n    }\n\n}\n\nfun test() {\n    inlineFun {\n        println(\"lambda\")\n        return\n    }\n}\n\nfun main(args: Array<String>) {\n    test()\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.experimental.*\nimport kotlinx.coroutines.experimental.channels.*\n\nfun main(args: Array<String>) = runBlocking {\n    val channel = Channel<Int>(10)\n    for (i in 1..5) channel.send(i)\n    println(\"BOOM\") // BREAKPOINT HERE\n}\n"
        },
        {
            "code": "\nfun f<T>(): T = null as T\nval s = f<String>() // Should call an NPE if flag is enabled\n"
        },
        {
            "code": "\nval map = mapOf<String, Any?>(\"x\" to null)\n\nval x: String by map\n\nfun main(args: Array<String>) {\n    println(x) // silently prints null, but should be NPE\n}\n"
        },
        {
            "code": "\nfun <T> any(): @JvmUnchecked T = null as T\n\nfun foo() {\n    any<String>() // When KT-8135 is fixed this call should not throw NPE\n}\n"
        },
        {
            "code": "\ninterface A {\n    fun foo(x: Int): Int\n}\n\nabstract class B {\n    abstract fun foo(x: Int = 42): Int\n}\n\nclass C : A, B() {\n    override fun foo(x: Int) = x\n}\n\nfun main(args: Array<String>) {\n    println(C().foo())\n}\n"
        },
        {
            "code": "\nprivate inline fun <reified T: Any> type() = T::class\nfun main(args: Array<String>) {\n    println(type<Byte>().js.name)    // Number\n    println(type<Short>().js.name)   // Number\n    println(type<Int>().js.name)     // Number\n    println(type<Long>().js.name)    // Number\n    println(type<Float>().js.name)   // Number\n    println(type<Double>().js.name)  // Number\n\n    println(type<Char>().js.name)    // BoxedChar,\n    println(type<Boolean>().js.name) // Boolean,\n\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    example<Int>()\n}\ninline fun <reified T: Any> example() {\n    println(T::class == \"1\".toInt()::class) // true\n    println(\"1\".toInt()::class == T::class) // false\n    println(Int::class.isInstance(\"1\".toInt())) // true\n    println(T::class.isInstance(\"1\".toInt())) // false\n}\n"
        },
        {
            "code": "\nfun <T: Any> KClass<T>.safeCastNullable(subject: Any?): T? {\n    if (subject == null) {\n        return null\n    }\n    //this == subject::class added because isInstance doesn't work with reified simple types\n    if (this == subject::class || isInstance(subject)) {\n        @Suppress(\"UNCHECKED_CAST\")\n        return subject as T\n    } else {\n        throw ClassCastException(\"${subject::class} can not be cast to $this\")\n    }\n}\n"
        },
        {
            "code": " kotlin\ninline fun <reified T> x() {\n    println(T::class)\n}\n\nfun main() {\n    x<ByteArray>()\n    x<String>()\n    println(ByteArray::class)\n}\n"
        },
        {
            "code": "\nclass ByteArray\nclass String\nclass ByteArray\n"
        },
        {
            "code": "\nenum class TestType {\n    ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN\n}\n\nclass TestClass {\n    fun testMethod(type: TestType): String {\n        val testFloat: Float = when (type) {\n            TestType.ONE -> 1000.0f\n            TestType.TWO -> 5000.0f\n            TestType.THREE -> 10000.0f\n            TestType.FOUR -> 1609.34f\n            TestType.FIVE -> 8046.72f\n            TestType.SIX -> 16093.4f\n            else -> 5f\n        }\n        val before = \"Before alloc type=$type testFloat=$testFloat\\n\"\n        Log.e(\"TestClass\", \"Before alloc type=$type testFloat=$testFloat\") // testFloat=1000.0f as expected\n\n        val dummyObjects = List(200_000) { 1024 }\n\n        Log.e(\"TestClass\", \"After alloc type=$type testFloat=$testFloat\") // testFloat=0.0f - expected to be 1000.0f\n        return before + \"After alloc type=$type testFloat=$testFloat\" \n    }\n}\n"
        },
        {
            "code": "\nimport org.junit.Test\nimport kotlin.test.assertNotSame\nimport kotlin.test.assertSame\n\nclass HigherOrderLambdaTest {\n\n    @Test\n    fun `higher-order lambda with lambda, instances same`() {\n        val provider = {\n            { Unit }\n        }\n\n        assertSame(provider.invoke(), provider.invoke())\n    }\n\n    @Test\n    fun `higher-order lambda with object, instances not same`() {\n        val provider = {\n            object : () -> Unit {\n                override fun invoke() = Unit\n            }\n        }\n\n        assertNotSame(provider.invoke(), provider.invoke())\n    }\n\n    @Test\n    fun `higher-order lambda with lambda and side effect, instances not same`() {\n        val provider = {\n            val sideEffect = false\n            { sideEffect }\n        }\n\n        assertNotSame(provider.invoke(), provider.invoke())\n    }\n}\n\n"
        },
        {
            "code": "\nclass MyViewGroup : ViewGroup {\n    @JvmOverloads\n    constructor(context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : super(context, attrs, defStyleAttr)\n\n    override fun setOnClickListener(listener: OnClickListener?) {\n        if (listener == null) return super.setOnClickListener(null)\n\n        super.setOnClickListener(OnClickListener { // <<< here\n            // whatever\n        })\n    }\n\n    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) = Unit\n}\n"
        },
        {
            "code": "\ninline fun f() = document.createElement(\"div\") { }\n"
        },
        {
            "code": "\n0.until(1).map { f() }\n"
        },
        {
            "code": "\nclass HelloKotlinJs: React.Component(){\n    fun render(): dynamic{\n        return React.createElement(ReactNative.Text, null, \"I'm a Component from Kotlin!!!\")\n    }\n\n    fun render2() = React.createElement(ReactNative.Text, null, \"I'm a Component from Kotlin!!!\")\n}\n"
        },
        {
            "code": "\nval response = window.fetch(url, object: RequestInit {\n        override var method: String? = method\n        override var body: dynamic = body\n        override var credentials: RequestCredentials? = \"same-origin\".asDynamic()\n        override var headers: dynamic = json(\"Accept\" to \"application/json\")\n    }).await()\n"
        },
        {
            "code": "\n        manager.commandCompletions.registerAsyncCompletion(\"settlements\") { _ ->\n            useDB {\n                TSettlements.slice(TSettlements.name).selectAll().map { it[TSettlements.name] }\n            }\n        }\n"
        },
        {
            "code": "\nimport javafx.application.Application\nimport javafx.scene.Scene\nimport javafx.scene.control.Label\nimport javafx.scene.layout.StackPane\nimport javafx.stage.Stage\n\npublic class ApplicationSample : Application() {\n    override fun start(stage: Stage) {\n        val sceneRoot = StackPane(Label(\"content\"))\n        val scene = Scene(sceneRoot, 200.0, 200.0)\n        stage.setScene(scene)\n        stage.show()\n    }\n}\n\nfun main(args: Array<String>) {\n    Application.launch(javaClass<ApplicationSample>(), *args)\n}\n"
        },
        {
            "code": "\nfun main() {\n    val result = Result.runCatching { \"Test 01\" }\n    val errorResult = Result.runCatching { throw java.io.IOException(\"Some error happened\") }\n    \n    println(\"Test\")\n    println(test(\"Test 01\", result))\n    println(test(\"Some error happened\", errorResult))\n    \n    println()\n    println(\"With generics\")\n    println(match(\"Test 01\", \"Some error happened\").test(result))\n    println(match(\"Test 01\", \"Some error happened\").test(errorResult))\n    \n    println()\n    println(\"With kotlintest dsl-like\")\n    println(result should match(\"Test 01\", \"Some error happened\"))\n    println(errorResult should match(\"Test 01\", \"Some error happened\"))\n}\n\ninfix fun <T> T.should(matcher: Matcher<T>) = matcher.test(this)\n\nfun test(expectedValue: String, result: Result<String>) = if (result.isSuccess) {\n    expectedValue == result.getOrNull()\n} else {\n    expectedValue == result.exceptionOrNull()?.message\n}\n\nfun <T> match(expectedValue: T, errorMessage: String) = object: Matcher<Result<T>> {\n    override fun test(value: Result<T>) = if (value.isSuccess) {\n        print(\"I'm a success\")\n        Pair(\n            value.getOrNull() == expectedValue,\n            Pair(value.getOrNull(), expectedValue)\n        )\n    } else {\n        print(\"I'm an error\")\n        Pair(\n            value.exceptionOrNull()?.message == errorMessage,\n            Pair(value.exceptionOrNull()?.message, errorMessage)\n        )\n    }\n}\n\ninterface Matcher<T> {\n    fun test(value: T): Pair<Boolean, Pair<Any?, Any?>>\n}\n"
        },
        {
            "code": "-kotlin\ninline class FieldValue(val value: String)\n\nenum class RequestFields {\n    ENUM_ONE\n}\n\nprivate data class RequestInputParameters(\n    private val backingMap: Map<RequestFields, FieldValue>\n) : Map<RequestFields, FieldValue> by backingMap\n\nfun main() {\n    val testMap = mapOf(RequestFields.ENUM_ONE to FieldValue(\"value1\"))\n    val test = testMap[RequestFields.ENUM_ONE] // works!\n    println(test)\n\n    val testMap2 = RequestInputParameters(mapOf(RequestFields.ENUM_ONE to FieldValue(\"value1\")))\n    val test2 = testMap2[RequestFields.ENUM_ONE] // does not work :-(\n    println(test2)\n}\n"
        },
        {
            "code": "\nannotation class Annotation {\n    companion object {\n        @JvmStatic val TEST_FIELD = \"\"\n    }\n}\n\nfun main() {\n    println(Annotation.TEST_FIELD)\n}\n"
        },
        {
            "code": "\nimport kotlin.test.Test\n\nclass SampleTests {\n\n    @Test\n    fun demonstrateBug() {\n        TestList().removeAt(0)\n    }\n}\n\n\nclass TestList : MutableListBase<String>() {\n\n    override fun removeAt(index: Int): String {\n        return \"\"\n    }\n\n}\n\n"
        },
        {
            "code": "\n\nabstract class ListBase<out E> : List<E> {\n\n    val lastIndex: Int\n        get() = TODO()\n\n    override fun indexOf(element: @UnsafeVariance E): Int {\n        TODO()\n    }\n\n    override fun lastIndexOf(element: @UnsafeVariance E): Int {\n        TODO()\n    }\n\n    override fun contains(element: @UnsafeVariance E): Boolean {\n        TODO()\n    }\n\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean {\n        TODO()\n    }\n\n    override fun isEmpty(): Boolean {\n        TODO()\n    }\n\n    override fun iterator(): Iterator<E> {\n        TODO()\n    }\n\n    override fun listIterator(): ListIterator<E> {\n        TODO()\n    }\n\n    override fun listIterator(index: Int): ListIterator<E> {\n        TODO()\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<E> {\n        TODO()\n    }\n}\n\nabstract class MutableListBase<E> : ListBase<E>(), MutableList<E> {\n\n    override fun add(index: Int, element: E) {\n        TODO()\n    }\n\n    override val size: Int\n        get() = TODO()\n\n    override fun get(index: Int): E = TODO()\n\n    override fun set(index: Int, element: E): E {\n        TODO()\n    }\n\n    override fun add(element: E): Boolean {\n        TODO()\n    }\n\n    override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        TODO()\n    }\n\n    override fun addAll(elements: Collection<E>): Boolean {\n        TODO()\n    }\n\n    override fun remove(element: E): Boolean {\n        TODO()\n    }\n\n    override fun removeAll(elements: Collection<E>): Boolean {\n        TODO()\n    }\n\n    override fun retainAll(elements: Collection<E>): Boolean {\n        TODO()\n    }\n\n    override fun clear() {\n        TODO()\n    }\n\n    override fun iterator(): MutableIterator<E> {\n        TODO()\n    }\n\n    override fun listIterator(): MutableListIterator<E> {\n        TODO()\n    }\n\n    override fun listIterator(index: Int): MutableListIterator<E> {\n        TODO()\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> {\n        TODO()\n    }\n}\n"
        },
        {
            "code": "\n  var size: Long\n    internal set\n\n  fun copyTo(\n    out: Buffer,\n    offset: Long = 0L,\n    byteCount: Long = size - offset\n  ): Buffer\n"
        },
        {
            "code": "\nexternal open class TypeScriptParent {\n    companion object {\n        var prop: String\n        fun foo(): String\n    }\n    open fun show(): Unit\n}\n\nclass KotlinChild : TypeScriptParent()\n\nfun main() {\n    KotlinChild().show()\n}\n\n// output;\n// undefined\n// TypeError: this.constructor.foo is not a function\n"
        },
        {
            "code": "\njs(\"Object\").setPrototypeOf(KotlinChild::class.js, TypeScriptParent::class.js)\n"
        },
        {
            "code": "\nval headers = js(\"{'Content-Type':'application/json'}\")\n\nval headers = js(\"\"\"{\"Content-Type\":\"application/json\"}\"\"\")\n"
        },
        {
            "code": "\nval o = js(\"{}\")\no[\"Content-Type\"] = \"application/json\"\n"
        },
        {
            "code": "\nclass Foo(val i: Int) {\n    init {\n        val z = \"42\"\n        val zz = z.toInt()\n    }\n}\n"
        },
        {
            "code": "\npackage test1\n\nprivate interface PrivateInFileInterface\n\nclass Public1 : PrivateInFileInterface\nclass Public2 : PrivateInFileInterface\n"
        },
        {
            "code": "\npackage test2\n\nimport test1.Public1\nimport test1.Public2\n\nfun main(args: Array<String>) {\n    println(listOf(Public1(), Public2())) // (*)\n    // ^^^\n    // Exception in thread \"main\" java.lang.IllegalAccessError:\n    //     tried to access class test1.PrivateInFileInterface from class test2.TestIAE2Kt\n}\n"
        },
        {
            "code": "\ninline class Z(val i: Int)\n\nclass A(val x : Z = Z(0)) {\n    constructor(x: Z, y: Z) : this(y) {}\n}\n"
        },
        {
            "code": "\nval x: List<Int> = y()\n\nval z: List<Int> = listOf(1)\n\nfun y(): List<Int> = z\n\nfun main() {\n  println(x.toString())\n}\n"
        },
        {
            "code": "\nfun <T> something(): T = Any() as T\n\nclass Context<T>\n\nfun <T> Any.decodeIn(typeFrom: Context<in T>): T = something()\n\nfun <T> Any?.decodeOut(typeFrom: Context<out T>): T {\n    return this?.decodeIn(typeFrom) ?: error(\"\")  // decodeIn result is of type Nothing\n}\n\nfun main(args: Array<String>) {\n    val r = \"str\".decodeOut(Context<Any>())\n    println(r)\n}\n"
        },
        {
            "code": "\nval dynamicVal: dynamic = null\nprintln(\"${dynamicVal?.foo()}\")\n"
        },
        {
            "code": "\nval value: dynamic = foo();\nvalue.hashCode()\n"
        },
        {
            "code": "\nvar value = this.foo();\nhashCode(value); // I expect value.hashCode(), because value is external third party object (I don't need Kotlin hashCode() method)\n"
        },
        {
            "code": "\nenum class X(y : Y) {A(Y.B);\n    init {\n        when (y) {Y.B -> {}}\n    }\n    \n    fun neverCall(x : X) {\n        when(x) {X.A -> {}}\n    }\n}\n\nenum class Y() {B }\n\nfun main(args: Array<String>) {\n    print(X.A)\n}\n"
        },
        {
            "code": "\nfun main() {\n    testSafe(Test(\"Tom\"))\n    testSafe(null)\n\n    println(\"---------\")\n\n    testBug(Test(\"Tom\"))\n    testBug(null)\n}\n\nfun testBug(test: Test?) {\n    println(test?.Inner()?.thing)\n}\n\nfun testSafe(test: Test?) {\n    println(test?.createInner()?.thing)\n}\n\nclass Test(val name: String) {\n    inner class Inner {\n        val thing: String\n            get() = \"Hello, $name\"\n    }\n\n    fun createInner() = Inner()\n}\n"
        },
        {
            "code": "\ndata class Something(\n        val colorsByString: Map<String, Color>\n)\n\nenum class Color {\n    RED, BLUE;\n}\n"
        },
        {
            "code": "\nval x = listOf(\"asd\")\nprintln(x::class)\n"
        },
        {
            "code": "\ninline fun <reified T> typeOf(x: T) = typeOf<T>()\n"
        },
        {
            "code": "\nval x = listOf(\"asd\")\nprintln(typeOf(x))\n"
        },
        {
            "code": "\nval x = null\nprintln(typeOf(x))\n"
        },
        {
            "code": "\n// module \"core\"\nsuspend fun suspendedCast(arg: String) = arg as Any\n\nsuspend inline fun throwCompilerError(token: String?) {\n    token?.let { suspendedCast(it) }\n}\n\n// module \"sample\"\nsuspend fun main() {\n    // this will throw a compiler error as it is in a separate module\n    throwCompilerError(\"any string or null\")\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n\n    val context = object : Interface, AnotherInterface {\n        override val guy: AnotherInterface get() = this\n    }\n\n    with(context) {\n        TargetClass(\"Here we go!\")\n            .perform()\n    }\n\n}\n\ndata class TargetClass(val value: String)\n\ninterface Interface {\n\n    val guy: AnotherInterface\n\n    fun TargetClass.perform() {\n        println(\"Target class perform\")\n\n        DifferentClass(value)\n            .perform()\n    }\n\n    private fun DifferentClass.perform() = with(guy) {\n        perform()\n    }\n\n}\n\ndata class DifferentClass(val value: String)\n\ninterface AnotherInterface {\n\n    fun DifferentClass.perform() {\n        println(\"DifferentClass perform\")\n    }\n\n}\n"
        },
        {
            "code": "\ndata class Report(val content: String)\ntypealias Reporter = (Report) -> Unit\n\nfun reporterA(report:Report) { println(\"A: $report\")}\nfun reporterB(report:Report) { println(\"B: $report\")}\n\nclass CompositeReporter(val delegates:Array<out Reporter>):Reporter {\n    override fun invoke(report: Report) {\n       delegates.forEach { reporter -> reporter(report) }\n    }\n}\nfun main(){\n    val reporter = CompositeReporter(arrayOf(::reporterA, ::reporterB))\n    reporter(Report(\"Content\"))\n}\n"
        },
        {
            "code": "\ndata class StringBox(val inside: String)\n\nclass BuggyClass(private val strings: List<String>) {\n\n    init {\n        strings.forEachIndexed { i, vv ->\n            @Suppress(\"USELESS_IS_CHECK\")\n            if (vv !is String) throw IllegalArgumentException(\"${\"${\"strings\"}[$i]\"} should be ${String::class.simpleName} but is ${vv.constructor.name}\")\n        }\n    }\n\n    // making this constructor the primary makes the bug disappear\n    constructor(s: List<StringBox>) : this(\n            strings = s\n            // using the following line will result in:\n            //     IllegalArgumentException: strings[0] should be String but is BuggyClass\n                    .map(StringBox::inside)\n            // the following will give the correct result\n//                    .map { it.inside }\n    )\n}\n\n// calling the following from JS triggers the bug\nfun make() = BuggyClass(listOf(StringBox(\"Lorem ipsum\")))\n"
        },
        {
            "code": "\nexternal interface Node\n\nexternal interface IGraph {\n    fun createNode(): Node\n}\n\nexternal open class DefaultGraph : IGraph {\n    override fun createNode() = definedExternally\n}\n\nfun main() {\n    val graph1 = DefaultGraph()\n    val node1 = graph1.createNode() // Nothing\n\n    val graph2: IGraph = DefaultGraph()\n    val node2 = graph2.createNode() // Node\n}\n"
        },
        {
            "code": "\nclass KotlinBug {\n    interface Inf {\n        fun print(string: String)\n    }\n\n    class Printer(val name: String) : Inf {\n        override fun print(string: String) {\n            println(\"$name:[$string]\")\n        }\n    }\n\n    companion object {\n        fun <I> function(arg: I, vararg func: (I) -> Unit) {\n            func.forEach { it(arg) }\n            println()\n        }\n\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val a = Printer(\"A\")\n            val b = Printer(\"B\")\n            val arrayFromClass = listOf(a, b).map { it::print }.toTypedArray()\n\n            val x = fun(string: String) { println(\"X:[$string]\") }\n            val y = fun(string: String) { println(\"Y:[$string]\") }\n            val arrayFromAnonymous = listOf(x, y).toTypedArray()\n\n            function(\"Single Class\", a::print)\n            function(\"Anyone From Class Array\", arrayFromClass[0])\n            function(\"Anyone From Class Array\", arrayFromClass[1])\n            function(\"Anonymous Lambda Array\", *arrayFromAnonymous)\n            function(\"Class Array\", *arrayFromClass)\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun main() {\n    val asc = Array(5, { i -> i * i })\n    for (s: Any in asc) {\n        println(s);\n    }\n}\n"
        },
        {
            "code": "\nval soundUri = \"android.resource://${context.packageName}/${R.raw.sound_love}\"\n"
        },
        {
            "code": "\nval soundUri = \"android.resource://${context.packageName}/\" + R.raw.sound_love\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val v = BooleanWrap(true)\n}\n\nclass BooleanWrap(private val value: Boolean): Comparable<Boolean> by value\n"
        },
        {
            "code": "\nimplementation(\"io.mockk:mockk:1.9\")\n"
        },
        {
            "code": "\npackage io.mockk.gh\n\nimport io.mockk.*\nimport kotlin.test.Test\n\nclass Issue223Test {\n    interface Foo<in T> {\n        fun bar(value: T)\n    }\n\n    @Test\n    fun test() {\n        val mock = createMock<Int>()\n        mock.tryBar(3)\n    }\n\n    inline fun <reified T : Any> createMock(): Foo<Any> {\n        val slot = slot<T>()\n\n        return mockk {\n            every {\n                bar(capture(slot))\n            } just Runs\n        }\n    }\n\n    fun <T> Foo<T>.tryBar(value: T) {\n        bar(value)\n    }\n}\n"
        },
        {
            "code": "\npackage myproj.common\n\nimport kotlinx.coroutines.*\n\nsuspend fun go(fn: suspend CoroutineScope.() -> Unit) { coroutineScope { launch { fn() } } }\n"
        },
        {
            "code": "\npackage myproj.jvm\n\nimport myproj.common.go\nimport kotlinx.coroutines.*\nimport org.junit.jupiter.api.Test\n\nclass SomeTest {\n    @Test\n    fun temp() {\n        runBlocking {\n            go { println(\"Test!!\") }\n            delay(1000)\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun foo(a: A) {\n    a[0] += 42\n}\n\nclass A {\n    operator fun get(vararg i: Int): Int = 42    // IndexOutOfBoundsException: Cannot pop operand off an empty stack\n    // operator fun get(i: Int): Int = 42    // OK\n\n    operator fun set(i: Int, value: Int) {}\n}\n"
        },
        {
            "code": "\nenum class Type {\n    A, B, C\n}\n\ninterface Wrapper {\n    val type: Type\n}\n\nval map = mapOf<String, Wrapper>()\nval wrapper = map[\"a\"]\nprintln(wrapper?.type == Type.A)\n"
        },
        {
            "code": "\nclass MyMap: java.util.Map<String, Any?> {\n    override fun clear() {\n        TODO(\"not implemented\")\n    }\n\n    override fun containsValue(value: Any?): Boolean {\n        TODO(\"not implemented\")\n    }\n\n    override fun putAll(m: MutableMap<out String, out Any?>?) {\n        TODO(\"not implemented\")\n    }\n\n    override fun values(): MutableCollection<Any?> {\n        TODO(\"not implemented\")\n    }\n\n    override fun size(): Int {\n        TODO(\"not implemented\")\n    }\n\n    override fun containsKey(key: Any?): Boolean {\n        TODO(\"not implemented\")\n    }\n\n    override fun get(key: Any?): Any? {\n        TODO(\"not implemented\")\n    }\n\n    override fun entrySet(): MutableSet<MutableMap.MutableEntry<String, Any?>> {\n        TODO(\"not implemented\")\n    }\n\n    override fun put(key: String?, value: Any?): Any? {\n        TODO(\"not implemented\")\n    }\n\n    override fun isEmpty(): Boolean {\n        TODO(\"not implemented\")\n    }\n\n    override fun remove(key: Any?): Any? {\n        TODO(\"not implemented\")\n    }\n\n    override fun keySet(): MutableSet<String> {\n        TODO(\"not implemented\")\n    }\n}\n"
        },
        {
            "code": "\nclass Presenter(private val view: View) {\n\tfun load() {\n\t\tSingle\n\t\t\t.fromCallable { \"Hello world\" }\n\t\t\t.subscribeUsual(\n\t\t\t\tonSuccess = { result -> view.display(result) },\n\t\t\t\tonError = { error -> error.printStackTrace() }\n\t\t\t)\n\t}\n}\n\ninline fun <T> Single<T>.subscribeUsual(\n\tonSuccess: (result: T) -> Unit,\n\tonError: (error: Throwable) -> Unit\n): Subscription =\n\tthis\n\t\t.subscribeOn(Schedulers.immediate())\n\t\t.observeOn(Schedulers.immediate())\n\t\t.subscribe(onSuccess.toAction(), onError.toAction())\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninline fun <T> ((input: T) -> Unit).toAction() = Action1<T> { this.invoke(it) }\n"
        },
        {
            "code": "\n        fun foo(): Any? {\n            val om = ObjectMapper()\n            return when {\n                true -> om.readValue(\"[]\", TypeFactory.defaultInstance().constructArrayType(Int::class.java))\n                else -> throw IllegalArgumentException()\n            }\n        }\n\n        foo()\n"
        },
        {
            "code": "\nfun main(args: Array<String>) = println(testy())\n\n// Typealias with generic parameter\ntypealias Testy<T> = Pair<T, T>\n\n// Inline function calling constructor of typealias\ninline fun testy(): Testy<String> = Testy(\"1\", \"2\")\n\n// This version compiles and executes fine\n// inline fun testy(): Testy<String> = Pair(\"1\", \"2\")\n"
        },
        {
            "code": "\n@file:JvmName(TAG)\n\npackage playground\n\nprivate const val TAG = \"MyBar\"\n"
        },
        {
            "code": "\n    suspend fun SF(c: Array<Continuation<Unit>?>)\n    {\n        suspendCoroutine {\n            cont: Continuation<Unit> ->\n            c[0] = cont\n        }\n    }\n\n    fun F()\n    {\n        val c: Array<Continuation<Unit>?> = Array(1, {_ -> null})\n        \n        suspend {\n            SF(c)\n            throw Throwable(\"From handler\")\n        }.createCoroutine(object: Continuation<Unit> {\n            override val context: CoroutineContext = EmptyCoroutineContext\n\n            override fun resume(value: Unit)\n            {\n                println(\"resumed\")\n            }\n\n            override fun resumeWithException(exception: Throwable)\n            {\n                println(\"resumeWithException $exception\")\n                throw Throwable(\"resumeWithException\", exception)\n            }\n        }).resume(Unit)\n\n        c[0]!!.resume(Unit)\n    }\n"
        },
        {
            "code": "\n    fun F()\n    {\n        val c: Array<Continuation<Unit>?> = Array(1, {_ -> null})\n\n        suspend {\n            suspendCoroutine {\n                cont: Continuation<Unit> ->\n                c[0] = cont\n            }\n            throw Throwable(\"From handler\")\n        }.createCoroutine(object: Continuation<Unit> {\n            override val context: CoroutineContext = EmptyCoroutineContext\n\n            override fun resume(value: Unit)\n            {\n                println(\"resumed\")\n            }\n\n            override fun resumeWithException(exception: Throwable)\n            {\n                println(\"resumeWithException $exception\")\n                throw Throwable(\"resumeWithException\", exception)\n            }\n        }).resume(Unit)\n\n        c[0]!!.resume(Unit)\n    }\n"
        },
        {
            "code": "\n    suspend fun SF()\n    {\n        suspendCoroutine {\n            cont: Continuation<Unit> ->\n            cont.resume(Unit)\n        }\n    }\n\n    fun F()\n    {\n        suspend {\n            SF()\n            throw Throwable(\"From handler\")\n        }.createCoroutine(object: Continuation<Unit> {\n            override val context: CoroutineContext = EmptyCoroutineContext\n\n            override fun resume(value: Unit)\n            {\n                println(\"resumed\")\n            }\n\n            override fun resumeWithException(exception: Throwable)\n            {\n                println(\"resumeWithException $exception\")\n                throw Throwable(\"resumeWithException\", exception)\n            }\n        }).resume(Unit)\n    }\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.experimental.launch\n\nclass Bar {\n    fun doWork() = launchWithDismiss {\n        process( // <---------------------------- line break is essential\n                param = 1)\n    }\n\n    suspend fun process(param: Any) {}\n\n    inline fun launchWithDismiss(crossinline block: suspend () -> Unit) = launch {\n        block()\n    }\n\n}\n"
        },
        {
            "code": "\nimport arrow.core.*\nimport arrow.data.*\nimport arrow.typeclasses.binding\n\ntypealias AnyStack = List<Pair<String, Any>>\n\nfun main(args : Array<String>) {\n\n    fun <T:Any> genList(name:String, list: List<T>) = StateT<ForListK, AnyStack, T>(ListK.monad()) { stack ->\n        ListK(list).map {\n            stack.plus(name to it) toT it\n        }\n    }\n\n    fun <T0:Any, T1:Any> genList(name0:String, name1:String, list: List<Tuple2<T0, T1>>) =\n            StateT<ForListK, AnyStack, Tuple2<T0, T1>>(ListK.monad()) { stack ->\n                ListK(list).map {\n                    stack.plus(name0 to it.a).plus(name1 to it.b) toT it\n                }\n            }\n\n    fun stackOperations() = StateT.monad<ForListK, AnyStack>(ListK.monad()).binding {\n        val (a:Int, d:String) = genList(\"a\", \"d\", listOf(Tuple2(0,\"h\"))).bind() // ClassCastException with this line\n//        val a_d:Tuple2<Int, String> = genList(\"a\", \"d\", listOf(Tuple2(0,\"h\"))).bind() // ClassCastException with this line\n//        genList(\"a\", \"d\", listOf(Tuple2(0,\"h\"))).bind() // no ClassCastException\n        val b = genList(\"b\", listOf(1,2,3)).bind()\n        genList(\"c\",(0 until b).toList()).bind()\n    }.fix()\n\n    // no ClassCastException\n    fun stackOperationsWithFlatMap() =\n         genList(\"a\", \"d\", listOf(Tuple2(0, \"h\"))).flatMap(ListK.monad()){\n            genList(\"b\", listOf(1, 2, 3)).flatMap(ListK.monad()){\n                genList(\"c\", (0 until it).toList())\n            }\n        }\n\n    println(stackOperations().runS(ListK.monad(), emptyList()).fix())\n}\n\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.experimental.channels.produce\nimport kotlinx.coroutines.experimental.runBlocking\nimport kotlinx.coroutines.experimental.selects.select\n\nfun main(args: Array<String>) {\n    runBlocking {\n        select<Int> {\n            produce {\n                send(1)\n            }?.onReceive { it }\n        }\n    }\n}\n"
        },
        {
            "code": "\npackage com.empowerops.language\n\nclass SequentialPoolBroker2 {\n\n    inline fun <T> doSubmit(crossinline task: () -> T): Unit {\n\n        val newJob = { task.invoke() }\n\n    }\n\n    fun another(command: Runnable): Unit = doSchedule { command.run() }\n\n    inline fun <V : Any?> doSchedule(crossinline callable: () -> V): Unit {\n\n        actualSchedule { doSubmit(callable) }\n\n    }\n\n    fun <T> actualSchedule(command: () -> T): Unit {}\n\n}\n"
        },
        {
            "code": "\nmetricsRef.log().get().addOnSuccessListener(requireActivity()) { metrics ->\n    async {\n        firestoreBatch {\n            for (metric in metrics) delete(metric.reference.log())\n        }.await()\n    }.logFailures()\n\n    longSnackbar(fam, R.string.deleted, R.string.undo) {\n        async {\n            firestoreBatch {\n                for (metric in metrics) set(metric.reference.log(), metric.data)\n            }.await()\n        }.logFailures()\n    }\n}\n"
        },
        {
            "code": "\nval ref = asLifecycleReference()\nasync(UI) {\n    val metrics = try {\n        metricsRef.log().get().await()\n    } catch (e: Exception) {\n        CrashLogger.onFailure(e)\n        return@async\n    }\n\n    async {\n        firestoreBatch {\n            for (metric in metrics) delete(metric.reference.log())\n        }.await()\n    }.logFailures()\n\n    longSnackbar(ref().fam, R.string.deleted, R.string.undo) {\n        async {\n            firestoreBatch {\n                for (metric in metrics) set(metric.reference.log(), metric.data)\n            }.await()\n        }.logFailures()\n    }\n}.logFailures()\n"
        },
        {
            "code": "\nabstract class NumberParent: Number(){\n    \n}\n\nclass MyNumber(val v: Double): NumberParent(){\n    override fun toByte(): Byte = v.toByte()\n\n    override fun toChar(): Char = v.toChar()\n\n    override fun toDouble(): Double = v\n\n    override fun toFloat(): Float = v.toFloat()\n\n    override fun toInt(): Int = v.toInt()\n\n    override fun toLong(): Long = v.toLong()\n\n    override fun toShort(): Short = v.toShort()\n}\n\n\nfun main(args: Array<String>) {\n    val myNumber = MyNumber(4.0)\n    println(myNumber)\n\tprintln(myNumber.toDouble())\n}\n"
        },
        {
            "code": "\nfun checkFloatArray(): Boolean {\n    val floatArray = floatArrayOf(1.1f, 2.2f, 3.3f)\n    var sum = 0f\n    for (i in 0..floatArray.size - 1) {\n        sum += floatArray[i]\n    }\n    if (sum != (1.1f + 2.2f + 3.3f)) return false\n    return true\n}\n"
        },
        {
            "code": "\n        registerActivityCallbacks(\n            onPaused = { },\n            onResumed = ::onActivityResumed\n        )\n"
        },
        {
            "code": "\nclass SomeClass {\n    fun someFunction() {\n        registerActivityCallbacks(\n            onResumed = ::onActivityResumed,\n            onPaused = { }\n        )\n    }\n\n    private fun onActivityResumed() {\n    }\n}\n\ninterface Callbacks {\n    fun onActivityResumed()\n    fun onActivityPaused()\n    fun onActivityDestroyed()\n}\n\ninline fun registerActivityCallbacks(\n    crossinline onResumed: () -> Unit,\n    crossinline onPaused: () -> Unit,\n    crossinline onDestroyed: () -> Unit = {}\n): Callbacks {\n    return object : Callbacks {\n        override fun onActivityResumed() = onResumed.invoke()\n        override fun onActivityPaused() = onPaused.invoke()\n        override fun onActivityDestroyed() = onDestroyed.invoke()\n    }\n}\n"
        },
        {
            "code": "\n  val mapa = HashMap<Int, Int>()\n  inline fun teste() = mapa[0] ?: 1\n  "
        },
        {
            "code": "\n  fun main(args: Array<String>)\n  {\n  \tteste()\n  }\n  "
        },
        {
            "code": "\nabstract class BaseClass<T : ViewModel> {\n    protected lateinit var model: T\n        private set\n\n    protected abstract fun onModelProvided()\n}\n"
        },
        {
            "code": "\nclass SubClass(private val lifecycleOwner: LifecycleOwner)\n    : BaseClass<CustodyTabViewModel>() {\n\n    override fun onModelProvided() {\n        model.updates.observe(lifecycleOwner, NonNullObserver {\n            model.subscribe()\n        })\n    }\n}\n"
        },
        {
            "code": "\nfun coroutineBuilder(block: suspend () -> Unit) = Unit\n\nsuspend fun suspending(block: () -> Unit) = Unit\n\nfun main(args: Array<String>) {\n    `test)`()\n}\n\nfun `test)`() {\n    val value = 1\n    coroutineBuilder {\n        suspending {\n            println(value)\n        }\n    }\n}\n"
        },
        {
            "code": " kotlin\ninline fun <reified T> x(): () -> Unit {\n    return  { println(T::class) }\n}\n\nfun main() {\n    x<ByteArray>()()\n    x<String>()()\n    println(ByteArray::class)\n}\n"
        },
        {
            "code": "\nclass ByteArray\nclass String\nclass ByteArray\n"
        },
        {
            "code": "\n@Target(FUNCTION)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class MyMethodKotlinAnnotation {\n}\n\nclass AnnotationsSuspendLambda {\n    val bar3: CoroutineScope.() -> Unit = @MyMethodKotlinAnnotation {\n        println(\"hello\")\n    }\n    val bar4: suspend CoroutineScope.() -> Unit = @MyMethodKotlinAnnotation {\n        println(\"hello\")\n    }\n}\n\nfun main() {\n  // works\n  val bar3 = AnnotationsSuspendLambda().bar3\n  val bar3Annotations = bar3.javaClass.getMethod(\"invoke\", CoroutineScope::class.java).annotations\n  bar3Annotations.find { a -> a.annotationClass == MyMethodKotlinAnnotation::class }\n\n  // fails\n  val bar4 = AnnotationsSuspendLambda().bar4\n  val bar4Annotations = bar4.javaClass.getMethod(\"invoke\", CoroutineScope::class.java).annotations\n  bar4Annotations.find { a -> a.annotationClass == MyMethodKotlinAnnotation::class }\n}\n"
        },
        {
            "code": "\npublic interface FlowCollector<in T> {\n    public suspend fun emit(value: T)\n}\n\npublic interface Flow<out T> {\n    public suspend fun collect(collector: FlowCollector<T>)\n}\n\ninternal inline fun <T> builder(@BuilderInference crossinline block: suspend FlowCollector<T>.() -> Unit): Flow<T> {\n    return object : Flow<T> {\n        override suspend fun collect(collector: FlowCollector<T>) {\n            collector.block()\n        }\n    }\n}\n\npublic fun <T> Flow<T>.foo(action: suspend () -> Unit): Flow<T> = builder {\n    try {\n    } catch (e: Throwable) {\n    } finally {\n        try {\n            action()\n        } catch (e: Throwable) {\n            throw e\n        }\n    }\n}\n"
        },
        {
            "code": "\n@Test\nfun testFoo() = runBlocking<Unit> {\n    launch2 {\n        delay(200)\n    }\n}\n\ninline fun CoroutineScope.launch2(crossinline block: suspend CoroutineScope.() -> Unit) {\n    launch {\n        // Pick *one* of these\n        block(this) // works well\n        block.invoke(this) // produces state machine that is resumed twice\n    }\n}\n"
        },
        {
            "code": "\nsuspend fun main() {\n    Test().execute(2, Test::test)\n}\n\nclass Test {\n    suspend fun test(a: Int): Int = a + 5\n}\n\nsuspend inline fun Test.execute(a: Int, crossinline f: suspend Test.(Int) -> Int): Flow<Int> = flow {\n    emit(f(a))\n}\n"
        },
        {
            "code": "\nimport java.util.*\n\ninterface I {\n    fun test() = object : ArrayList<String>() {}\n}\n\nclass C : I\n\nfun main(args: Array<String>) {\n    val testAnonimousClass = C().test().javaClass\n    println(testAnonimousClass.enclosingClass.canonicalName)//I.DefaultImpls => OK\n    println(testAnonimousClass.name) //I$test$1 =>KO! (should be I.DefaultImpls$test$1\n    //java.lang.Class#getSimpleBinaryName (used by #getSimpleName) does this :\n    //getName().substring(enclosingClass.getName().length()) and the result should start with $ to be valid\n    testAnonimousClass.simpleName //throw InternalError(\"Malformed class name\")\n}\n"
        },
        {
            "code": "\nfun main() {\n    for (x in UByte.MIN_VALUE..UByte.MAX_VALUE) {\n        println(x)\n    }\n}\n"
        },
        {
            "code": "\nfun main() {\n    var n = 0u\n    for (x in UByte.MIN_VALUE..UByte.MAX_VALUE) {\n        n = x\n    }\n    println(n)\n}\n"
        },
        {
            "code": "\n@ExperimentalStdlibApi\nfun test() {\n    val permissionService = serviceOf<PermissionService>()\n    val optionalPermissionService = serviceOf<PermissionService?>()\n}\n\n@ExperimentalStdlibApi\ninline fun <reified S> serviceOf(): S {\n    if (typeOf<S>().isMarkedNullable) {\n        // Inline this if it's nullable\n        return Sponge.getServiceManager().provide(S::class.java).orElse(null) as S\n    }\n    // Inline this if it's non-null\n    return Sponge.getServiceManager().provideUnchecked(S::class.java)\n}\n"
        },
        {
            "code": "\nsealed class Base\n\nclass Derived : Base()\n\nobject Instance : Base()\n\nfun foo(base: Base) {\n    when (base) {\n        is Derived -> println(\"Derived\")\n        Instance -> println(\"Instance\")\n    }\n}\n"
        },
        {
            "code": "\njs(\"for(var k of a.keys()) { console.log(k); }\")\n"
        },
        {
            "code": "\ninline fun a(f: () -> Any) =\n    try {\n        f()\n    } finally {\n        throw RuntimeException()\n    }\n\nfun b(vararg functions: () -> Any) = a {\n    for (function in functions) {\n        try {\n            return function()\n        } catch (fail: Throwable) {}\n    }\n}\n\nfun main(args: Array<String>) {\n    b({ println(1); 1 }, { println(2); 2 })\n}\n"
        },
        {
            "code": "\nclass A {\n    var field = 0\n\n    inline fun a(f: () -> Any): Any {\n        try {\n            val value = f()\n            return value\n        } finally {\n            field--\n        }\n    }\n\n    fun c(vararg functions: () -> Any): Any = a {\n        for (function in functions) {\n            try { return function() } catch (fail: Throwable) { }\n        }\n        throw RuntimeException()\n    }\n}\n"
        },
        {
            "code": "\n// Also reproes on interface\nabstract class Base<T> {\n    // Also reproes if abstract\n    open fun foo(a: T, b: Any? = null) {}\n}\n\n// Concrete type HAS to be primitive\nclass Derived : Base<Int>() {\n    override fun foo(a: Int, b: Any?) {}\n}\n\nfun main(args: Array<String>) {\n    // Must omit argument for parameter with default value\n    Derived().foo(42)\n}\n"
        },
        {
            "code": "\ninline class Z(val s: String) {\n    val Int.s: Int get() = 42\n}\n\nassert(Z(\"a\").toString() == \"Z(s=\\\"a\\\")\")\n"
        },
        {
            "code": "\ninline class Foo private constructor(val x: Int) // Error: Primary constructor of inline class must be public\n"
        },
        {
            "code": "\ninline fun foo(s1: String, vararg s: String) {\n Paths.get(s1, *s)\n Paths.get(s1, *s)\n}\nfun bar() {\n    foo(\"a\", \"b\", \"c\")\n}\n"
        },
        {
            "code": "\ninterface Headers {\n    var accept: String?\n    var `content-length`: String?\n}\n\nval headers: Headers = TODO(\"value provided by a JS library\")\nval accept = headers.accept\nval length = headers.`content-length`\n"
        },
        {
            "code": "\nopen class Foo(val x: Int)\nclass Bar(val y: Int)\n\nfun foo(bar: Bar): Foo {\n    return object: Foo(bar.y) {}\n}\n\nfun main() {\n    val x = foo(Bar(1))\n    println(x.javaClass.declaredFields.joinToString { it.name })\n}\n"
        },
        {
            "code": "\ninterface I1\ninterface I2\n\nfun <T> foo(x: Any) where T : I1, T : I2 {\n    x as T // Should be checked for I1 and I2, but there's only CHECKCAST I1\n}\n\nclass W : I1, I2\n\nfun main() {\n    foo<W>(object : I1 {}) // CCE should happen, but it doesn't\n}\n"
        },
        {
            "code": "\npackage test\n\nclass ML<T> {\n    val list = ArrayList<T>()\n\n    fun add(x: T) {\n        list.add(x)\n    }\n}\n\ninterface IFoo {\n    fun foo()\n}\n\ninterface IBar {\n    fun bar()\n}\n\nclass C<T> where T : IFoo, T : IBar {\n    fun foo(a: Any, b: Any) {\n        a as ML<IBar>\n        b as T\n        a.add(b)\n    }\n}\n\nclass FooImpl : IFoo {\n    override fun foo() {}\n}\n\nclass FooBar : IFoo, IBar {\n    override fun foo() {}\n    override fun bar() {}\n}\n\nfun main() {\n    val c = C<FooBar>()\n    val ml = ML<IBar>()\n    c.foo(ml, FooImpl())\n    println(ml.list)\n}\n"
        },
        {
            "code": "\ninline fun <reified T> foo() {\n    arrayOf<T>()\n}\n\nfun <U> bar() {\n    // warnings should be on both calls\n    arrayOf<U>() // Prohibited, should work as arrayOf<Any?>()\n    arrayOf<Array<U>>() // Allowed, but fails at runtime, should work as arrayOf<Array<Any?>>()\n}\n"
        },
        {
            "code": "\nclass case\nclass Case\n\nfun main(args: Array<String>) {\n\n    case()\n    Case()\n\n}\n"
        },
        {
            "code": "\n    inline private fun <reified T> writeArray(arrayBase: Int, arrayStride: Int, array: T, lengthGetter: (T) -> Int) {\n        val len = lengthGetter(array)\n        writeInt(len)\n\n        unsafe.copyMemory(array, arrayBase.toLong(), byteBufferMemoryBase, memory + offset, len * arrayStride.toLong())\n        offset += len * arrayStride.toLong()\n    }\n\n    override fun writeIntArray(array: IntArray) = writeArray(Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE, array, IntArray::size)\n"
        },
        {
            "code": ""
        },
        {
            "code": "\ninline class InlineString(val v: String)\nfun main() {\n    val x = InlineString(\"\")::javaClass\n    println(x.get()) //output: class java.lang.String\n}\n"
        },
        {
            "code": "\ninline class InlineInt(val v: Int)\nfun main() {\n    val x = InlineInt(0)::javaClass\n    println(x.get())\n}\n"
        },
        {
            "code": "\nsuspend fun foo() {}\n\nfun main() {\n    val fooRef: suspend () -> Unit = f@{ \n        return@f foo() \n    }\n}\n"
        },
        {
            "code": "\n// function compiled with -jvm-target: 1.8\ninline fun inlineFun(p: () -> Unit) {\n    p()\n}\n\n// function compiled with -jvm-target: 1.6\nfun test() {\n    inlineFun {} // EROR\n}\n"
        },
        {
            "code": "\n// Base class compiled with -jvm-target 1.8\nopen class Base {\n    inline fun inlineFunBase(p: () -> Unit) {\n        p()\n    }\n}\n\n// Derived class compiled with -jvm-target 1.6\nclass Derived : Base() {\n    fun test() {\n        inlineFunBase {} // no error, missed diagnostic\n    }\n}\n"
        },
        {
            "code": "\n// Derived class compiled with -jvm-target 1.6\nclass Derived : Base() {\n    fun test() {\n        inlineFunBase {} // Error\n    }\n}\n"
        },
        {
            "code": "\nsuspend fun dummy()\nsuspend fun foo() { \n  dummy()\n  dummy()\n}\n"
        },
        {
            "code": "\ninline fun inlineMe(crossinline c: suspend () -> Unit) = suspend { c() }\n\nsuspend fun main() {\n    val lambda = suspend {\n        suspendCoroutine<Unit> {\n            Thread {\n                Thread.sleep(100)\n                it.resume(Unit)\n            }.start()\n        }\n    }\n\n    inlineMe(lambda)()\n}\n"
        },
        {
            "code": "\nsuspend fun main() {\n    (FromJava().call() as suspend () -> Unit)()\n}\n"
        },
        {
            "code": "\ninline fun inlineMe(crossinline c: (Int) -> Unit) {\n  // a lot of code\n  return suspend { c() }\n}\n"
        },
        {
            "code": "\nfun foo(param: String = \"bar\") { }\n"
        },
        {
            "code": "\nannotation class MethodAnnotation\nannotation class ParameterAnnotation\n\n@MethodAnnotation\nfun foo(@ParameterAnnotation param: String = \"bar\") { }\n"
        },
        {
            "code": "\n// Module m1:\n\npublic inline fun <reified T> test() {}\n"
        },
        {
            "code": "\n// Module m2 (depends on m1):\n\nfun callTest() {\n    test<String>()\n}\n"
        },
        {
            "code": "\nclass C {\n    inline fun <reified T> test() {}\n}\n\nfun main() {\n    println(C::class.java.getMethod(\"test\"))\n}\n"
        },
        {
            "code": "\npublic class ClassWithField {\n    companion object {\n        private val field: Int = 2\n    }\n}\n"
        },
        {
            "code": " val field = \"Hello, World!\""
        },
        {
            "code": "\nprivate fun main(args: Array<String>) {\n}\n"
        },
        {
            "code": "\nprivate fun main() {\n}\n"
        },
        {
            "code": "\nprivate fun main() {\n}\n\npublic fun main(args: Array<String>) = main()  // generated method\n"
        },
        {
            "code": "\nsuspend fun foo() {}\n\nfun fooRef(): suspend () -> Unit = ::foo\n"
        },
        {
            "code": "\n        // surrogate chars\n        testEncoding(false, surrogateCharEncoding, \"\\uD800\")\n        testEncoding(false, surrogateCharEncoding, \"\\uDB6A\")\n        testEncoding(false, surrogateCharEncoding, \"\\uDFFF\")\n"
        },
        {
            "code": "\n    this.testEncoding_0(false, surrogateCharEncoding, '\\uD800');\n    this.testEncoding_0(false, surrogateCharEncoding, '\\uDB6A');\n    this.testEncoding_0(false, surrogateCharEncoding, '\\uDFFF');\n"
        },
        {
            "code": "\n    this.testEncoding_0(false, surrogateCharEncoding, '?');\n    this.testEncoding_0(false, surrogateCharEncoding, '?');\n    this.testEncoding_0(false, surrogateCharEncoding, '?');\n"
        },
        {
            "code": "\n@Serializable\nsealed class TimeInterval(open val start: Timestamp, open val end: Timestamp?) {\n    @Serializable\n    data class Finite(override val start: Timestamp, override val end: Timestamp) : TimeInterval(start, end)\n    @Serializable\n    data class Indefinite(override val start: Timestamp, override val end: Timestamp?) : TimeInterval(start, end)\n\n    companion object {\n        operator fun invoke(start: Timestamp, end: Timestamp): TimeInterval.Finite = TimeInterval.Finite(start, end)\n        operator fun invoke(start: Timestamp, end: Timestamp?): TimeInterval = if (end == null) TimeInterval.Indefinite(start, end) else TimeInterval.Finite(start, end)\n    }\n}\n"
        },
        {
            "code": "\n\n"
        },
        {
            "code": "\nvar counter = 0\nfun inc() = counter++\n\ntailrec fun test(x: Int = 0, y: Int = inc(), z: Int = inc()) {\n   if (x * 2 != y || z - y != 1)\n       throw IllegalArgumentException(\"x=$x y=$y z=$z\")\n\n   if (x < 100000)\n       test(x + 1) // default value for `y` initialized after default value for `z` so exception would be thrown on next call\n                           // Code without `tailrec` optimization works as expected\n}\n\nfun main() {\n   test()\n}\n"
        },
        {
            "code": "\nsuspend inline fun inlineMe(crossinline c: suspend () -> Unit) {\n    c()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(causesVerifyErrorSample())\n}\n\nfun causesVerifyErrorSample(): Sample<Boolean> = Sample\n    // Calling Type with generic T\n    .Success(true)\n    .flatMap { Sample.Failure(RuntimeException()) }\n\nsealed class Sample<out T> {\n    companion object {\n        fun <A> just(a: A): Sample<A> = Success(a)\n        fun <A> raise(e: Throwable): Sample<A> = Failure(e)\n    }\n\n    inline fun <R> flatMap(f: (T) -> Sample<R>): Sample<R> =\n        when (this) {\n            // First clause been Type with generic Nothing\n            is Failure -> this\n            is Success -> f(this.value)\n        }\n\n    data class Failure(val exception: Throwable): Sample<Nothing>()\n    data class Success<out T>(val value: T): Sample<T>()\n}\n"
        },
        {
            "code": "\nFailure(exception=java.lang.RuntimeException)\n"
        },
        {
            "code": "\ninline fun <R> flatMap(f: (T) -> Sample<R>): Sample<R> =\n        when (this) {\n            is Failure -> this as Sample<R>\n            is Success -> f(this.value)\n        }\n"
        },
        {
            "code": "\n@file:JsModule(\"somepackage\")\npackage somepackage\ntypealias SomeClass = Any\n\n// Error: Can't put non-external declarations in file marked with JsModule annotation\n"
        },
        {
            "code": "\nfun foo(x: (String) -> Unit) {}\n\nfun main(args: Array<String>) {\n    foo {\n        println(it)\n    }\n}\n"
        },
        {
            "code": "\nenum class A {\n  A, B\n}\nenum class B {\n  A, B\n}\nfun main(args: Array<String>) {\n  val a = A.A\n  when (a) {\n    A.A -> println(\"A.A\") // should hit this\n    A.B -> println(\"A.B\")\n    B.A -> println(\"B.A\") // but hitting this branch\n    B.B -> println(\"B.B\")\n  }\n}\n"
        },
        {
            "code": "\nenum class A {\n    A\n}\n\nenum class B {\n    B\n}\n\nfun f() = A.A\n\nfun main (args: Array<String>) {\n    when (f()) {\n        B.B -> println(\"Not ok\")\n        A.A -> println(\"Ok\")\n    }\n}\n"
        },
        {
            "code": "\ninline class A(val x : Int) {\n}\n\nfun <T: A> foo(a: T) {\n  println(a.x)\n}\n\nfun main(args: Array<String>) {\n  foo(A(32))\n}\n"
        },
        {
            "code": "\npackage com.test\n\nclass Example {\n\n    fun pathParam(key: String): String = \"param=$key\"\n    inline fun <reified T : Any> pathParam(key: String) = Holder(T::class.java.getDeclaredConstructor().newInstance())\n\n    data class Holder<T>(val value: T)\n}\n"
        },
        {
            "code": "\nclass Foo(private val bar: String) {\n    private inline fun baz() = bar\n}\n"
        },
        {
            "code": "\n@JsName(\"jsNamedValCustom\") val jsNamedVal = 0\nval originalNamedVal = 0\n\nfun printConst() {\n    println(js(\"typeof jsNamedValCustom\"))\n    println(js(\"typeof originalNamedVal\"))\n}\n"
        },
        {
            "code": "\nundefined\nundefined\n"
        },
        {
            "code": "\nundefined\nnumber\n"
        },
        {
            "code": "\nval a = {try {val b = 1} catch (e: Exception) {1}}\nprintln(a())\n"
        },
        {
            "code": "\nclass X {\n    private var foo = 0\n    \n    private fun y() {\n        x()\n    }\n    \n    private inline fun x() {\n        foo //     INVOKESTATIC kotlinx/io/X.access$getFoo$p (Lkotlinx/io/X;)I\n    }\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.runBlocking\n\nfun main() {\n    foo { number ->\n        val a = 5 // number variable is absent here\n    }\n\n    foo { number ->\n        val a = number // and even if it's explicitly used\n    }\n}\n\nfun foo(block: suspend kotlinx.coroutines.CoroutineScope.(Int) -> Unit) {\n    runBlocking {\n        block(5)\n    }\n}\n"
        },
        {
            "code": "\n    val a = try {\n        throw(IllegalStateException())\n    } catch (e : Throwable) {\n\n    }\n    println(a)\n"
        },
        {
            "code": "\ntest {}\n\ninline class MyInlineClass(val string: String)\n\nfun test(block: (MyInlineClass?) -> Unit) {\n    // This line crashes with a ClassCastException:  java.lang.String cannot be cast to MyInlineClass\n    block(\"Hello\"?.let { MyInlineClass(it) })\n}\n"
        },
        {
            "code": "\ninterface A {\n    fun a(): Int\n}\n\ninterface B : A\ninterface C : A {\n    @JvmDefault\n    override fun a() = 0\n}\n\ninterface D : B, C\n"
        },
        {
            "code": "\nabstract class A01 : List<String>\nabstract class A02 : A01()\nabstract class A03 : A02()\nabstract class A04 : A03()\nabstract class A05 : A04()\nabstract class A06 : A05()\nabstract class A07 : A06()\nabstract class A08 : A07()\nabstract class A09 : A08()\nabstract class A10 : A09()\nabstract class A11 : A10()\nabstract class A12 : A11()\nabstract class A13 : A12()\nabstract class A14 : A13()\nabstract class A15 : A14()\n"
        },
        {
            "code": "\n//Main.kt\ninterface I {\n    val a: Int\n}\n\nclass A : J\n\nfun main() {\n    A().a\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.runBlocking\n\nsuspend fun Int.doIt() = delay(1)\n\nclass Foo {\n\n    suspend fun delete() = callAndParse(Int::doIt)\n\n    private suspend inline fun callAndParse(\n        method: suspend Int.() -> Unit\n    ) = method(0)\n}\n\nfun main(args: Array<String>) {\n    runBlocking {\n        val foo = Foo()\n        runBlocking {\n            foo.delete()\n        }\n    }\n}\n"
        },
        {
            "code": "\n//     compile \"io.ktor:ktor-client-apache:1.1.1\"\n\nimport io.ktor.client.HttpClient\nimport io.ktor.client.engine.apache.Apache\nimport io.ktor.client.request.HttpRequestBuilder\nimport io.ktor.client.request.delete\nimport kotlinx.coroutines.runBlocking\n\nclass Foo {\n\n    private val client = HttpClient(Apache) {}\n\n    suspend fun delete() = call(HttpClient::delete)\n\n    private suspend inline fun call(\n        method: suspend HttpClient.(String, HttpRequestBuilder.() -> Unit) -> String\n    ) = client.method(\"\") {}\n}\n\nfun main(args: Array<String>) {\n    runBlocking {\n        val foo = Foo()\n        runBlocking {\n            foo.delete()\n        }\n    }\n}\n"
        },
        {
            "code": " kotlin\nopen class A(x : () -> Unit)\nclass B(x : Int) : A({ class C(val y : Int = x) })\n"
        },
        {
            "code": "\n\ninline fun foo(noinline block: suspend () -> Unit) = suspend { block() }\n\n// Changing this to noinline makes things work as expected.\ninline fun bar(crossinline block: suspend () -> Unit) = foo { block() }\n\ninline fun baz() = bar {\n  try {\n    // This _should_ suspend forever, but it resumes immediately.\n    suspendCancellableCoroutine<Unit> {}\n  } catch (e: Throwable) {\n    // This gets run.\n    println(\"this should never execute\")\n  }\n  // This actually gets run twice.\n  println(\"nor should this\")\n}\n\nfun main() {\n  val waiter = baz()\n\n  runBlocking {\n    // This should suspend forever, but doesn't.\n    waiter()\n  }\n}\n"
        },
        {
            "code": "\nnor should this\nthis should never execute\nnor should this\n"
        },
        {
            "code": "\npackage defect\n\nimport org.assertj.core.api.Assertions   // assertj-core v. 3.11.1\nimport org.junit.jupiter.api.DynamicTest // junit v. 5.3.2\nimport org.junit.jupiter.api.TestFactory // junit v. 5.3.2\n\nclass MyTest {\n\n    // compiles with Kotlin 1.3.11\n    // compiles with Kotlin 1.3.20\n    @TestFactory\n    fun `Test (42,mm,jjjj_cur +- X(d,m,j`(): Collection<DynamicTest> {\n        return listOf(\"1\", \"2\").map {\n            DynamicTest.dynamicTest(\"Test $it\") {\n                Assertions.assertThatExceptionOfType(Exception::class.java).isThrownBy {\n                    createTestee().run()\n                }\n            }\n        }\n    }\n\n    // compiles with Kotlin 1.3.11\n    // does not compile with Kotlin 1.3.20\n    @TestFactory\n    fun `Test (42,mm,jjjj_cur +- X(d,m,j))`(): Collection<DynamicTest> {\n        return listOf(\"1\", \"2\").map {\n            DynamicTest.dynamicTest(\"Test $it\") {\n                Assertions.assertThatExceptionOfType(RuntimeException::class.java).isThrownBy {\n                    createTestee().run()\n                }\n            }\n        }\n    }\n\n    private fun createTestee(): Runnable {\n        return Runnable { throw RuntimeException(\"Boom!\") }\n    }\n\n}\n"
        },
        {
            "code": "\nfun foo(value: String) {\n    class A(val fail: String = value)\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.experimental.async\nimport kotlinx.coroutines.experimental.runBlocking\nimport org.junit.Test\nimport kotlin.coroutines.experimental.Continuation\nimport kotlin.coroutines.experimental.suspendCoroutine\n\nclass InlineSuspendFail {\n\n    @Test\n    fun showFail() {\n\n        val decoratedWork = decorate {\n            work {\n                Thread {\n                    Thread.sleep(100)\n                    it.resume(42)\n                }.start()\n            }\n        }\n\n        val deferred = async { decoratedWork() }\n        runBlocking { deferred.await() }\n\n    }\n\n    fun decorate(actualWork: suspend () -> Int): suspend () -> Int {\n        return {\n            actualWork\n                .let { workDecorator(it) }\n                .invoke()\n        }\n    }\n\n    suspend inline fun work(crossinline triggerResume: (Continuation<Int>) -> Unit): Int {\n        System.out.println(\"Starting suspend\")\n        return suspendCoroutine { continuation ->\n            System.out.println(\"Triggering resume\")\n            triggerResume(continuation)\n            System.out.println(\"Resume triggered\")\n        }\n    }\n\n    suspend inline fun workDecorator(crossinline work: suspend () -> Int): suspend () -> Int =\n        suspend {\n            System.out.println(\"About to call work\")\n            work()\n        }\n}\n"
        },
        {
            "code": "\nval a = 1u\n\nwhen(a) {\n    0u -> println(\"another\")\n    1u -> println(\"success\")\n    else -> fail()\n}\n"
        },
        {
            "code": "\nclass foo(var bar : String)\n\nfun main() {    \n    var baz : foo? = foo(\"test\")\n    baz?.bar += \"test\"\n}\n"
        },
        {
            "code": "\nclass Key<T>(val value: T)\n\nclass Project {\n    fun <T> get(k: Key<T>): T = k.value\n}\n\nfun test() {\n    val id = Key<Long>(1L)\n    Project().get(id).equals(1)\n}\n"
        },
        {
            "code": "\nexpect class C {\n   fun foo(x: Any? = this)\n}\n\nactual class C {\n    actual fun foo(x: Any?) {}\n}\n"
        },
        {
            "code": "\npackage test\n\nclass L\n\noperator fun L?.invoke() {\n    println(this)\n}\n\nclass X\n\nval X?.x: L?\n    get() {\n        println(\"get\")\n        return if (this == null) null else L()\n    }\n\nfun test1(nx: X?) = nx?.x()\n\nfun main() {\n    test1(X())\n}\n"
        },
        {
            "code": "\nfun <T> f() = typeOf<List<T>>() // error: unsupported ['typeOf' with non-reified type parameters is not supported]\n"
        },
        {
            "code": "\ninline fun <reified X> g() = typeOf<X>()\n\nfun <Y> h() = g<List<Y>>() // OK, returns type for List<Any?> irrelevant of Y\n"
        },
        {
            "code": "\ninline class Foo(val value: Int)\n\ninterface Parent<T> {\n    val member: T\n}\n\nclass Sub(override val member: Foo) : Parent<Foo>\n\nfun main() {\n    val b = Sub(Foo(1))\n    println(b.member)\n}\n"
        },
        {
            "code": "\nsuspend fun coroutineContext(): CoroutineContext = \n    suspendCoroutineOrReturn { cont -> cont.context }\n"
        },
        {
            "code": "\nclass Test {\n    lateinit var classWithFunction: ClassWithFunction\n\n    val standardLambda1: () -> Unit = { doSth1() }\n    val referencedLambda1: () -> Unit = ::doSth1\n\n    val standardLambda2: () -> Unit = { classWithFunction.doSth2() }\n    val referencedLambda2_1: () -> Unit = classWithFunction::doSth2 // an error occurred because holds reference to the classWithFunction\n    val referencedLambda2_2: () -> Unit = ::classWithFunction.get()::doSth2 // even this throws an error\n    \n    fun doSth1() {}\n\n    class ClassWithFunction {\n        fun doSth2() {}\n    }\n}\n"
        },
        {
            "code": "\nvalue and (31.inv())\n"
        },
        {
            "code": "\n    BIPUSH -32\n    IAND\n"
        },
        {
            "code": "\n// Lambda returns parsed record and how many bytes were read from RawByteBuf\ninline fun  ByteBufferWrapper.highPerformantParseR(parser: (RawByteBuf) -> Pair<R, Int>): R  {\n  val raw = getRawBuffer()\n  val (result: R, read: Int) = parser(raw)\n  updateReadBytes(read)\n  return result\n}\n"
        },
        {
            "code": "\npublic inline fun foo(f: () -> Pair<Int, Int>): Int {\n    val (i: Int, r: Int) = f.invoke()\n    return r\n}\n\nval int = foo { 42 to 239 }\n"
        },
        {
            "code": "\nclass Test {\n    companion object {\n\n        private lateinit var INSTANCE: String\n\n        fun foo() {\n            INSTANCE\n        }\n    }\n}\n"
        },
        {
            "code": "\nclass Test {\n    companion object {\n\n        lateinit var INSTANCE: String\n\n        fun foo() {\n            INSTANCE\n        }\n    }\n}\n"
        },
        {
            "code": "\nclass Test {\n    companion object {\n\n        private lateinit var INSTANCE: String\n\n        fun foo() = INSTANCE\n    }\n}\n"
        },
        {
            "code": "\nsealed class State {\n    object System : State()\n    object Permission : State()\n    object Error : State()\n    companion object {\n        val stateOrder = listOfNotNull(\n            State.Permission,\n            State.System,\n            State.Error\n        )\n        val unit = println(\"Values $stateOrder\")\n    }\n}\nfun main() {\n    State.Permission\n}\n"
        },
        {
            "code": "\nimport java.io.Writer\n\nclass WriterWrapper(private val writer: Writer) {\n    fun write(s: String) {\n        writer.write(s)\n    }\n}\n"
        },
        {
            "code": "\n    val crash = arrayListOf<Int>()\n    crash[0].equals(crash) // any value, null, 4, \"\", crash, false, true, and so on\n    val crash = arrayListOf<Boolean>()\n    crash[0].equals(crash) // any value, null, 4, \"\", crash, false, true, and so on\n"
        },
        {
            "code": "\n@file:JvmMultifileClass\n@file:JvmName(\"Test\")\npackage test\n\nexpect class Foo {\n    val value: String\n}\n\nactual class Foo(actual val value: String)\n"
        },
        {
            "code": "\n// declaration in JVM\nactual fun convertDurationUnit(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double\n// invocation in common\nconvertDurationUnit(value.toDouble(), unit, storageUnit)\n"
        },
        {
            "code": "\nimport kotlin.coroutines.*\n\ninterface Flow<T> {\n    suspend fun consumeEach(consumer: FlowConsumer<T>)\n}\n\ninterface FlowConsumer<T> {\n    suspend fun consume(value: T)\n}\n\n// This functions cross-inlines action into an implementation of FlowConsumer interface\nsuspend inline fun <T> Flow<T>.consumeEach(crossinline action: suspend (T) -> Unit) =\n    consumeEach(object : FlowConsumer<T> {\n        override suspend fun consume(value: T) = action(value)\n    })\n"
        },
        {
            "code": "\ninline fun <T> Flow<T>.onEach(crossinline action: suspend (T) -> Unit): Flow<T> = object : Flow<T> {\n    override suspend fun consumeEach(consumer: FlowConsumer<T>) {\n        this@onEach.consumeEach { value ->\n            action(value)\n            consumer.consume(value)\n        }\n    }\n}\n"
        },
        {
            "code": "\ninline fun <T> Flow<T>.onEach(crossinline action: suspend (T) -> Unit): Flow<T> = object : Flow<T> {\n    override suspend fun consumeEach(consumer: FlowConsumer<T>) {\n        this@onEach.consumeEach(object : FlowConsumer<T> {\n            override suspend fun consume(value: T) {\n                action(value)\n                consumer.consume(value)\n            }\n        })\n    }\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.experimental.async\nimport kotlinx.coroutines.experimental.runBlocking\nimport org.junit.Test\nimport kotlin.coroutines.experimental.Continuation\nimport kotlin.coroutines.experimental.suspendCoroutine\n\nclass InlineSuspendFail {\n\n    @Test\n    fun showFail() {\n\n        val decoratedWork = decorate {\n            work {\n                Thread {\n                    Thread.sleep(100)\n                    it.resume(42)\n                }.start()\n            }\n        }\n\n        val deferred = async { decoratedWork() }\n        runBlocking { deferred.await() }\n    }\n\n    fun decorate(actualWork: suspend () -> Int): suspend () -> Int {\n        return {\n            actualWork\n                    .let { workDecorator(it) }\n                    .invoke()\n        }\n    }\n\n    suspend inline fun work(crossinline triggerResume: (Continuation<Int>) -> Unit): Int {\n        return suspendCoroutine { continuation ->\n            triggerResume(continuation)\n        }\n    }\n\n    suspend inline fun workDecorator(crossinline work: suspend () -> Int): suspend () -> Int = suspend {\n        // coroutine appears to resume here, rather than inside the `suspendCoroutine` block\n        // this causes an infinite loop, since calling work() below starts another coroutine\n        work()\n    }\n}\n"
        },
        {
            "code": "\nexternal enum class E { A, B }\n\nfun foo() {\n    E.values()\n    E.valueOf(\"A\")\n    enumValues<E>()\n    enumValueOf<E>(\"A\")\n}\n"
        },
        {
            "code": "\n@file:JvmMultifileClass\n@file:JvmName(\"Test\")\n\npackage com.example\n\nsealed class Foo\nobject Bar : Foo()\n\nfun main(args: Array<String>) {\n    println(Bar)\n}\n"
        },
        {
            "code": "\npublic fun String.toCharArray(): CharArray = CharArray(length) { this[it] }\n"
        },
        {
            "code": "\nfun test(x: Any, y: Double): Boolean {\n    if (x !is Double) return false\n    val tmp: Double = x\n    return tmp == y\n}\n"
        },
        {
            "code": "\nfun example1(x: Comparable<Double>, y: Double) =\n        x is Double && x < y\n"
        },
        {
            "code": "\nfun example1a(x: Comparable<Double>, y: Double): Boolean {\n    if (x !is Double) return false\n    val tmp: Double = x\n    return tmp < y\n}\n"
        },
        {
            "code": "\nfun example2(x: Any, y: Any) =\n        x is Int && y is Double && x < y // total order comparison\n\nfun example2a(x: Int, y: Double) =\n        x < y // widening conversion for 'x' + IEEE 754 comparison\n"
        },
        {
            "code": "\nfun example3(x: Any) =\n    when (x) {\n        !is Double -> \"!Double\"\n        0.0 -> \"0.0\" // (*)\n        else -> \"other\"\n    }\n\nfun example3a(x: Any) =\n    if (x !is Double) \"!Double\"\n    else if (x == 0.0) \"0.0\"\n    else \"other\"\n\n// example3(-0.0) == \"other\"\n// example3a(-0.0) == \"0.0\"\n"
        },
        {
            "code": "\nsuspend inline fun inlineMe(crossinline c: suspend () -> Unit) = suspend {\n    suspendCoroutineUninterceptedOrReturn<Unit> { println(it.toString()); Unit }\n    c()\n}\n\nsuspend fun main() {\n    inlineMe {}()\n}\n"
        },
        {
            "code": "\n// FILE: a.kt\n\npublic inline fun assertFailsWith() {\n    launchIn2 {\n        catch2<Any>(10) {\n        }\n    }\n}\n\nfun foo() {\n    assertFailsWith()\n}\n\npublic fun launchIn2(builder: () -> Unit) {  }\n\npublic inline fun <reified T> catch2(t: T, action: (T) -> Unit) {\n    T::class\n}\n\n\n// FILE: box.kt\n\nfun box() : String {\n    assertFailsWith()\n    return \"OK\"\n}\n"
        },
        {
            "code": "\nfun foo(): dynamic \nfun bar() {\n    foo() += 1 // translated as invalid JS code: foo() += 1\n}\n"
        },
        {
            "code": "\n    @JvmOverloads\n    private fun writeObject(outputStream: ObjectOutputStream, param: Boolean = true)\n"
        },
        {
            "code": "\ninline class Test(val x: Int){\n\tprivate companion object{\n\t\tprivate const val CONSTANT = 0\n\t}\n\t\n\tfun crash(){\n\t\tgetInlineConstant()\n\t}\n\t\n\tprivate inline fun getInlineConstant(): Int{\n\t\treturn CONSTANT\n\t}\n}\n"
        },
        {
            "code": "\ninline fun foo(x: () -> Unit) {\n    x.let {}\n}\n\nfun main() {\n    foo {\n        return@foo\n    }\n}\n"
        },
        {
            "code": "\npublic long put(final long key, final long value)\n"
        },
        {
            "code": "\nmap.put(5, 10)\n"
        },
        {
            "code": "\nmap.put(5L, 10L);\n"
        },
        {
            "code": "\nmap[5] = 10\n"
        },
        {
            "code": "\ninline class Direction(private val direction: Int) {\n    fun dx() = dx[direction]\n    fun dy() = dy[direction]\n\n    companion object {\n        private val dx = intArrayOf(0, 1, 0, -1)\n        private val dy = intArrayOf(-1, 0, 1, 0)\n    }\n}\n\nfun main(args: Array<String>) {\n    Direction(42).dx()\n}\n"
        },
        {
            "code": "\nenum class SimpleEnum {\n    A(1),\n    B(2),\n    C;\n\n    val myValue:Int\n\n    constructor(value:Int) {\n        myValue = value\n    }\n\n    constructor():this(0)\n\n}\n\n\nfun main() {\n    for(e in SimpleEnum.values()) {\n        println(\"Enum constant ${e.name}\") // \"Enum constant undefined\"\n    }\n}\n"
        },
        {
            "code": "\nenum class Test(vararg xs: Int) {\n    OK {\n        fun foo() {}\n    };\n    val xs = xs\n}\n\nfun box(): String =\n        if (Test.OK.xs.size == 0) \"OK\" else \"Fail\"\n"
        },
        {
            "code": "\ninline fun inlineMe(crossinline y: () -> Unit) =\n        object {\n            inline fun run() { y() }\n        }.run()\n\nfun main() {\n    inlineMe { println(1) }\n}\n"
        },
        {
            "code": "\ndata class A(val x: String, val y: String)\n\nsuspend fun foo(a: A, block: suspend (Int, A, String) -> String): String = block(1, a, \"#\")\n\nsuspend fun test() = foo(A(\"O\", \"K\")) { i_param, (x_param, y_param), v_param ->\n    i_param.toString() + x_param + y_param + v_param\n}\n"
        },
        {
            "code": "\ninterface Flow<T>\n\ninline fun <reified T> foo() =\n    object {\n        fun test() = object : Flow<T> {}\n    }.test() // NoSuchMethodError\n\nfun main() {\n    foo()\n}\n"
        },
        {
            "code": "\nenum class A {\n  A, B\n}\n\nenum class B {\n  A, B\n}\n\nfun main(args: Array<String>) {\n  val a = A.A\n\n  when (a) {\n    A.A -> println(\"A.A\") // should hit this\n    A.B -> println(\"A.B\")\n    B.A -> println(\"B.A\") // but hitting this branch\n    B.B -> println(\"B.B\")\n  }\n}\n"
        },
        {
            "code": "\nclass Test {\n    fun f(t: Thread.State) {}\n}\n"
        },
        {
            "code": "\nenum class Numbers {\n    ONE,\n    TWO,\n    THREE\n}\n\nfun testNumbersWhen(n: Numbers): Int {\n    return when(n) {\n        Numbers.ONE -> 1\n        Numbers.TWO -> 2\n        Numbers.THREE -> 3\n    }\n}\n"
        },
        {
            "code": "\nval unsigned = 0x8fffffffU\nval good = \"123 \" + unsigned\nval bad = \"123 \" + 0x8fffffffU\n\nfun main() {\n    println(good) //123 2415919103\n    println(bad) //123 -1879048193\n}\n"
        },
        {
            "code": "\nclass AlsoReceiver  {\n\n    object Completion : Continuation<AlsoReceiver> {\n        override val context = EmptyCoroutineContext\n        override fun resumeWith(result: Result<AlsoReceiver>) {\n            println(\"Completed with $result\")\n        }\n    }\n\n    fun foo2() {\n        (::doWork).startCoroutineUnintercepted(Completion)\n    }\n\n    private suspend fun doWork() = also {\n        suspendCoroutine<Unit> {\n            thread {\n                Thread.sleep(1000)\n                it.resumeWith(Result.success(Unit))\n            }\n        }\n    }\n\n\n    @Test\n    fun foo() {\n        foo2()\n        Thread.sleep(2000)\n    }\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.experimental.runBlocking\n\nsuspend fun suspending(c: suspend () -> String) {}\n\nfun main(args: Array<String>) {\n    val foo: suspend () -> String = fun () = \"foo\"\n    runBlocking {\n        suspending(foo)\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.contracts.ExperimentalContracts\nimport kotlin.contracts.InvocationKind\nimport kotlin.contracts.contract\n\n@ExperimentalContracts\nfun example(block: () -> Unit) {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    block()\n}\n\n// ERROR: Kotlin: [Internal Error] java.lang.IllegalStateException (see stacktrace.txt)\n@ExperimentalContracts\nclass Example(bool: Boolean) {\n    init {\n        example {\n            if (bool) {\n\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\n// No error\nclass Example(bool: Boolean) {\n    init {\n        run {\n            if (bool) {\n\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun main() {\n    SomeClass().ping(\"whatever\")\n}\n"
        },
        {
            "code": "\nclass SomeClass : ParentClass<String> {\n    override fun ping(message: String) {\n        println(message)\n    }\n}\n"
        },
        {
            "code": "\ninterface ParentClass<S> {\n    fun ping(message: S)\n}\n"
        },
        {
            "code": "\ninline class SomeIC(val x: Int)\n\nfun main() {\n    SomeJavaClass().test(SomeIC(10))\n}\n"
        },
        {
            "code": "\ninterface MyInterface<T> {\n    val value: T\n}\n\ninline class MyInlineClass(val value: Int)\n\ndata class MyInlineClassInterface(override val value: MyInlineClass) : MyInterface<MyInlineClass>\n"
        },
        {
            "code": "\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\nplugins {\n    kotlin(\"jvm\") version \"1.3.21\"\n}\n\nval junitJupiterVersion by extra { \"5.4.0\" }\nval striktVersion by extra { \"0.19.1\" }\n\ndependencies {\n\n    implementation(kotlin(\"stdlib\"))\n\n    testImplementation(kotlin(\"reflect\"))\n\n    testImplementation(\"io.strikt:strikt-core:$striktVersion\")\n\n    testImplementation(\"com.nhaarman.mockitokotlin2:mockito-kotlin:2.1.0\")\n    testImplementation(\"org.mockito:mockito-core:2.25.0\")\n\n    testImplementation(\"org.junit.jupiter:junit-jupiter-api:$junitJupiterVersion\")\n    testImplementation(\"org.junit.jupiter:junit-jupiter-params:$junitJupiterVersion\")\n\n    testRuntimeOnly(\"org.junit.jupiter:junit-jupiter-engine:$junitJupiterVersion\")\n}\ntasks {\n    withType<KotlinCompile>().configureEach {\n        kotlinOptions {\n            jvmTarget = \"1.8\"\n        }\n    }\n}\n"
        },
        {
            "code": "\nimport org.junit.jupiter.api.DynamicTest.dynamicTest\nimport org.junit.jupiter.api.Test\nimport strikt.api.expectThrows\n\nprivate inline class MyInlineClass(val value: Long)\n\ninternal class InlineClassError {\n\n    @Test\n    internal fun `COMPILE FAILURE - test method with parenthesis (parenthesis)`() {\n        val frameId = MyInlineClass(0)\n        dynamicTest(\"with a single nano\") {\n            expectThrows<IllegalArgumentException> {\n                frameId\n            }\n        }\n    }\n\n    @Test\n    internal fun `COMPILE SUCCESS - test method without parenthesis`() {\n        val frameId = MyInlineClass(0)\n        dynamicTest(\"with a single nano\") {\n            expectThrows<IllegalArgumentException> {\n                frameId\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun <T, U> Result<T>.flatMap(function: (T) -> Result<U>): Result<U> {\n    return if (isSuccess) {\n        function(getOrNull()!!)\n    } else {\n        Result.failure(this.exceptionOrNull()!!)\n    }\n}\n"
        },
        {
            "code": "\nfun <T> Result<T>.forEach(consumer: (T) -> Unit) {\n    if (this.isSuccess) {\n        consumer(getOrNull()!!)\n    }\n}\n"
        },
        {
            "code": "\nopen class Foo(val args: String){\n    constructor(arg: Any = 1) : this(arg.toString()) {\n    }\n}\n\nopen class Base(val baseArgs: String)\nopen class Bar(arg: Any = 1) : Base(arg.toString()) {\n    val args = arg.toString()\n}\n\nobject TF : Foo() {}\nobject TF2 : Foo(2) {}\n\nfun main() {\n    val f = object : Foo() {}\n    val f2 = object : Foo(2) {}\n    val b = object : Bar() {}\n    println(\"f.args: \" + f.args)\n    println(\"f2.args: \" + f2.args)\n    println(\"TF.args: \" + TF.args)\n    println(\"TF2.args: \" + TF2.args)\n    println(\"b.args: \" + b.args)\n    println(\"b.baseArgs: \" + b.baseArgs)\n}\n"
        },
        {
            "code": "\nasync {\n    inner@ async {\n        run {\n            return@inner\n        }\n    }\n}\n"
        },
        {
            "code": "\ninline class Foo(val x: UIntArray)\n\nfun main() {\n    Foo(UIntArray(5))\n}\n"
        },
        {
            "code": "\nopen class Test<T> {\n    open fun testFun(a: T, b: Boolean = false) { }\n}\n\nclass SubTest : Test<Boolean>() {\n    override fun testFun(a: Boolean, b: Boolean) { super.testFun(a, b) }\n}\n\nfun main() {\n    SubTest().testFun(true) // -> Code Generation Error\n    SubTest().testFun(true, false) // -> Works\n}\n"
        },
        {
            "code": "\npackage flow\n\ninterface FlowCollector<T> {\n    suspend fun emit(value: T)\n}\n\ninterface Flow<T : Any> {\n    suspend fun collect(collector: FlowCollector<T>)\n}\n\npublic inline fun <T : Any> flow(crossinline block: suspend FlowCollector<T>.() -> Unit) = object : Flow<T> {\n    override suspend fun collect(collector: FlowCollector<T>) = collector.block()\n}\n\nsuspend inline fun <T : Any> Flow<T>.collect(crossinline action: suspend (T) -> Unit): Unit =\n    collect(object : FlowCollector<T> {\n        override suspend fun emit(value: T) = action(value)\n    })\n\ninline fun <T : Any, R : Any> Flow<T>.flowWith(crossinline builder: Flow<T>.() -> Flow<R>): Flow<T> =\n    flow {\n        builder(this@flowWith)\n    }\n\nsuspend fun main() {\n    val f = flow<Int> {\n        emit(1)\n    }.flowWith {\n        this\n    }.collect {\n    }\n}\n"
        },
        {
            "code": "\ninline class InlineClass(val string: String)\nclass Foo<T>(inlineString: InlineClass, generic: T)\n"
        },
        {
            "code": "\nsealed class Animal {\n    object Dog : Animal()\n    object Cat : Animal()\n\n    companion object {\n        val all =  setOf(Dog, Cat) \n    }\n}\n\nsealed class Fruit {\n    object Apple : Fruit()\n    object Mango : Fruit()\n\n    companion object {\n        val all get() = setOf(Apple, Mango) \n    }\n}\n\nfun main() {\n    println(Animal.Dog)\n    println(Animal.all)\n\n    println(Fruit.Apple)\n    println(Fruit.all)\n}\n"
        },
        {
            "code": "\n   fun main(args: Array<String>) {\n       var ary = Array(5, {x -> x + 2})\n       println(ary[2])\n   }\n   "
        },
        {
            "code": "\nfun main() {\n    // create constructor\n    val Profile: JsClass<Vue> = Vue.extend(object {\n        val template = \"<p>{{firstName}} {{lastName}} aka {{alias}}</p>\"\n        val data = {\n            object {\n                val firstName = \"Walter\"\n                val lastName = \"White\"\n                val alias = \"Heisenberg\"\n            }\n        }\n    })\n    // create an instance of Profile and mount it on an element\n    // *** QUESTION: how to instantiate an object out of `Profile`? ***\n    val profile: Vue = Profile.new() // does not work\n    profile.`$mount`(\"#mount-point\")\n}\n\n@JsModule(\"vue\")\n@JsNonModule\nexternal class Vue(config: dynamic = definedExternally) {\n    companion object {\n        /**\n         * [https://vuejs.org/v2/api/#Vue-extend]\n         */\n        fun extend(options: dynamic): JsClass<Vue>\n    }\n\n    fun `$mount`(mountPoint: String)\n}\n"
        },
        {
            "code": "\n// WITH_RUNTIME\n// WITH_COROUTINES\nimport helpers.*\n\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.*\n\nsuspend fun suspendThere(v: A): A = suspendCoroutineOrReturn { x ->\n    x.resume(v)\n    COROUTINE_SUSPENDED\n}\n\nclass A(var value: Int)\n\nsuspend operator fun A?.plus(a: A) = suspendThere(A(this?.value ?: 0 + a.value))\n\nclass B(var a: A)\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nfun box(): String {\n    var b: B? = B(A(11))\n    builder { b?.a += A(31) }\n    if (b?.a?.value != 42) return \"FAIL 0\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    navigate(Routes::index)\n}\n\nobject Routes {\n    suspend fun index() {}\n}\n\nfun navigate(route: suspend () -> Unit) {}\n"
        },
        {
            "code": "\ninline class Demo(val a: Int)\n\nfun main() {\n\tval a = Demo(10)\n    println(a.a)\n}\n"
        },
        {
            "code": "\n    @Test\n    fun `testingMethod() Exception code generation `() = runBlocking {\n        withTimeout(1300) {// the same behavior with launch and async\n            println(testingMethod())\n        }\n    }\n"
        },
        {
            "code": "\nprivate external interface I\nprivate external class C : I\n\nprivate fun f(instance: C) {\n    val ref = instance as I  // Unchecked cast to external interface: C to I\n}\n"
        },
        {
            "code": "\n// WITH_RUNTIME\nclass A(var value: Int)\n\noperator fun A?.plus(a: A) = A(this?.value ?: 0 + a.value)\n\nclass B(var a: A)\n\nfun box(): String {\n    var b: B? = B(A(11))\n    b?.a += A(31)\n    if (b?.a?.value != 42) return \"FAIL 0\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "\npackage test\n\nclass R(var x: String)\n\nfun test(r: R?) {\n    r?.x += \"123\"\n}\n"
        },
        {
            "code": "\ntypealias StringSupplier = () -> String\n\ntypealias WhateverStringFunction = (Any?) -> String\n\nfun main(args: Array<String>) {\n    whatIs(object : StringSupplier, WhateverStringFunction {\n        override fun invoke() = TODO()\n        override fun invoke(a: Any?): String = TODO()\n        override fun toString(): String = \"object : StringSupplier, WhateverStringFunction\"\n    })\n\n    whatIs(object : WhateverStringFunction, StringSupplier {\n        override fun invoke() = TODO()\n        override fun invoke(a: Any?): String = TODO()\n        override fun toString(): String = \"object : WhateverStringFunction, StringSupplier\"\n    })\n}\n\nfun whatIs(f: Any) {\n    try {\n        f as StringSupplier\n        println(\"$f is a StringSupplier\")\n    } catch (t: Throwable) {\n        println(\"$f is not a StringSupplier\")\n    }\n    try {\n        f as WhateverStringFunction\n        println(\"$f is a WhateverStringFunction\")\n    } catch (t: Throwable) {\n        println(\"$f is not a WhateverStringFunction\")\n    }\n}\n"
        },
        {
            "code": "\ninline class IC(val x: Int)\n\nfun f(z: IC) {\n    IC::class // KClass<out IC> \n    IC::class.simpleName // \"IC\"\n}\n"
        },
        {
            "code": "\ndata class A(val arr: ByteArray, val arr2: IntArray = intArrayOf(1,2), val arr3: BooleanArray = booleanArrayOf(true, false)\n             , var arr4: CharArray = charArrayOf('a', 'b', 'c')\n             , val arr5: FloatArray = floatArrayOf(Float.NaN, 0.0f, -0.25f ))\n\nval a = A(byteArrayOf(1, 2, 3))\nprintln(a)\n"
        },
        {
            "code": "\npackage org.example\n\nfun main(args: Array<String>) {\n    val obj = MyJavaClass()\n    obj.set(\"foo\", \"bar\")\n    val test = when { // inferred to `Nothing?`\n        true -> obj.get(\"foo\")\n        else -> null\n    }\n    print(test) // \"Always null\"\n}\n"
        },
        {
            "code": "\nprivate interface Bag<T> {\n\toperator fun contains(element: T): Boolean\n}\n\nprivate interface IntBag : Bag<Int> {\n\toverride fun contains(element: Int): Boolean\n}\n\nprivate fun testIntBag(intBag: IntBag) = 1 in intBag\n"
        },
        {
            "code": "\nabstract class Foo {\n    internal abstract fun foo()\n}\n\nabstract class Bar : Foo() {\n    public abstract override fun foo() // <- escalate visibility\n}\n"
        },
        {
            "code": "\npackage test\n\nfun <T : Int> bar(x: T) {}\n"
        },
        {
            "code": "\npublic static final <T> void test.FooKt.fooInt(T)\nfooInt was invoked\n"
        },
        {
            "code": "\nclass AuthenticationModule(\n\tprivate val jwtConfiguration: JWTConfiguration\n) : BakuModule<Context, Transaction>() {\n\n\t// â¦\n\n\tprivate suspend fun ApplicationCall.handleAuthenticationCreationRequest() {\n\t\tresponse.cacheControl(CacheControl.NoStore(visibility = null))\n\t\tresponse.header(HttpHeaders.Pragma, \"no-cache\")\n\n\t\trespond(transaction.authenticationService.execute(receiveJSON<APIRequest<AuthenticationCreationRequest>>().payload))\n\t}\n}\n"
        },
        {
            "code": "\ninterface AuthenticationService {\n\n\tsuspend fun execute(request: AuthenticationCreationRequest): AuthenticationCreationResult\n\t// â¦\n}\n"
        },
        {
            "code": "\nsuspend inline fun <reified Type : Any> ApplicationCall.receiveJSON(): Type {\n\tval type = object : JSONCodingTypeReference<Type>() {}::class\n\tval incomingContent = request.receiveChannel()\n\tval receiveRequest = ApplicationReceiveRequest(type, incomingContent)\n\tval transformed = request.pipeline.execute(this, receiveRequest).value\n\n\t@Suppress(\"UNCHECKED_CAST\")\n\treturn transformed as Type\n}\n"
        },
        {
            "code": "\nclass AuthenticationModule(\n\tprivate val jwtConfiguration: JWTConfiguration\n) : BakuModule<Context, Transaction>() {\n\n\t// â¦\n\n\tprivate suspend fun ApplicationCall.handleAuthenticationCreationRequest() {\n\t\tresponse.cacheControl(CacheControl.NoStore(visibility = null))\n\t\tresponse.header(HttpHeaders.Pragma, \"no-cache\")\n\n\t\trespond(test())\n\t}\n\n\tprivate suspend fun ApplicationCall.test() =\n\t\ttransaction.authenticationService.execute(receiveJSON<APIRequest<AuthenticationCreationRequest>>().payload)\n}\n"
        },
        {
            "code": "\n            cacheEmpty {\n                lastFetched(lastTimeFetched)\n            }\n"
        },
        {
            "code": "\n    @Test\n    fun `initState(), set last fetched - expect set state`() {\n        val maxAgeOfCache = Age(1, Age.Unit.HOURS)\n        `when`(repository.maxAgeOfCache).thenReturn(maxAgeOfCache)\n\n        val lastTimeFetched = Calendar.getInstance().apply {\n            add(Calendar.DATE, -100)\n        }.time\n\n        onlineRepositoryTesting.initState(repository, requirements) {\n            cacheEmpty {\n                lastFetched(lastTimeFetched)\n            }\n        }\n\n        val setLastFetchedCaptor = argumentCaptor<Date>()\n        verify(cacheAgeManager).updateLastSuccessfulFetch(eq(requirements.tag), setLastFetchedCaptor.capture())\n        assertThat(setLastFetchedCaptor.firstValue).isEqualTo(lastTimeFetched)\n\n        verify(repository, never()).saveCacheSyncCurrentThread(ArgumentMatchers.anyString(), eq(requirements))\n    }\n"
        },
        {
            "code": "\nfun test(a: Int, b: Int, flag: Boolean) =\n    (if (flag) a..b else a downTo b).map { it + 1 }\n"
        },
        {
            "code": "\npackage sample\n\nfun main(args: Array<String>) {\n    val temp = SomeClass(5.toUInt())\n    println(temp.v)\n}\n\ninterface SomeIface<T> {\n    val v: T\n}\n\nclass SomeClass(override val v: UInt) : SomeIface<UInt>\n"
        },
        {
            "code": "\npackage test\n\nfun main() {\n    ZipZap()[{ 42 }]++\n}\n"
        },
        {
            "code": "\npackage test\n\nclass A\n\nvar stored: Any? = null\n\noperator fun A.get(vararg xs: Int): Int {\n    stored = xs\n    return 0\n}\n\noperator fun A.set(vararg xs: Int, v: Int) {\n    if (stored === xs) \n        println(\"Same\") \n    else \n        println(\"$stored !== $xs\")\n}\n\nfun main(args: Array<String>) {\n    A()[1, 2]++\n}\n"
        },
        {
            "code": "\nclass Ex1 {\n    operator fun get(i: Int) = 0\n    operator fun set(i: Int, v: Int) {}\n}\n"
        },
        {
            "code": "\nval tmp_a = Ex1()\nval tmp_i1 = foo()\ntmp_a.set(\n    tmp_i1,\n    tmp_a.get(tmp_i1).plus(bar())\n)\n"
        },
        {
            "code": "\nclass Ex2 {\n    operator fun get(vararg i: Int) = 0\n    operator fun set(i: Int, j: Int, v: Int) {}\n}\n"
        },
        {
            "code": "\nval tmp_a = Ex2()\nval tmp_i1 = foo1()\nval tmp_i2 = foo2()\ntmp_a.set(\n    tmp_i1,\n    tmp_i2,\n    tmp_a.get(intVararg(tmp_i1, tmp_i2)).plus(bar())\n)\n"
        },
        {
            "code": "\nclass Ex3 {\n    operator fun get(vararg i: Int) = 0\n    operator fun set(vararg i: Int, v: Int) {}\n}\n"
        },
        {
            "code": "\nval tmp_a = Ex3()\nval tmp_i1 = foo1()\nval tmp_i2 = foo2()\ntmp_a.set(\n    intVararg(tmp_i1, tmp_i2),\n    tmp_a.get(intVararg(tmp_i1, tmp_i2)).plus(bar())\n)\n"
        },
        {
            "code": "\nclass Ex4 {\n    operator fun get(vararg i: Any) = 0\n    operator fun set(vararg i: Int, v: Int) {}\n}\n"
        },
        {
            "code": "\nval tmp_a = Ex4()\nval tmp_i1 = foo1()\nval tmp_i2 = foo2()\ntmp_a.set(\n    objectVararg<Any>(tmp_i1 as Any, tmp_i2 as Any),\n    tmp_a.get(intVararg(tmp_i1, tmp_i2)).plus(bar())\n)\n"
        },
        {
            "code": "\noperator fun Int.get(i1: Int, vararg ii: Int) = 0\n\noperator fun Any.set(a1: Any, a2: Any, a3: Any = \"\", v: Int) {}\n"
        },
        {
            "code": "\nval tmp_a = int()\nval tmp_i1 = foo1()\nval tmp_i2 = foo2()\n(tmp_a as Any).set(\n    a1 = tmp_i1 as Any,\n    a2 = tmp_i2 as Any,\n    v = tmp_a.get(\n        i1 = tmp_i1,\n        ii = intVararg(tmp_i2)\n    ).plus(bar())\n)\n"
        },
        {
            "code": "\npackage test\n\nimport test.Host.get\nimport test.Host.set\n\nclass A\n\nobject Host {\n    operator fun A.get(i: Int) = 1\n\n    operator fun A.set(i: Int, v: Int) {\n        println(\"A.set($i, $v)\")\n    }\n}\n\nfun main(args: Array<String>) {\n    A()[1]++\n}\n"
        },
        {
            "code": "\npackage test\n\noperator fun <T> Array<out T>.set(i: Int, value: T) {\n    println(\"Array<out T>.set: i=$i, value=$value\")\n}\n\nfun test(a: Array<out String>) {\n    a[0] = \"abc\" // (*)\n}\n\nfun main(args: Array<String>) {\n    test(arrayOf(\"0\", \"1\", \"2\"))\n}\n"
        },
        {
            "code": "\npackage test\n\nclass A\n\noperator fun A.get(i: Any) = i as Int\n\noperator fun A.set(i: Int, v: Int) {\n    println(\"i=$i, v=$v\")\n}\n\nfun main(args: Array<String>) {\n    A()[10] += 1\n}\n"
        },
        {
            "code": "\npackage ch.tutteli.atrium.assertions\n\nimport ch.tutteli.atrium.assertions.A.getFoo\n\nabstract class B(f: () -> String): Spek({})\n\nobject A : B(::getFoo){\n    private fun getFoo() = \"foo\"\n}\n"
        },
        {
            "code": "\nclass C: B(Companion::getFoo){\n    companion object{\n        private fun getFoo() = \"foo\"\n    }\n}\n"
        },
        {
            "code": "\nsuspend fun foo() {}\n\nsuspend fun bar(): Int {\n    foo()\n    return 42\n}\n"
        },
        {
            "code": "\nsuspend fun foo(s: String) {\n    val a = 5\n    coroutineContext\n}\n"
        },
        {
            "code": "\nimport junit.framework.Assert\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.CoroutineContext\n\nprivate suspend fun <X> background(context: CoroutineContext = Dispatchers.Default, block: suspend () -> X): Deferred<X> {\n    return coroutineScope {\n        async(context) {\n            block.invoke()\n        }\n    }\n}\nprivate suspend fun <T> T.toDeferred(): Deferred<T> {\n    return background { this }\n}\n\nsuspend inline fun <T1, T2, R> zip(source1: Deferred<T1>, source2: Deferred<T2>, coroutineStart: CoroutineStart = CoroutineStart.DEFAULT, crossinline zipper: (T1, T2) -> R): Deferred<R> =\n    coroutineScope {\n        async(start = coroutineStart) {\n            zipper(source1.await(), source2.await())\n        }\n    }\n\nsuspend fun main() {\n    val first = 1.toDeferred()\n    val second = 2.toDeferred()\n    val result = 3\n\n    Assert.assertEquals(\n        result,\n        zip(first, second) { firstValue: Int, secondValue: Int -> firstValue + secondValue }.await()\n    )\n}\n"
        },
        {
            "code": "\npackage sample\n\nfun test() {\n}\n\nfun main(args: Array<String>) {\n    println(::test)\n}\n"
        },
        {
            "code": "\npackage sample\n\ninline class Foo(val v: Int)\n\nfun main(args: Array<String>) {\n    var a = Foo(5)\n    val b = a::v\n    println(\"A: ${a.v} - ${b.get()}\")\n}\n"
        },
        {
            "code": "\nsuspend fun foo(a: Int) {}\nsuspend fun bar(b: Int) {}\n\nsuspend fun baz(a: Int, b: Int): Int {\n    foo(a)\n    bar(b)\n    return 42 // not a tail suspend call to bar\n}\n"
        },
        {
            "code": "\nreturn path.resolve(Paths.get(\"gradle\", \"wrapper\", \"gradle-wrapper.properties\"))\n    .let { p ->\n        if (Files.exists(p)) {\n            p.toFile().useLines { lines ->\n                lines\n                    .filter { it.contains(\"(?:distributionUrl).*(?:=)\".toRegex()) }\n                    .map { it.split(\"=\".toRegex(), 2)[1] }\n                    .map { it.replace(\"\\\\\\\\\".toRegex(), \"\") }\n                    .firstOrNull()\n                    ?.let(URI::create)\n            }\n        } else {\n            null\n        }\n    }\n"
        },
        {
            "code": "\nfun test(a: Any) = a.run { hashCode() }\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(\"abc\")\n}\n"
        },
        {
            "code": "\nclass Receiver(val value: Int)\n\nexpect fun Receiver.test(param: Int = value)\n"
        },
        {
            "code": "\nactual fun Receiver.test(param: Int) {\n}\n"
        },
        {
            "code": "\nopen class Range() {\n companion object {\n    @JvmField val EQUAL: Byte = 0\n    @JvmField val MODIFIED: Byte = 1\n    @JvmField val INSERTED: Byte = 2\n    @JvmField val DELETED: Byte = 3\n  }\n}\n"
        },
        {
            "code": "\nclass SColl(private val s: String) : Collection<String> {\n    override val size: Int\n        get() = 1\n\n    override fun contains(element: String): Boolean {\n        return element.length == s.length && element == s\n    }\n\n    override fun containsAll(elements: Collection<String>): Boolean {\n        return elements.all { it == s }\n    }\n\n    override fun isEmpty(): Boolean {\n        return false\n    }\n\n    override fun iterator(): Iterator<String> {\n        return listOf(s).iterator()\n    }\n}\n"
        },
        {
            "code": "\nval scoll = SColl(\"s\")\nprintln((scoll as Collection<Any?>).contains(null))\n"
        },
        {
            "code": "\nimport kotlin.coroutines.intrinsics.*\n\nfun check() = true\n\nsuspend fun f(i: Int): Unit {\n    return f_2()\n}\n\nprivate inline suspend fun f_2(): Unit {\n    if (check()) return\n\n    return suspendCoroutineUninterceptedOrReturn {\n        COROUTINE_SUSPENDED\n    }\n}\n"
        },
        {
            "code": "\nfun main() {\n    println(StrReader(\"a\").peek())\n}\n\ninline fun String.getOrElse(index: Int, default: () -> Char): Char = if (index >= 0 && index < this.length) this[index] else default()\n\nclass StrReader(val str: String, var pos: Int = 0) {\n        // NO BOXING\n\tfun peek2(): Char = if (pos >= 0 && pos < str.length) str[pos] else '\\u0000'\n\t\n\t// BOXING\n\tfun peek(): Char = str.getOrElse(pos) { '\\u0000' }\n}\n"
        },
        {
            "code": "\nfun test(d: dynamic) {\n    d?.m += 123\n}\n"
        },
        {
            "code": "\nval tmp = d\nif (tmp != null) {\n    tmp.m += 123\n}\n"
        },
        {
            "code": "\nval tmp = d\n(if (tmp != null) tmp else null).plusAssign(123)\n"
        },
        {
            "code": "\nval tmp1 = d\nval tmp2 = e\nif (tmp1 != null) {\n    tmp1 += tmp2\n}\n"
        },
        {
            "code": "\nfun test(x: dynamic) {\n    x?.m += \"abc\"\n}\n\nfun main() {\n    val t: dynamic = {}\n    t.m = \"123\"\n    test(t)\n    println(t.m)\n}\n"
        },
        {
            "code": "\n@file:Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\npackage test\n\nimport kotlin.internal.DynamicExtension\n\ninterface WithDynamicExtensionGet {\n    @DynamicExtension\n    operator fun dynamic.get(i: Any?) = this\n}\n\ninterface WithDynamicExtensionSet {\n    @DynamicExtension\n    operator fun dynamic.set(i: Any?, v: Any?) {}\n}\n\ninterface WithDynamicExtensionGetAndSet :\n        WithDynamicExtensionGet,\n        WithDynamicExtensionSet\n\nfun WithDynamicExtensionGet.test1(d: dynamic) {\n    d[1] += \"def\"\n}\n\nfun WithDynamicExtensionGetAndSet.test2(d: dynamic) {\n    d[2] += \"def\"\n}\n"
        },
        {
            "code": "\nfun test(x: dynamic) {\n    x?.m += \"abc\"\n}\n\nfun main() {\n    val t: dynamic = {}\n    t.m = \"123\"\n    test(t)\n    println(t.m)\n}\n"
        },
        {
            "code": "\nfun testAndAnd(d1: dynamic, d2: dynamic): Boolean = d1 && d2\n"
        },
        {
            "code": "\nObservable.fromCallable { }\n    .map<State> { state.copy(loaderState = LoaderState.Loaded) }\n    .startWith(state.copy(loaderState = LoaderState.Loading))\n"
        },
        {
            "code": "\n   @Column(name = \"monitor_props\") @Convert(converter = PgJsonToStringConverter::class) @HollowInline\n   var json: String = \"\"\n      @JsonRawValue\n      get() = field\n      @JsonDeserialize(using = KeepAsJsonDeserialzier::class)\n      set(value) {\n         field = value\n\n         val matchResult = Regex(\"\\\"triggers\\\":\\\\s*(\\\\[.*])\", RegexOption.DOT_MATCHES_ALL).find(value) ?: return\n         val triggersJson = matchResult.groupValues[1]\n         triggers = fromTypedJson<Array<AlertTrigger>>(triggersJson)!!.toSet()\n         triggers.forEach {\n            it.monitorId = monitorId\n            it.hashCode() /* force hashCode calculation/caching */\n         }\n      }\n"
        },
        {
            "code": "\n   @Column(name = \"monitor_props\") @Convert(converter = PgJsonToStringConverter::class) @HollowInline @get:JsonRawValue\n   var json: String = \"\"\n      @JsonDeserialize(using = KeepAsJsonDeserialzier::class)\n      set(value) {\n         field = value\n\n         val matchResult = Regex(\"\\\"triggers\\\":\\\\s*(\\\\[.*])\", RegexOption.DOT_MATCHES_ALL).find(value) ?: return\n         val triggersJson = matchResult.groupValues[1]\n         triggers = fromTypedJson<Array<AlertTrigger>>(triggersJson)!!.toSet()\n         triggers.forEach {\n            it.monitorId = monitorId\n            it.hashCode() /* force hashCode calculation/caching */\n         }\n      }\n"
        },
        {
            "code": "\nfun test1(a: IntArray) {\n    for ((i, x) in a.withIndex()) {\n        println(x)\n    }\n}\n\nfun test2(a: UIntArray) {\n    for ((i, x) in a.withIndex()) {\n        println(x)\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\nclass Delegate(val value: String) {\n    operator fun getValue(thisRef: Any?, kProperty: Any?) = value\n}\n\nfun box(): String {\n    val x by Delegate(\"O\")\n\n    class Local(val y: String) {\n        val fn = { x + y }\n    }\n\n    return Local(\"K\").fn()\n}\n\nfun main(args: Array<String>) {\n    println(box())\n}\n"
        },
        {
            "code": "\nprintln(AssertionError(\"failing on purpose\").asDynamic().stack)\n"
        },
        {
            "code": "\nimport kotlin.properties.Delegates.notNull\n\nobject BugsBunny_Fails {\n    @JvmStatic fun main(args: Array<String>) {\n        var bunny by notNull<String>()\n\n        val obj = object {\n            val getBunny = {bunny}\n        }\n\n        bunny = \"Hi there\"\n        println(obj.getBunny())\n    }\n}\n\nobject BugsBunny_Works {\n    var bunny by notNull<String>()\n\n    @JvmStatic fun main(args: Array<String>) {\n        val obj = object {\n            val getBunny = {bunny}\n        }\n\n        bunny = \"Hi there\"\n        println(obj.getBunny())\n    }\n}\n"
        },
        {
            "code": "\nobject Foo2 {\n    operator fun Any?.get(key: String) = 42 as Any\n}\n\nobject Main {\n    val Int.id: Int? get() = 42\n\n    fun bar() = with(Foo2) {\n\n        val x = object {\n            val y = 38[\"Hello!\"]\n            val z = 45.id\n        }\n        println(x)\n    }\n}\n\nfun main(args: Array<String>) {\n    Main.bar()\n}\n"
        },
        {
            "code": "\nconst val s1 = \"1234567890\"\nconst val s2 = s1 + s1 + s1 + s1 + s1 + s1 + s1 + s1 + s1 + s1;\nconst val s3 = s2 + s2 + s2 + s2 + s2 + s2 + s2 + s2 + s2 + s2;\nconst val s4 = s3 + s3 + s3 + s3 + s3 + s3 + s3 + s3 + s3 + s3;\nconst val s5 = s4 + s4 + s4 + s4 + s4 + s4 + s4 + s4 + s4 + s4;\n\nfun main(args: Array<String>) {\n    println(s5.length)\n}\n"
        },
        {
            "code": "\nconst val s1 = \"1234567890\"\nconst val s2 = s1 + s1 + s1 + s1 + s1 + s1 + s1 + s1 + s1 + s1;\nconst val s3 = s2 + s2 + s2 + s2 + s2 + s2 + s2 + s2 + s2 + s2;\nconst val s4 = s3 + s3 + s3 + s3 + s3 + s3 + s3 + s3 + s3 + s3;\n\nfun main(args: Array<String>) {\n    println(s4.length)\n}\n"
        },
        {
            "code": "\nobject Foo {\n    operator fun Int.get(key: String) = 42\n}\n\nfun bar() = with(Foo) {\n    val x = object {\n        val y = 38[\"Hello!\"]\n    }\n}\n\nfun main(args: Array<String>) {\n    bar()\n}\n"
        },
        {
            "code": "\nimport androidx.arch.core.executor.testing.InstantTaskExecutorRule\nimport androidx.lifecycle.MutableLiveData\nimport androidx.lifecycle.Observer\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.runBlocking\nimport org.junit.Rule\nimport org.junit.Test\nimport org.mockito.Mockito.*\n\nclass LazyLiveDataTest {\n\n    @get:Rule\n    val archRule = InstantTaskExecutorRule()\n\n    @Test\n    fun `get() loads only once`() {\n        runBlocking {\n            suspend fun load(l: MutableLiveData<Int>) {\n                delay(100)\n                l.postValue(1)\n            }\n            val lazyLiveData = LazyLiveData(::load)\n            val observer = mock(Observer::class.java)\n            @Suppress(\"UNCHECKED_CAST\")\n            lazyLiveData.get(this).observeForever(observer as Observer<in Int>)\n            lazyLiveData.get(this)\n            delay(150)\n            lazyLiveData.get(this)\n            verify(observer).onChanged(1)\n        }\n    }\n}\n"
        },
        {
            "code": "\nenum class Button(val caution: CautionLevel) {\n    POWER(CautionLevel.LOW),\n    RESET(CautionLevel.LOW),\n    VOLTAGE(CautionLevel.HIGH)\n}\n\nenum class CautionLevel(val buttons: List<Button>) {\n    HIGH(listOf(Button.VOLTAGE)),\n    LOW(listOf(Button.POWER, Button.RESET))\n}\n\nfun main(args: Array<String>) {\n   println(\"\\nButtons w/ their caution level:\")\n   Button.values().asSequence()\n     .forEach { \n       println(\"\\tButton: $it Caution: ${it.caution}\") \n     }\n   println(\"\\nCaution Levels w/ associated buttons:\")\n   CautionLevel.values().asSequence()\n     .forEach { \n       println(\"\\tCaution Level: $it Associated Buttons: ${it.buttons}\") \n     }\n}\n"
        },
        {
            "code": "\nfun main() {\n   `doAThing) outer inner`()\n   `doAThing) only`()\n}\n\nclass Thing {\n    private val myThing = 1\n\n    fun thing() = myThing\n}\n\ntypealias MyRunable = () -> Unit\n\nfun doAThing(name: String, myRunable: MyRunable) {\n    println(\"running $name\")\n    myRunable()\n}\n\nfun `doAThing) outer inner`() {\n    val thing = Thing()\n\n    doAThing(\"outer\") { doAThing(\"inner\") { thing.thing() } }\n}\n\nfun `doAThing) only`() {\n    val thing = Thing()\n\n    doAThing(\"only\") { thing.thing() }\n}\n"
        },
        {
            "code": "\nval String.wcstr: CValues<UShortVar>\n    get() {\n        val chars = CharArray(this.length, { i -> this.get(i)})\n        return object : CValues<UShortVar>() {\n            override val size get() = 2 * (chars.size + 1)\n\n            override fun getPointer(scope: AutofreeScope): CPointer<UShortVar> {\n                val result = scope.allocArray<UShortVar>(chars.size + 1)\n                nativeMemUtils.putCharArray(chars, result.pointed, chars.size)\n                result[chars.size] = 0u\n                return result\n            }\n        }\n    }\n"
        },
        {
            "code": "\ninterface A {\n    private fun foo() {\n      \tprintln(\"Hi!\")  \n    }\n    \n    public fun bar() {\n        foo()\n    }\n}\n\nclass B : A {\n    \n    private fun foo() {\n      \tprintln(\"Hiiiii!\")  \n    }\n    \n}\n\nfun main(args: Array<String>) {\n    val b = B()\n    \n    b.bar()\n}\n"
        },
        {
            "code": "\n// -- kotlinApp.kt\npackage com.demo\n\nclass TestClass() { \n\n  fun concatStrings(left: String, right: String): String {\n    return left + right\n  }\n}\n"
        },
        {
            "code": "\nclass MethodWithParens {\n    fun `(bla)`() {\n        something {\n            something {\n                something {}\n            }\n        }\n    }\n\n    private fun something(function: () -> Any) {\n        function()\n    }\n\n}\n\nfun main() {\n    MethodWithParens().`(bla)`()\n}\n"
        },
        {
            "code": "\ninterface A {\n    fun foo(): Int\n}\n\nfun brr() {\n    inline fun foo() {\n        val b = object : A {\n            override fun foo() = 10\n        }\n        \n        println(b.foo())\n    }\n    \n    foo()\n}\n\nfun main(args: Array<String>) {\n    brr()\n}\n"
        },
        {
            "code": "\ninterface AsyncCloseable {\n\tsuspend fun close()\n}\n\ninline suspend fun <T : AsyncCloseable, R> T.use(callback: T.() -> R): R { // FAILS\n//suspend fun <T : AsyncCloseable, R> T.use(callback: T.() -> R): R { // WORKS\n\ttry {\n\t\treturn callback()\n\t} finally {\n\t\tclose()\n\t}\n}\n\nclass Demo : AsyncCloseable {\n    override suspend fun close() {\n    }\n}\n\nsuspend fun main() {\n    println(Demo().use { 10 })\n}\n"
        },
        {
            "code": "\nclass Boo : Function0<String> {\n    override fun invoke() = \"Boo\"\n}\n\nfun test() {\n    val b = Boo()\n    assertEquals(\"Boo\", run(b))\n}\n"
        },
        {
            "code": "\n// WITH_RUNTIME\n\nfun testUInt(x: UInt) =\n    when (x) {\n        0u -> \"none\"\n        1u -> \"one\"\n        2u -> \"two\"\n        3u -> \"three\"\n        else -> \"many\"\n    }\n\nfun box(): String {\n    val t = testUInt(2u)\n    if (t != \"two\") throw AssertionError(\"$t\")\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "\n    var t = testUInt(new UInt(2)); // NB boxed\n    if (!equals(t, 'two'))\n      throw AssertionError_init(t);\n"
        },
        {
            "code": "\n    fun `we test function xx() which do something`() {\n        mockServer {\n            runBlocking {\n                val x = SOME_RESPONSE\n            }\n        }\n    }\n"
        },
        {
            "code": "\n    fun `test foo() bar`() {\n        assertThat(true).isTrue()\n    }\n"
        },
        {
            "code": "\nfun main() {\n}\n\nclass Test {\n\n    data class C(val a: String)\n\n    class A {\n        fun a(\n            f: (C) -> Int\n        ) {\n\n        }\n    }\n\n    class B {\n        fun b(c: C): Int {\n            return 10\n        }\n    }\n\n    fun f(f: () -> Unit) {\n\n    }\n\n    fun `Method with parentheses ()`() {\n\n        val b = B()\n\n        val a = A()\n\n        f { a.a({ b.b(it) }) }\n\n    }\n\n}\n"
        },
        {
            "code": "\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String(chars: CharArray): String {\n    return js(\"String.fromCharCode\").apply(null, chars)\n}\n"
        },
        {
            "code": "\npackage sample\n\nfun test() {\n}\n\nfun main(args: Array<String>) {\n    println(::test)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val p = 1\n\n    (1..2).forEach {\n        class A {\n            val z = p\n        }\n\n        A()\n    }\n}\n"
        },
        {
            "code": "\nclass CrashMe2 {\n    fun outString() = \"\"\n    fun crashMe() {\n        \"abc\".let {\n            class LocalLocal {\n                val v = outString()\n            }\n            LocalLocal()\n        }\n    }\n}\n"
        },
        {
            "code": "\nimport reactor.core.publisher.EmitterProcessor\nimport java.io.Closeable\n\nclass MyCloseable:Closeable\n{\n    override fun close() {\n    }\n}\n\nfun main()\n{\n    val ep=EmitterProcessor.create<String>()\n    MyCloseable().use{\n        class InnerThing{\n            fun doSomething()\n            {\n                ep.onComplete()\n            }\n        }\n        InnerThing()\n    }\n}\n"
        },
        {
            "code": "\nclass Foo {\n    @Test\n    fun ` d \"  `() {\n        class Foo {\n\n        }\n    }\n}\n"
        },
        {
            "code": "\ninterface A {\n    fun baz() {\n        println(A.hashCode())\n    }\n    private companion object\n}\n\nclass C : A\n\nfun main(args: Array<String>) {\n    C().baz()\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.experimental.launch\n\nfun main(args: Array<String>) {\n  abc {\n    launch { }\n        .join()\n  }\n}\n\ninline fun abc(crossinline task: suspend () -> Unit) {\n  launch {\n    task()\n  }\n}\n"
        },
        {
            "code": " kotlin\nclass A {\n    open inner class B {}\n}\n\nclass C : A.B {\n    constructor()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val value = Double.NaN\n    println(\"NaN == NaN: ${value == Double.NaN}\")\n    println(\"NaN.equals(NaN): ${value.equals(Double.NaN)}\")\n    println()\n    when (value) {\n        Double.NaN -> println(\"When NaN is NaN?\")\n        else -> println(\"When NaN not NaN?\")\n    }\n}\n"
        },
        {
            "code": "\nwhen (value) {\n        Double.NaN -> println(\"NaN\")\n        in 0..100 -> println(\"0..100\")\n        else -> println(\"-INF..0 || 100..+INF range\")\n    }\n"
        },
        {
            "code": "\npackage pw.ske.roguelite.enemy\n\nimport com.badlogic.ashley.core.Entity\nimport pw.ske.roguelite.EntityCreator\n\ndata enum class EnemyType(val create: () -> Entity) {\n    MONSTER({EntityCreator.createMonster()})\n}\n"
        },
        {
            "code": " kotlin\ninterface A<T : Any>  {\n    fun foo(x : T? = null)\n}\n\ninterface B {\n    fun foo(x : String? = null)\n}\n\ninterface C<T : Any> : A<T>, B\n\nobject D : C<String> {\n    override fun foo(x: String?) { }\n}\n\nfun main(args: Array<String>) {\n    D.foo()\n}\n"
        },
        {
            "code": "\nimport android.database.Cursor\n\npublic inline fun Cursor.getString(key: String, defaultValue: String = \"\"): String =\n        try {\n            getString(getColumnIndexOrThrow(key)) ?: defaultValue\n        } catch (e: Exception) {\n            defaultValue\n        }\n\npublic inline fun Cursor.getString(key: String, defaultValue: String? = null): String? =\n        try {\n            getString(getColumnIndexOrThrow(key))\n        } catch (e: Exception) {\n            defaultValue\n        }\n\n"
        },
        {
            "code": " kotlin\ninterface A {\n    fun notify()\n}\n\nclass C : A {\n    override fun notify() { }\n}\n\nfun main(args: Array<String>) {\n    C()\n}\n"
        },
        {
            "code": "\nclass Foo {\n    val handler = Handler()\n    private val bar = \"\"\n    \n    inline fun baz() {\n        handler.post {\n            bar\n        }\n    }\n}\n"
        },
        {
            "code": "\nclass B\n\nclass A {\n    operator fun get(x: Int, y: B = B()) = x to y\n}\n\nfun main(args: Array<String>) {\n    println(A()[0])\n}\n"
        },
        {
            "code": "\ninterface A {\n    fun foo(x: Int)\n}\nopen class C {\n    open fun foo(x: Int) {\n        println(\"C\")\n    }\n}\n\nclass B : C(),A {\n    @JvmOverloads\n    fun foo(x: Int, y: Int = 42) {\n        println(\"B\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val a : A = B()\n    (B() as A).foo(1)\n    (B() as C).foo(1)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(Foo().bar(\"hello \"))\n}\n\ninterface IFoo {\n    open fun bar(a: String, b: String = \"world\") = a + b\n}\n\nclass Foo : IFoo {\n    override fun bar(a: String, b: String) = super.bar(a)\n}\n"
        },
        {
            "code": " kotlin\nclass C{\n    fun foo(){\n        class A\n        A().hashCode()\n    }\n    fun foo(x : Int){\n        class A\n        A().hashCode()\n    }\n}\n"
        },
        {
            "code": "\nfun Array<Int>.test2(): Array<Int> {\n    class Z() {\n        fun run(): Array<Int> {\n            return this@test2\n        }\n    }\n    return Z().run()\n}\n\nfun Array<String>.test2(): Array<String> {\n    class Z() {\n        fun run(): Array<String> {\n            return this@test2\n        }\n    }\n    return Z().run()\n}\n\nfun box(): String {\n    val array = Array<String>(2, { i -> \"${i}\" })\n    if (array != array.test2()) return \"fail 2\"\n\n    val array2 = Array<Int>(2, { i -> i })\n    if (array2 != array2.test2()) return \"fail 4\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "\npackage foo\n\nfun main(args: Array<String>) {\n    val xs = listOf(1, 2, 3).flatMap { x ->\n        listOf(3, 4, 5).map { y ->\n            object {\n                val value = x + y\n            }\n        }\n    }\n\n    xs.forEach {\n        println(\"value: \" + it.value)\n    }\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.experimental.CoroutineScope\nimport kotlinx.coroutines.experimental.async\nimport kotlinx.coroutines.experimental.runBlocking\nimport kotlin.coroutines.experimental.EmptyCoroutineContext\nimport kotlin.coroutines.experimental.suspendCoroutine\nsuspend fun privateJob(): Unit = suspendCoroutine {\n    cont ->\n    println(\"DOOOOOOOMED\")\n    cont.resume(Unit)\n}\nsuspend fun protectedJob() {\n    println(\"searching for sub-worker company\")\n    privateJob()\n}\nfun insideJob() = doTheJob {\n    protectedJob()\n}\nfun doTheJob(block: suspend CoroutineScope.() -> Unit) = {\n    val job = async(EmptyCoroutineContext, start = false) {\n        insideJob()\n    }\n    job.invokeOnCompletion {\n        println(\"job end\");\n    }\n    job.start()\n}\nfun main(args: Array<String>) {\n//    runBlocking {\n    insideJob()\n//        println(\"we did it!\")\n//    }\n}\n"
        },
        {
            "code": "\nfun isZero(n: UInt?): Boolean = n == 0u\n"
        },
        {
            "code": "\n@ExperimentalUnsignedTypes\nfun main(args: Array<String>) {\n    // Only happens for nullable types, same happens for other unsigned types\n    val nullableShort: UShort? = 1.toUShort()\n    if(nullableShort == UShort.MAX_VALUE) println(\"This won't compile\")\n}\n"
        },
        {
            "code": "\nclass ListenerList<T> private constructor(\n        private val innerReference: AtomicReference<Collection<T>>) :\n        Collection<T> by innerReference.get(),\n        MutableCollection<T>{\n\n    constructor() : this(AtomicReference(listOf())) {\n    }\n}\n"
        },
        {
            "code": "\ninterface Digraph<T> { val node: Int }\ninterface AcyclicDigraph<T> : Digraph<T> { }\nfun <T> Digraph<T>.assertAcyclic(): AcyclicDigraph<T> = AcyclicDigraphImpl(this)\nclass AcyclicDigraphImpl<T>(val graph: Digraph<T>) : AcyclicDigraph<T>, Digraph<T> by graph {\n\tinit {\n\t\t// @TODO: check this is acyclic!\n\t}\n}\n"
        },
        {
            "code": "\ninterface Foo {\n    fun name(): String\n}\n\ninterface Bar: Foo {\n    override fun name() = name\n    var name: String\n}\n\nenum class Baz : Bar {\n    ONE, TWO, TREE;\n}\n"
        },
        {
            "code": "\nopen class A : List<String> {\n    override val size: Int\n        get() = throw UnsupportedOperationException()\n\n    override fun contains(element: String): Boolean {\n        throw UnsupportedOperationException(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun containsAll(elements: Collection<String>): Boolean {\n        throw UnsupportedOperationException(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun get(index: Int): String {\n        throw UnsupportedOperationException(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun indexOf(element: String): Int {\n        throw UnsupportedOperationException(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun isEmpty(): Boolean {\n        throw UnsupportedOperationException(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun iterator(): Iterator<String> {\n        throw UnsupportedOperationException(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun lastIndexOf(element: String): Int {\n        throw UnsupportedOperationException(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun listIterator(): ListIterator<String> {\n        throw UnsupportedOperationException(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun listIterator(index: Int): ListIterator<String> {\n        throw UnsupportedOperationException(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<String> {\n        throw UnsupportedOperationException(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n    }\n\n\n    fun add(x: String) {}\n    fun add(x: String) {}\n}\n"
        },
        {
            "code": "\nopen class MapModel2 : HashMap<String, String> () {\n    companion object{}\n}\nclass abc : MapModel2() {\n}\nfun main(arg: Array<String>) {\n    var a = abc();\n    a[\"aName\"] = \"OK\";\n    println(a[\"Name\"]);\n}\n\n"
        },
        {
            "code": "\nclass A {\n    private val x = object {}\n}\n"
        },
        {
            "code": "\nopen class A() {\n  open fun compareTo(o: Any): Int = 0\n}\nclass B() : A(), Comparable<B> {\n  override fun compareTo(o: B): Int = 0\n}\n\nfun main(args: Array<String>) {\n  println(B().compareTo(Object()))\n}\n"
        },
        {
            "code": "\nclass CompilerBug {\n    internal var `var` = 0\n\n    inner class Inner @JvmOverloads constructor(r: Runnable = Runnable { `var` = 1 })\n\n    companion object {\n\n        @JvmStatic fun main(args: Array<String>) {\n            CompilerBug().Inner()\n        }\n    }\n}\n"
        },
        {
            "code": "\nval pair = 'z' to 'z'\npair.first.compareTo(pair.second)\n"
        },
        {
            "code": "\nabstract class Base(number: Int)\n\nclass One : Base(ONE) {\n  companion object {\n    const val ONE = 1\n  }\n}\n\nclass Two : Base(TWO) {\n  companion object {\n    private const val TWO = 2\n  }\n}\n"
        },
        {
            "code": "\nfun qwe_lateinit() {\n    val x = object {\n        lateinit var y: String\n    }\n\n    console.log(x.y)\n    console.log(\"ok\")\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.SequenceBuilder\nimport kotlin.coroutines.experimental.buildSequence\n\ntailrec suspend fun SequenceBuilder<Int>.fromTo(from: Int, to: Int) {\n    if (from > to) return\n    yield(from)\n    return fromTo(from + 1, to)\n}\n\nfun main(args: Array<String>) {\n    val seq = buildSequence {\n        fromTo(1, 5)\n    }\n    println(seq.toList())\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    var test = \"Hello\"\n    run {\n        test = \"world\"\n    }\n    println(test)\n}\n"
        },
        {
            "code": "\nfun Collection<Int>.sum(): Int {\n  var r = 0\n  forEach { r += it }\n  return r\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    var i = 0\n    run {\n        println(i)\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\nimport test.CallableRefExample4.foo\nimport kotlin.reflect.KFunction\n\nabstract class Base(val z: KFunction<Unit>)\n\nobject CallableRefExample4 : Base(::foo) {\n    fun foo() { println(this) }\n}\n\nfun main() {\n    CallableRefExample4.z.call()\n}\n"
        },
        {
            "code": "\nfun test(a: UInt) =\n        when (a) {\n            0u -> \"zero\"\n            1u -> \"one\"\n            2u -> \"two\"\n            3u -> \"three\"\n            else -> \"other\"\n        }\n"
        },
        {
            "code": "\nfun solve(input: String, part1: Boolean) {\n    val frequencies = Array(8) { LongArray(26) }\n\n    for (line in input.split(\"\\n\")) {\n        line.forEachIndexed { i, char ->\n            frequencies[i][char - 'a']++ // the ++ seems to be the culprit\n        }\n    }\n\n    println(frequencies.joinToString { ('a' + it.indexOfMax()).toString() })\n}\n"
        },
        {
            "code": "\nopen class Base {\n    init { f() }\n    open fun f() { }\n}\n\nclass DerivedNull : Base() {\n    var s: String? = null\n    override fun f() { s = \"set in f()\" }\n}\n\nclass DerivedNotNull : Base() {\n    var s: String? = \"set in ctor\"\n    override fun f() { s = \"set in f()\" }\n}\n\nfun main(args: Array<String>) {\n    println(DerivedNull().s)\n    println(DerivedNotNull().s)\n}\n"
        },
        {
            "code": "\nset in f()\nset in ctor\n"
        },
        {
            "code": "\nclass Test {\n    @Test\n    fun foo() {\n        val child = Child()\n        assertEquals(42, child.someVar)\n    }\n}\n\nabstract class Parent {\n    constructor() {\n        setValue()\n    }\n\n    abstract fun setValue()\n}\n\nclass Child : Parent() {\n    var someVar: Long = 0\n\n    override fun setValue() {\n        someVar = 42\n    }\n}\n"
        },
        {
            "code": "\nclass A {\n    fun fooLongSyntheticAccessor(capt: Int): String {\n        val o = run {\n            object {\n                fun run(captured: String): String {\n                    return {\n                        callPrivate(capt, captured)\n                    }()\n                }\n\n                private fun callPrivate(x: Int, y: String?): String = \"O\" + x + y\n            }\n        }\n        return o.run(\"K\")\n    }\n}\n\nfun main() {\n    println(A().fooLongSyntheticAccessor(5))\n}\n"
        },
        {
            "code": "\n    class MyMap: TestMap() {\n\n    }\n\n    fun F()\n    {\n        val map = MyMap()\n        map.remove(\"aaa\", 42)\n        map.getOrDefault(\"aaa\", 42)\n    }\n"
        },
        {
            "code": "\nfun testSigned(a: Long, b: Long) = (a..b).forEach { println(it) }\n\nfun testUnsigned(a: ULong, b: ULong) = (a..b).forEach { println(it) }\n"
        },
        {
            "code": "\ninline fun test(p: String, s: () -> Call = {\n    object : Call {\n        override fun run() = p\n    } as Call\n}) = s() \n"
        },
        {
            "code": "\ninline fun f(mapper: (Int) -> Number = { it }) {}\n\nfun main(args: Array<String>) = f()\n"
        },
        {
            "code": "\nfun <T> identity(value: T): T = value\n\ninline fun g(mapper: (Int) -> Number = ::identity) {}\n\nfun main(args: Array<String>) = g()\n"
        },
        {
            "code": "\nfun f(mapper: (Int) -> Number = { it }) {}\nfun g(mapper: (Int) -> Number = ::identity) {}\n"
        },
        {
            "code": "\ninline fun f(mapper: (Int) -> Int = { it }) {}\ninline fun g(mapper: (Int) -> Int = ::identity) {}\n"
        },
        {
            "code": "\ninline fun f(mapper: (Int) -> Number = { it }) {}\ninline fun g(mapper: (Int) -> Number = ::identity) {}\n\nfun main(args: Array<String>) {\n\tf { it }\n\tg { it }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n\tval mapper: (Int) -> Number = { it }\n\tval mapper2: (Int) -> Number = ::identity\n}\n"
        },
        {
            "code": "\nimport java.util.*\n\n@ExperimentalUnsignedTypes\nfun test(sortedMap: SortedMap<UInt, String>) {\n\n    val key = sortedMap.firstKey()\n}\n\n"
        },
        {
            "code": "\nimport java.util.*\n\n@ExperimentalUnsignedTypes\nfun test(sortedMap: SortedMap<UInt, String>) {\n\n    val key: UInt = sortedMap.firstKey() //val key: UInt? = sortedMap.firstKey() also compiles successfully\n}\n"
        },
        {
            "code": "\nimport java.util.*\n\n@ExperimentalUnsignedTypes\nfun test(sortedMap: SortedMap<UInt, String>) {\n\n    val (key, value) = sortedMap.entries.first()\n}\n"
        },
        {
            "code": "\nimport java.util.*\n\n@ExperimentalUnsignedTypes\nfun test(sortedMap: SortedMap<UInt, String>) {\n\n    val (key: UInt, value) = sortedMap.entries.first()\n}\n"
        },
        {
            "code": "\nimport javafx.beans.property.SimpleObjectProperty\n\nval property = SimpleObjectProperty(0u)\n\nfun main(args: Array<String>) {\n    property.addListener { _, _, new -> println(new) }  // This line causes the issue\n}\n"
        },
        {
            "code": "\nfun test1(): String {\n    Array<Int>(1) {\n        return \"OK1;\"\n    }\n    \n    return \"fail1;\"\n}\n\nfun test2(): String {\n    IntArray(1) {\n        return \"OK2;\"\n    }\n    \n    return \"fail2;\"\n}\n\nfun main(args: Array<String>) {\n    println(test1() + test2())\n}\n"
        },
        {
            "code": "\nclass A : Iterable<String> {\n    override fun iterator() = null\n\n    override fun iterator() = null\n}\n"
        },
        {
            "code": "\nfun x(f: (Int) -> String) {\n\n}\n\nfun usage() {\n    x(Int::toString)\n}\n\nfun usage2() {\n    x(Int::toString)\n}\n"
        },
        {
            "code": "\ntailrec\nfun f(i: Int) {\n    (1..i-1).forEach { return f(it) }\n}\n\nfun main(args: Array<String>) {\n    f(10)\n}\n"
        },
        {
            "code": "\nclass A {\n    private companion object {\n        const val B = 1\n    }\n}\n"
        },
        {
            "code": "\nclass Foo {\n    private fun foo() {}\n\n    private inline fun inlined() {\n        foo()\n    }\n}\n"
        },
        {
            "code": "\nsuspend fun doWork() {}\n\nsuspend fun callDoWork() {\n    doWork() // no tail call optimisation\n}\n\nsuspend fun callDoWorkReturn() {\n    return doWork() // optimised, no continuation or state machine\n}\n"
        },
        {
            "code": "\nfun `test that ? works`() = doTest { /* a lambda function */ }\n"
        },
        {
            "code": "\nobject A {\n    fun b(c: List<Int>) {\n        c.map(::d).sum()\n    }\n\n    fun d(e: Int) = e + 1\n}\n"
        },
        {
            "code": "\nclass C {\n\n  fun task() {\n    listOf(1, 2, 3)\n        .map(::intToString)\n  }\n\n  fun intToString(value: Int) = value.toString()\n}\n"
        },
        {
            "code": "\nobject Foo {\n    fun `function with spaces`(): String {\n        data class Bar (val s: String)\n        return Bar(\"xyz\").toString()\n    }\n}\n\nfun main(args: Array<String>) {\n    println(Foo.`function with spaces`())\n}\n"
        },
        {
            "code": "\nclass `foo bar`() {\n    data class baz(val v: Int)\n}\n"
        },
        {
            "code": "\nfun `foo bar`() {\n    data class baz(val v: Int)\n}\n"
        },
        {
            "code": "\nclass C {\n    fun `foo bar`() {\n        data class baz(val v: Int)\n    }\n}\n"
        },
        {
            "code": "\nclass CursorsKtTest {\n    @Test\n    fun `bro ken`() {\n        // cannot spy lambda because it is final :(\n        open class Func1 {\n            open fun call(c: String): Any = Any()\n        }\n\n        val spy = mock(Func1::class.java)\n    }\n\n    @Test\n    fun `working`() {\n        // cannot spy lambda because it is final :(\n        open class Func1 {\n            open fun call(c: String): Any = Any()\n        }\n\n        val spy = mock(Func1::class.java)\n    }\n}\n"
        },
        {
            "code": "\nfun `a b`() { { object {} } }\n"
        },
        {
            "code": "\nfun <`E e e`> z() = 1\n"
        },
        {
            "code": "\nclass Test {\n    private lateinit var prop: Any\n\n    fun test() {\n        if (!::prop.isInitialized) {\n            synchronized(this) {\n                if (!::prop.isInitialized) {\n                    prop = Any()\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\nclass Test {\n    private lateinit var prop: Any\n\n    fun test() {\n        if (!::prop.isInitialized) {\n            synchronized(this) {\n//                if (!::prop.isInitialized) {\n                    prop = Any()\n//                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\nprivate lateinit var mMarker: Marker\n"
        },
        {
            "code": "\nclass MyService(val name: String)\n\nclass MyServiceProvider() {\n    private lateinit var service: MyService\n    private val initLock: Any = Object()\n\n    public fun getOrCreateService(): MyService {\n        synchronized(initLock) {\n            if (!this::service.isInitialized) {\n                service = MyService(\"foo\")\n            }\n            return service\n        }\n    }\n}\n\n\nfun main(args: Array<String>) {\n    println(MyServiceProvider().getOrCreateService().name)\n}\n"
        },
        {
            "code": "\nimport android.os.Bundle\nimport android.support.v7.app.AppCompatActivity\nimport android.util.Log\nimport androidx.view.isVisible\nimport com.trello.rxlifecycle2.android.lifecycle.kotlin.bindToLifecycle\nimport io.reactivex.Observable\nimport io.reactivex.android.schedulers.AndroidSchedulers\nimport kotlinx.android.synthetic.main.activity_main.*\nimport java.util.concurrent.TimeUnit\n\nfun <T> Observable<T>.observeOnMainTread(): Observable<T> =\n    observeOn(AndroidSchedulers.mainThread())\n\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val someObservable = Observable.interval(1, TimeUnit.SECONDS).map { it % 2 == 0L }\n\n        someObservable.bindToLifecycle(this).observeOnMainTread().subscribe {\n\n            Log.d(\"visibility\", it.toString())\n\n            // This doesn't compile\n            helloText.isVisible = it\n\n            // This works:\n            /*\n            if (it) {\n                helloText.isVisible = true\n            } else {\n                helloText.isVisible = false\n            }\n            */\n        }\n    }\n}\n"
        },
        {
            "code": "\nclass DuplicateGetter {\n    val test: Double = 0.0\n    fun getTest(): Int = 0\n}\n\nfun (args: Array<String>) {\n    val instance = DuplicateGetter()\n    println(\"test: ${instance.test} | getTest: ${instance.getTest()}\")\n}\n\n/// result:\n/// test: 0.0 | getTest: 0\n"
        },
        {
            "code": "\nclass A {\n    fun foo(a: a) {\n        println(a)\n    }\n}\n\nobject a {}\n\nfun main(args: Array<String>) {\n    A().foo(a)\n}\n"
        },
        {
            "code": "@RequestMapping(\"/edit_thing\")\n    internal fun editThing(@RequestParam(\"id\", required = false) id: Int = -1,\n                              thingWrapper: ThingWrapper = ThingWrapper()): String\n"
        },
        {
            "code": "\nexpect class Foo {\n  fun foo(a: Int, b: Int)\n}\n"
        },
        {
            "code": "\nactual class Foo {\n  @JvmOverloads\n  actual fun foo(a: Int, b: Int = 0) {}\n}\n"
        },
        {
            "code": "\nexpect class Foo {\n  fun foo(a: Int, b: Int = 0)\n}\n"
        },
        {
            "code": "\nactual class Foo {\n  @JvmOverloads\n  actual fun foo(a: Int, b: Int) {}\n}\n"
        },
        {
            "code": "\nclass ConstructingProviderTest {\n    /*@Test fun `construct() constructs simple object`() {\n        class A @Inject constructor()\n        val context = IocContext(this)\n        val provider = ConstructingProvider(context, A::class)\n        provider.construct()\n    }*/\n    // ^ this works fine\n\n    //@Test fun `dawdawda`() { <--- this works fine if swapped with below line\n    @Test fun `construct() constructs complex object`() {\n        class A  constructor()\n        data class B constructor(val a: A)\n    }\n}\n"
        },
        {
            "code": "\ndata class Foo(val bar: String)\n"
        },
        {
            "code": "\n    val mouseButtonCallback: MouseButtonCallbackT = { button: Int, action: Int, _: Int ->\n        if (action == GLFW_PRESS && button in 0..2)\n            mouseJustPressed[button] = true\n    }\n"
        },
        {
            "code": "\n@ExperimentalUnsignedTypes\nfun main(args: Array<String>) {\n    var a: UByte = 0u\n    --a\n    println(a)  // 255\n}\n"
        },
        {
            "code": "\n@ExperimentalUnsignedTypes\nfun main(args: Array<String>) {\n    var a: UByte = 0u\n    println(--a) // -1\n}\n"
        },
        {
            "code": "\n@ExperimentalUnsignedTypes\nfun main(args: Array<String>) {\n    val a: UByte = 0u\n    val b: UByte = 1u\n    println(a - b) // 4294967295\n}\n"
        },
        {
            "code": "\n\nimport com.natpryce.hamkrest.absent\nimport com.natpryce.hamkrest.assertion.assertThat\nimport com.natpryce.hamkrest.equalTo\nimport org.jetbrains.spek.api.Spek\nimport org.jetbrains.spek.api.dsl.it\n\nobject DodgyInitialisationSpec: Spek({\n    it(\"should not initialise vars to default values, apparently\"){\n        val dodgy = DodgyInitialisation{\n            initToFalse = true\n            initToTrue = false\n            initNullableToFalse = true\n            initNullableToTrue = false\n            initNullableToNull = true\n        }\n\n        dodgy.apply {\n            assertThat(initToFalse, equalTo(true))\n            assertThat(initToTrue, equalTo(false))  // this fails, but should pass\n            assertThat(initNullableToFalse, equalTo(false))\n            assertThat(initNullableToTrue, equalTo(true))\n            assertThat(initNullableToNull, absent()) // this fails, but should pass\n        }\n    }\n})\n\nclass DodgyInitialisation(init: DodgyInitialisation.() -> Unit = {}) {\n\n    init {\n        // execute our init block before var declaration\n        init()\n    }\n\n    var initToFalse: Boolean = false // No bytecode for this\n    var initToTrue: Boolean = true // But we have bytecode for this\n    var initNullableToFalse: Boolean? = false\n    var initNullableToTrue: Boolean? = true\n    var initNullableToNull: Boolean? = null\n}\n"
        },
        {
            "code": "\npackage org.jetbrains.kotlin\n\nimport kotlinx.io.core.*\n\nfun main() {\n    ByteReadPacket.Empty.f()\n}\n\nfun Input.f(): Int {\n    takeWhileSize {\n        return 1\n    }\n\n    return 0\n}\n"
        },
        {
            "code": "\ninline fun <reified T : Activity> Context.startActivity(\n        clearStack: Boolean = false,\n        bundleBuilder: Bundle.() -> Unit = {},\n        intentBuilder: Intent.() -> Unit = {}\n) {\n    val intent = Intent(this, T::class.java)\n    if (clearStack) intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK or Intent.FLAG_ACTIVITY_NEW_TASK)\n    intent.intentBuilder()\n    val bundle = Bundle()\n    bundle.bundleBuilder()\n    startActivity(intent, bundle)\n    if (clearStack && this is Activity) finish()\n}\n"
        },
        {
            "code": "\ninline fun <reified T : AboutActivityBase> Context.kauLaunchAbout() =\n        startActivity<T>(bundleBuilder = {\n            withSceneTransitionAnimation(this@kauLaunchAbout)\n        })\n"
        },
        {
            "code": "\nplainText(R.string.kau_about_app) {\n    onClick = { kauLaunchAbout() }\n}\n"
        },
        {
            "code": "\npackage test\n\nval x = 42\n\nfun main(args: Array<String>) {\n    when (x) {\n        42 -> {\n            println(\"42\")\n            if (x < 0) { // (*) breakpoint\n                println(\"Hmm?\") // (**)\n            }\n        }\n        1 -> println(\"1\")\n        else -> println(\"No\")\n    }\n}\n"
        },
        {
            "code": "\ninterface A {\n\n    fun baz() {\n        println(A.hashCode())\n    }\n    private companion object\n}\n\nclass C : A\n\nfun main(args: Array<String>) {\n    C().baz()\n}\n"
        },
        {
            "code": "\nabstract class C {\n    protected abstract fun ready(): Boolean\n    protected abstract suspend fun slow(): Boolean\n\n    suspend fun optimized(): Boolean {\n        if(ready()){\n            return true\n        }\n        else {\n            return slow()\n        }\n    }\n\n    suspend fun notOptimized(): Boolean {\n        return if(ready()){\n            true\n        }\n        else {\n            slow()\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun main() {\n    val myMap = MyMutableMap<String, Int> { 0 }\n    myMap[\"1\"] = 1  // works\n    myMap[\"2\"]++    // throws exception\n}\n\nclass MyMutableMap<K, V>(\n    private val map: MutableMap<K, V> = mutableMapOf(),\n    private val defaultValueSelector: (K) -> V\n) : MutableMap<K, V> by map {\n\n    override operator fun get(key: K): V =\n        map[key] ?: defaultValueSelector(key).also { map[key] = it }\n}\n"
        },
        {
            "code": "\n  fun <T> ugly(value : Any?) = value as T\n    @Test fun checkcast() {\n        assertEquals('c', ugly<Char>(\"c\"))\n    }\n"
        },
        {
            "code": "\nabstract class A {\n    abstract fun foo(x: Int = 1, y: Int): Int\n}\n\ninterface B {\n    fun foo(x: Int, y: Int = 2): Int\n}\n\nclass C : A(), B {\n    override fun foo(x: Int, y: Int) = x + y\n}\n\nfun main(args: Array<String>) {\n    println(C().foo())\n}\n"
        },
        {
            "code": "\nfun test(x: Any) {\n    map1 { x } // should expand into: { { x } }\n}\n\ninline fun anonymous(crossinline f: () -> Unit) {\n    { f() }\n}\n\ninline fun map1(crossinline f: () -> Unit) {\n    anonymous { map2(f) }\n}\n\ninline fun map2(crossinline f: () -> Unit) {\n    anonymous { f() }\n}\n"
        },
        {
            "code": "\ninline fun <T, R> fixInlineBug1(crossinline f: (T) -> R): (T) -> R = { f(it) }\ninline fun <R>    fixInlineBug0(crossinline f: () -> R): () -> R = { f() }\n"
        },
        {
            "code": "\nmap1 (fixInlineBug0 { x })\n"
        },
        {
            "code": "\nimport org.junit.Test\nimport javax.inject.Provider\n\nclass ProviderSSCCE{\n\n    @Test fun `things`(){\n        val blam = Extended\n    }\n}\n\nopen class Base(provider: Provider<Number>)\n\nobject Extended : Base(Provider { 32 })\n"
        },
        {
            "code": "\nfun printLineNumber() {\n    Throwable().printStackTrace()\n}\n\nfun normalFunction() {\n\n}\n\ninline fun inlineFunction() {\n\n}\n\nfun test1() {\n    inlineFunction()\n    printLineNumber()\n}\n\nfun test2() {\n    normalFunction()\n    printLineNumber()\n}\n\nfun test3() {\n    println()\n    printLineNumber()\n}\n\nfun main(vararg args: String) {\n    test1()\n    test2()\n    test3()\n}\n"
        },
        {
            "code": "\ninline fun <reified F> laws(M: Monad<F> = monad<F>(), EQ: Eq<HK<F, Int>> = Eq()): List<Law>\n"
        },
        {
            "code": "\n Law(\"Monad / JVM: stack safe\", { stackSafety(M = M) })\n"
        },
        {
            "code": "\nvar inc: String = \"\"\n\nclass X {\n    var result: String = \"fail\"\n\n    operator fun get(name: String, type: String = \"none\") = name + inc + type\n\n    operator fun set(name: String, s: String) {\n        result = name + s;\n    }\n}\n\noperator fun String.inc(): String {\n    inc = this + \"1\"\n    return this + \"1\"\n}\n\nfun box(): String {\n    var x = X()\n    val res = ++(x[\"a\"])\n    println(\">> $res\")\n    if (x.result != \"aanone1\") return \"fail 1: ${x.result}\"\n\n    if (res != \"aanone1none\") return \"fail 2: ${res}\"\n\n    return \"OK\"\n}\n\nfun main(arg:Array<String>) {\n    println(box())\n}\n"
        },
        {
            "code": "\nimport rx.Observable\nimport rx.functions.Action1\n\nfun Unit.wz(unit: Unit) {}\n\ninline fun foo(crossinline init: Unit.() -> Unit): (Unit) -> Unit = { it.init() }\n\nfun bar(a: Action1<String>) {}\n\nval l = foo {\n    val value = Observable.just(Unit)\n    smth {\n        value.subscribe(this::wz)\n    }\n}\n\ninline fun Unit.smth(init: Unit.() -> Unit) = Unit.init()\n"
        },
        {
            "code": "\npackage test\n\nfun main(args: Array<String>) {\n    (arrayOf(1, 2, 3)::get)(1)\n}\n"
        },
        {
            "code": " kotlin\nclass X {\n    fun g(x : () -> Boolean = { super.equals(this) }) = println(x())\n}\n\nfun main(args: Array<String>) {\n    X().g()\n}\n"
        },
        {
            "code": "\npackage d8\n\nimport utils.Day\n\nfun main(args: Array<String>) = Day8()\n\nobject Day8 : Day({\n    +\"\"\"\n    rect 3x2\n    rotate column x=1 by 1\n    rotate row y=0 by 4\n    rotate column x=1 by 1\n\"\"\".trimMargin()\n}) {\n\n    const val WIDTH = 50\n    const val HEIGHT = 6\n\n    operator fun Array<BooleanArray>.get(x: Int, y: Int) = this[x][y]\n\n    fun Array<BooleanArray>.transform(op: Op) = op.transform(this)\n\n    interface Op {\n        fun transform(screen: Array<BooleanArray>): Array<BooleanArray>\n    }\n\n    class Rect(val x: Int, val y: Int) : Op {\n        override fun transform(screen: Array<BooleanArray>) = Array(WIDTH) { x ->\n            screen[x].mapIndexed { y, _ ->\n                x < this.x && y <= this.y\n            }.toBooleanArray()\n        }\n    }\n\n    class Column(val x: Int, val value: Int) : Op {\n        override fun transform(screen: Array<BooleanArray>) = screen.mapIndexed { x, column ->\n            if (x == this.x) {\n                BooleanArray(HEIGHT) { y -> column[Math.floorMod(y - value, HEIGHT)] }\n            } else {\n                column\n            }\n        }.toTypedArray()\n    }\n\n    class Row(val y: Int, val value: Int) : Op {\n        override fun transform(screen: Array<BooleanArray>) = screen.mapIndexed { x, _ ->\n            BooleanArray(HEIGHT) { y ->\n                if (y == this.y) {\n                    screen[Math.floorMod(x - value, WIDTH), y]\n                } else {\n                    screen[x, y]\n                }\n            }\n        }.toTypedArray()\n    }\n\n    val REGEX_RECT = \"\"\"rect (\\d+)x(\\d+)\"\"\".toRegex()\n    val REGEX_ROTATE = \"\"\"rotate (column|row) [xy]=(\\d+) by (\\d+)\"\"\".toRegex()\n\n    fun String.parseOp(): Op = when (takeWhile { it != ' ' }) {\n        \"rect\" -> {\n            val match = REGEX_RECT.matchEntire(this)!!\n            Rect(match.groupValues[1].toInt(), match.groupValues[2].toInt())\n        }\n        \"rotate\" -> {\n            val match = REGEX_ROTATE.matchEntire(this)!!\n            val type = match.groupValues[1]\n            val coord = match.groupValues[2].toInt()\n            val value = match.groupValues[3].toInt()\n\n            if (type == \"column\") Column(coord, value) else Row(coord, value)\n        }\n        else -> throw IllegalArgumentException()\n    }\n\n    override fun solve(input: List<String>, part1: Boolean): Any? {\n        val screen = Array(WIDTH) { BooleanArray(HEIGHT) }\n\n        val transformed = input.fold(screen) {screen, line -> screen.transform(line.parseOp())}\n        return transformed.sumBy { it.count { it } }\n    }\n}\n"
        },
        {
            "code": "\npackage utils\n\nimport kotlin.reflect.KCallable\n\nabstract class Day(inputs: Day.() -> Unit) {\n    val inputs = mutableListOf<Pair<String?, String>>()\n\n    init {\n        inputs()\n    }\n\n    operator fun String.unaryPlus() = +(null to this)\n    operator fun Pair<String?, String>.unaryPlus() = inputs.add(this)\n\n    fun res(name: String) = name to readResource(name)\n\n    operator fun invoke() {\n        inputs.forEach {\n            println(solve(it.second, true))\n            println(solve(it.second, false))\n        }\n    }\n\n    open fun String.split(): List<String> = splitLines()\n\n    open fun solve(input: String, part1: Boolean) = solve(input.split(), part1)\n    open fun solve(input: List<String>, part1: Boolean): Any? = \"\"\n}\n\n\nprivate class Foo\n\nfun readResource(name: String) = Foo::class.java\n        .getResourceAsStream(\"/\" + name)\n        .bufferedReader()\n        .use { it.readText() }\n\nfun String.splitLines() = split(\"\\\\r?\\\\n\".toRegex())\n"
        },
        {
            "code": "\ninline fun foo(f: (Int) -> Int, ff: ((Int) -> Int) -> Int) {\n    ff(f)\n}\n\nfun main(args: Array<String>) {\n    foo({ it }, { it(4) })\n}\n"
        },
        {
            "code": "\n@JvmName(\"fooA\")\nprivate fun String?.foo(t: String?): String? = \"\"\nprivate fun String?.foo(t: String): String = \"\"\nfun use() {\n    compareBy<String> {\n        \"\".foo(\"\")\n        \"\".foo(null)\n    }\n}\n"
        },
        {
            "code": "\nclass Example {\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            f(String::class)\n            f(Int::class)\n        }\n    }\n}\n\n@JvmName(\"fc\") private fun f(kClass: KClass<out CharSequence>) = _f(kClass)\n@JvmName(\"fn\") private fun f(kClass: KClass<out Number>) = _f(kClass)\nprivate fun _f(kClass: KClass<*>) {\n}\n"
        },
        {
            "code": "\ninline fun foo(): (Int) -> Int = { it + 1}\n\ninline fun bar(): (Int) -> Int = { it * 2}\n\ninline fun compose(crossinline f: (Int) -> Int,\n                   crossinline g: (Int) -> Int): (Int) -> Int {\n    return { f(g(it)) }\n}\n\nfun test(f: (Int) -> Int) = f(42)\n\nfun go() {\n    test(compose(foo(), bar()))  // :(\n}\n"
        },
        {
            "code": "\ninline fun <reified T: Event> registerListener(crossinline handler: (event: T) -> Unit) {\n        client.dispatcher.registerListener(IListener<T> { \n            if (!checkFieldsForBlacklist(it)) {\n                handler(it)\n            }\n        })\n    }\n"
        },
        {
            "code": "\nregisterListener<MessageReceivedEvent> {\n           //Stuff here\n        }\n"
        },
        {
            "code": "\nimport org.junit.jupiter.api.Test\nimport kotlin.test.assertEquals\n\n\nclass Container {\n\n    var id: Int? = null\n}\n\n\nclass TestClass {\n\n    @Test\n    fun doThings1() {\n        val containers = createContainers1()\n        assertEquals(containers.size, 101)\n    }\n\n    @Test\n    fun doThings2() {\n        val containers = createContainers2()\n        assertEquals(containers.size, 101)\n    }\n\n    private fun createContainer(id: Int): Container { val q = Container(); q.id = id; return q }\n    private fun createContainers1(from: Int = 0, to: Int = 100) = (from .. to).map(::createContainer)\n    private fun createContainers2(from: Int = 0, to: Int = 100): List<Container> { return (from .. to).map(::createContainer) }\n}\n"
        },
        {
            "code": "\npackage foo\n\nimport kotlin.reflect.full.primaryConstructor\n\nclass A(val x: Int, val y: Int)\n\ninline fun <reified T : Any> f() {\n    for (p in T::class.primaryConstructor!!.parameters.sortedBy { it.index }) {\n        println(p)\n    }\n}\n"
        },
        {
            "code": "\nimport foo.A\nimport foo.f\n\nfun main(args: Array<String>) {\n    f<A>()\n}\n"
        },
        {
            "code": "\nclass A {\n    companion object {\n        // not required, just to make this runnable\n        @JvmStatic\n        fun main(args: Array<String>) {\n        }\n    }\n\n    var field = 0\n\n    inline fun a(f: () -> Any): Any {\n        try {\n            val value = f()\n            return value\n        } finally {\n            field--\n        }\n    }\n\n    private inline fun b(rule: () -> Unit) {\n        try {\n            rule()\n        } catch (fail: Throwable) {}\n    }\n\n    fun c(vararg functions: () -> Any): Any = a {\n        for (function in functions) {\n            b { return function() }\n        }\n        throw Throwable()\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    A().foo {}\n}\n\nclass A {\n    val foo = fun(call: () -> Unit) =\n            ext {\n                fun send() {\n                    call()\n                }\n\n                bar {\n                    send()\n                }\n            }\n\n    fun bar(body: () -> Unit) {\n\n    }\n\n    inline fun A.ext(init: X.() -> Unit) {\n        return X().init()\n    }\n\n    class X\n}\n"
        },
        {
            "code": "\nclass Test {\n    fun test() {\n        try {\n            apply {\n                try {\n                    return test()\n                } catch (e: Exception) {\n\n                } catch (e: Throwable) {\n\n                }\n            }\n        } finally {\n            \n        }\n    }\n}\n"
        },
        {
            "code": "\nclass StateMap private constructor(private val names: Array<String>) {\n  companion object {\n    val EMPTY = StateMap(emptyArray())\n  }\n}\n"
        },
        {
            "code": "\ninline fun f(\n    wait: Int = 0,\n    action: (Int) -> Unit\n): Boolean {\n    var millis: Long = 1\n    try {\n    } catch (e: Throwable) {\n        millis = millis\n    }\n    return false\n}\n\nfun main(args: Array<String>) {\n    var x = 0\n    f {\n        x++\n    }\n}\n"
        },
        {
            "code": "\n    @Test fun `one two`(){\n        class Message(val outputQuestionLine: String, val response: CompletableDeferred<String> = CompletableDeferred())\n\n        val localDecoder = listOf<Message>()\n    }\n"
        },
        {
            "code": "\ninterface A {\n    companion object {\n        const val x = 1\n    }\n}\n"
        },
        {
            "code": "\n\nimport java.lang.ref.WeakReference\nimport java.util.*\n\nclass LabelHolder {\n\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            // just run it, and you'll get VerifyError\n        }\n    }\n\n    private val labels = IdentityHashMap<String?, WeakReference<String>>()\n    private val String?.label: String\n        get(): String = labels.getOrPutWeak(this) { \"hello\" }\n}\n\n// removing 'inline' removes this error\ninline fun <K, V> MutableMap<K, WeakReference<V>>.getOrPutWeak(key: K, defaultValue: ()->V): V {\n    val value = get(key)?.get()\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, WeakReference(answer))\n        answer\n    } else {\n        value // adding 'as V' removes this error\n    }\n}\n"
        },
        {
            "code": "\ninline fun test() {\n    val key = object {}.javaClass\n    println(key)\n  }\n"
        },
        {
            "code": "\nclass B<T> {\n    inline fun bar(value: T) {}\n}\n\nclass A {\n    inline fun <T> foo(block: B<T>.() -> Unit) {}\n}\n\nfun main() {\n  val a = A()\n  val str = \"xyz\"\n  a.foo<String>( { bar(str) } )\n}\n"
        },
        {
            "code": "\nclass C {\n    var inserting: Boolean = false\n    fun nextSlot(): Any? = null\n    fun startNode(key: Any?) {}\n    fun endNode() {}\n    fun emitNode(node: Any?) {}\n    fun useNode(): Any? = null\n    fun skipValue() {}\n    fun updateValue(value: Any?) {}\n}\nclass B<T>(val composer: C, val node: T) {\n    inline fun <V> bar(value: V, block: T.(V) -> Unit) = with(composer) {\n        if (inserting || nextSlot() != value) {\n            updateValue(value)\n            node.block(value)\n        } else skipValue()\n    }\n}\nclass A(val composer: C) {\n    inline fun <T> foo(key: Any, ctor: () -> T, update: B<T>.() -> Unit) = with(composer) {\n        startNode(key)\n        val node = if (inserting)\n            ctor().also { emitNode(it) }\n        else useNode() as T\n        B<T>(this, node).update()\n        endNode()\n    }\n}\nfun main() {\n  val a = A(C())\n  val str = \"xyz\"\n  a.foo<String>(\n      123,\n      { \"abc\" },\n      { bar(str) { } }\n  )\n}\n"
        },
        {
            "code": "\nfun function() {\n    val r = \"\"\n    val a = run {\n        fun f(x: Long, y: String? = null) {\n            r\n        }\n    }\n}\n"
        },
        {
            "code": "\n/** copies the contents of the InputStream to the OutputStream.\n * @param progressHandler is invoked every time after the buffer has been transferred. If it returns true, then the copying will cease immediately */\nfun InputStream.copyTo(out: OutputStream, closeIn: Boolean = false, closeOut: Boolean = false, progressHandler: (Long) -> Boolean): Long {\n\ttry {\n\t\tval buffer = ByteArray(DEFAULT_BUFFER_SIZE)\n\t\tvar bytesCopied = 0L\n\t\tvar bytes = read(buffer)\n\t\twhile (bytes >= 0) {\n\t\t\tout.write(buffer, 0, bytes)\n\t\t\tbytesCopied += bytes\n\t\t\tif (progressHandler(bytesCopied))\n\t\t\t\tbreak\n\t\t\tbytes = read(buffer)\n\t\t}\n\t\treturn bytesCopied\n\t} finally {\n\t\tif (closeIn)\n\t\t\tthis.close()\n\t\tif (closeOut)\n\t\t\tout.close()\n\t}\n}\n"
        },
        {
            "code": "\nfun test() {\n    fun b() {}\n    b()\n}\n"
        },
        {
            "code": "\nsuspend fun test() {\n    test()\n    test()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val c = UInt::class.javaObjectType  // Similar exception with `.javaPrimitiveType!!`\n    val x = c.cast(123)\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.*\n\nfun main() {\n    suspend fun Rec.dfs() {}\n    Rec { dfs() }\n}\n\n@RestrictsSuspension\nclass Rec(block: suspend Rec.() -> Unit) {\n    init { block.startCoroutine(this, Continuation(EmptyCoroutineContext) {}) }\n}\n"
        },
        {
            "code": "\n    fun testOuterJobIsCancelled() = runTest {\n        suspend fun callJobScoped() = coroutineScope {\n            launch {\n                expect(3)\n                try {\n                    delay(Long.MAX_VALUE)\n                } finally {\n                    expect(4)\n                }\n            }\n\n            expect(2)\n            delay(Long.MAX_VALUE)\n            42\n        }\n\n        val outerJob = launch(NonCancellable) {\n            expect(1)\n            try {\n                callJobScoped()\n                expectUnreached()\n            } catch (e: CancellationException) {\n                expect(5)\n                assertNull(e.cause)\n            }\n        }\n        repeat(3) { yield() } // let everything to start properly\n        outerJob.cancel()\n        outerJob.join()\n        finish(6)\n    }\n"
        },
        {
            "code": "\nfun `Creates an instance using constructor with collections, primitives and standard types`() {\n    class B(val i: Int)\n    class C(val b1: B, val c: Map<Int, Int>)\n    val c: C = makeRandomInstance()\n    print(c)\n}\n\nfun main(args: Array<String>) {\n    `Creates an instance using constructor with collections, primitives and standard types`()\n}\n\ninline fun <reified T> makeRandomInstance(): T {\n    return makeRandomInstance(T::class) as T\n}\n\nclass NoUsableConstructor : Error()\n\nfun makeRandomInstance(clazz: KClass<*>): Any? {\n    val primitive = makeStandardInstanceOrNull(clazz)\n    if (primitive != null) {\n        return primitive\n    }\n\n    val constructors = clazz.constructors\n            .sortedBy { it.parameters.size }\n\n    for (constructor in constructors) {\n        try {\n            val arguments = constructor.parameters\n                    .map { it.type.classifier as KClass<*> }\n                    .map { makeRandomInstance(it) }\n                    .toTypedArray()\n\n            return constructor.call(*arguments)\n        } catch (e: Throwable) {\n            e.printStackTrace()\n            // no-op. We catch any possible error here that might occur during class creation\n        }\n    }\n\n    throw NoUsableConstructor()\n}\n\nprivate val random = Random\nprivate fun makeStandardInstanceOrNull(clazz: KClass<*>) = when (clazz) {\n    Int::class -> random.nextInt()\n    Map::class -> makeRandomMap(clazz)\n    else -> null\n}\n\nprivate fun makeRandomMap(clazz: KClass<*>): Map<Any?, Any?> {\n    val numOfElements = random.nextInt(10) // TODO: class A(val list: List<A>) will never create\n    val keys = (1..numOfElements)\n            .map { makeRandomInstance(clazz.typeParameters[0].upperBounds[0].classifier as KClass<*>) }\n    val values = (1..numOfElements)\n            .map { makeRandomInstance(clazz.typeParameters[1].upperBounds[0].classifier as KClass<*>) }\n    return keys.zip(values).toMap()\n}\n"
        },
        {
            "code": "\npackage foo\n\nimport kotlin.contracts.ExperimentalContracts\nimport kotlin.contracts.InvocationKind\nimport kotlin.contracts.contract\n\n@ExperimentalContracts\nfun foo() {\n    val a: String\n    println(\"aa\")\n    block {\n        a = \"a\"\n    }\n    println(a)\n}\n\n@ExperimentalContracts\nfun block(block: () -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n}\n"
        },
        {
            "code": "\nimport io.vertx.core.Handler\nimport java.util.concurrent.ConcurrentHashMap\n\nfun main() {\n    val handlers = ConcurrentHashMap<Any, Handler<Int>>()\n    handlers[String::javaClass] = Handler { input ->\n        println(\"Handler for String is invoked\")\n    }\n\n    handlers[Int::javaClass] = Handler { input ->\n        println(\"Handler for Int is invoked\")\n    }\n}\n"
        },
        {
            "code": "\nclass A<T>(val b: T) {}\n\nfun test() {\n    val a = { A(1).b::javaClass }\n}\n"
        },
        {
            "code": "\nsuspend fun foo(): Result<String> {\n    return if (true) {\n        Result.success(\"42\")\n    } else {\n        Result.success(\"24\")\n    }\n}\n\nfun main() { // Not sure about `suspend main()`\n    runBlocking {\n            foo().getOrNull()\n     }\n}\n"
        },
        {
            "code": "\nimport org.mockito.BDDMockito.*\nimport kotlin.coroutines.experimental.*\n\ninterface Repo {\n    suspend fun suspendableFun()\n}\n\nfun populate(repo: Repo) {\n    builder {\n        repo.suspendableFun()\n    }\n}\n\nsuspend fun test() {\n    val repo = mock(Repo::class.java)\n    given(repo.suspendableFun()).willThrow(RuntimeException(\"\"))\n    populate(repo)\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(object : Continuation<Unit>{\n        override val context: CoroutineContext\n            get() = EmptyCoroutineContext\n\n        override fun resume(value: Unit) {\n\n        }\n\n        override fun resumeWithException(exception: Throwable) {\n            throw exception\n        }\n\n    })\n}\n\nfun main(args: Array<String>) {\n    builder { test() }\n}\n"
        },
        {
            "code": "\ninline fun test(block: () -> Any = { 1 }) {\n    block()\n}\n    \nfun main() {\n    test()\n}\n"
        },
        {
            "code": "\ninline fun test(block: () -> Any = { 1 as Any }) // ok\ninline fun test(block: () -> Int = { 1 }) // ok\n\ninline fun test(block: () -> Any = { 1 }) // crash\ninline fun test(block: () -> Number = { 1 }) // crash\n"
        },
        {
            "code": "\ninline fun foo(value: Int, action: () -> Any = { \"\" }) {\n    action()\n}\n\nfun main() {\n    foo(1)\n}\n"
        },
        {
            "code": "\npackage sample\n\nimport java.util.concurrent.atomic.AtomicReference\n\nfun main(args: Array<String>) {\n    println(\"A: \" + UByte::class)\n    println(\"B: \" + 0.toUByte().javaClass)\n    println(\"C: \" + 0.toUByte()::class)\n    println(\"D: \" + AtomicReference(0.toUByte()).get()::class)\n    println(\"E: \" + AtomicReference(0.toUByte()).get().javaClass)\n}\n"
        },
        {
            "code": "\nclass Container(val item: Item = Item())\nclass Item(val i: Int = 3)\n\nclass Test {\n    var arrayOfContainers = arrayOf<Container>()\n\n    fun setupAndGet(): Container {\n        setup(1)\n        return arrayOfContainers[0]\n    }\n\n    inline fun setup(number: Int, getItem: ((Int) -> Item?) = { null }) {\n        if (number <= 0) return\n\n        arrayOfContainers = Array(number) {\n            val item = getItem(it)\n            if (item != null)\n                Container(item)\n            else\n                Container()\n        }\n    }\n}\n\n\nfun main(args: Array<String>) {\n    val t = Test()\n    t.setup(3) { Item(4) }\n    t.setupAndGet()\n}\n"
        },
        {
            "code": "\nenum class TarEnum {\n    VAL\n}\ninline fun <reified T : Enum<T>> String?.enumOrNull(): T? {\n    this ?: return null\n    return enumValues<T>().firstOrNull { it.name == this }\n}\n\ninline fun <reified T : Enum<T>> String?.enumOrThrow(handleNull: () -> Throwable = { IllegalArgumentException(\"Enum type ${T::class.java} not contain value=$this\") }): T {\n    return this.enumOrNull<T>() ?: throw handleNull()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    \"VAL\".enumOrThrow<TarEnum>() { IllegalArgumentException() }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    \"VAL\".enumOrThrow<TarEnum>()\n}\n"
        },
        {
            "code": "\nparentOfType<JuliaStatements>()\n"
        },
        {
            "code": "\nparentOfType<JuliaStatements>()\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    class LeakedType(val source: String)\n    class ClassWithCallback {\n        var someCallback: (() -> Unit)? = null\n\n        fun dumpCallbackFields() =\n            someCallback!!.javaClass.declaredFields\n                .map { it.get(someCallback!!) as LeakedType }\n                .forEach { println(\"From callback fields :: leakedType=${it.source}\") }\n    }\n\n    val classWithCallback = ClassWithCallback()\n\n    val outer = LeakedType(\"Used in callback\")\n    val leaked = LeakedType(\"Used in apply block but not callback\")\n\n    classWithCallback.apply {\n        someCallback = { println(\"In callback :: leakedType=${outer.source}\") }\n        println(\"In apply block using leak arg :: leakedType=${leaked.source}\")\n    }\n    classWithCallback.dumpCallbackFields()\n}\n"
        },
        {
            "code": "\nIn apply block using leak arg :: leakedType=Used in apply block but not callback\nFrom callback fields :: leakedType=Used in callback\nFrom callback fields :: leakedType=Used in apply block but not callback\n"
        },
        {
            "code": "\nclass LeakedType(val source: String)\n\nclass SomeClass(private val fromOuterClass: LeakedType) {\n    val classWithCallback = ClassWithCallback()\n\n    fun addCallback() {\n        classWithCallback.apply {\n            someCallback = { println(\"In callback :: leakedType=${fromOuterClass.source}\") }\n        }\n    }\n\n    fun addCallback(leaked: LeakedType) {\n        classWithCallback.apply {\n            someCallback = { println(\"In callback :: leakedType=${fromOuterClass.source}\") }\n            println(\"In apply block using leak arg :: leakedType= ${leaked.source}\")\n        }\n    }\n}\n\nclass ClassWithCallback {\n    var someCallback: (() -> Unit)? = null\n\n    fun dumpCallbackFields() {\n        val someCallback = someCallback!!\n        someCallback::class.java.declaredFields.forEach {\n            println(\"field=$it\")\n            if (it.type == LeakedType::class.java) {\n                it.isAccessible = true\n                val topLevelType = it.get(someCallback) as LeakedType\n                println(\"From callback fields :: leakedType=${topLevelType.source}\")\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val fromCtor = LeakedType(\"Passed via ctor\")\n    val someClass = SomeClass(fromCtor)\n\n    someClass.addCallback()\n    someClass.classWithCallback.someCallback?.invoke()\n    someClass.classWithCallback.dumpCallbackFields()\n\n    println(\"\")\n\n    val passedToFunction = LeakedType(\"Passed as function arg\")\n    someClass.addCallback(passedToFunction)\n    someClass.classWithCallback.someCallback?.invoke()\n    someClass.classWithCallback.dumpCallbackFields()\n}\n"
        },
        {
            "code": "\n@file:Suppress(\"UNSUPPORTED_FEATURE\", \"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\nimport kotlin.internal.*\n\ninline class Result<T>(private val _value: Any?) {\n    companion object {\n        @InlineOnly inline fun <T> success(value: T): Result<T> = Result(value)\n    }\n}\n"
        },
        {
            "code": "\nfun foo(r: Result<String>) {}\n\nfun bar() = foo(Result.success(\"OK\"))\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n  val n = 1\n  repeat(1) {\n    class Foo {\n      fun bar() = n + 1\n    }\n    println(Foo::class.java.getDeclaredConstructor())\n  }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n  val n = 1\n  //  repeat(1) {\n  class Foo {\n    constructor() { println(\"in constructor\") }\n    fun bar() = n + 1\n  }\n  println(Foo::class.java.getDeclaredConstructor())\n//  }\n}\n"
        },
        {
            "code": "\npackage test.base\n\nopen class Base {\n    protected val protectedVariable = \"protected\"\n\n    protected inline fun protectedFunction(crossinline block: () -> Unit) {\n        Runnable { println(protectedVariable); block() }.run()\n    }\n}\n"
        },
        {
            "code": "\npackage test.sub\n\nimport test.base.Base\n\nclass Subclass: Base() {\n    fun execute() {\n        protectedFunction { println(\"executed\") }\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\nimport test.sub.Subclass\n\nfun main(args : Array<String>) {\n    Subclass().execute()\n}\n"
        },
        {
            "code": "\nclass A {\n    fun f() {\n        consumer1 {\n            supplier {\n                consumer1(consumer2())\n            }::apply\n        }\n    }\n\n    fun consumer2(): (Unit) -> Unit = {}\n}\n\nfun <T> supplier(f: () -> T) = f\n\ninline fun consumer1(c: (Unit) -> Unit) = c(Unit)\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.experimental.runBlocking\n\nfun main(args: Array<String>) = runBlocking {\n    do {\n        crash {}\n    } while (false)\n}\n\nsuspend inline fun crash(block: suspend () -> Unit) {\n    block()\n}\n"
        },
        {
            "code": "\nclass Test {\n    val bla = listOf(\"bla\").sortedByDescending { it }\n}\nfun main(args: Array<String>) {\n    println(Class.forName(\"Test\\$\\$special\\$\\$inlined\\$sortedByDescending\\$1\").declaringClass)\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(object : Continuation<Unit>{\n        override fun resumeWith(result: SuccessOrFailure<Unit>) {\n            result.getOrThrow()\n        }\n\n        override val context: CoroutineContext\n            get() = EmptyCoroutineContext\n\n    })\n}\n\nsuspend fun withDefaultParameter(ctx: CoroutineContext, lazy: Boolean = false) {}\n\nfun main(args: Array<String>) {\n    execute {\n        withDefaultParameter(coroutineContext)\n    }\n}\n\nprivate inline fun execute(crossinline action: suspend () -> Unit) {\n    builder { action() }\n}\n"
        },
        {
            "code": "\nsuspend inline fun <reified T : Any> ApplicationCall.getBodyParam(name: String, default: () -> T = { error(\"mandatory $name\") }): T =\n    getTypedOrNull(Source.BODY, name, T::class.java) ?: default()\n"
        },
        {
            "code": "\nfun main() {\n    val devStatus: UInt? = 0x0u\n    \n    when(devStatus) {\n        (0x0u) -> {\n            println(\"0\")\n        }\n        (0x10u) -> {\n            println(\"1\")\n        }\n        (0x20u) -> {\n            println(\"2\")\n        }\n        else -> {\n            println(\"else\")\n        }\n    }\n}\n"
        },
        {
            "code": "\n    @Test\n    fun testTablePojoConstructors() {\n        A::class.java.constructors.forEach {\n            assert(it.parameters.any { it.name == \"aString\" || it.name == \"anInt\"})\n        }\n\n        B::class.java.constructors.forEach {\n            assert(it.parameters.any { it.name == \"anotherString\" || it.name == \"anotherInt\"})\n        }\n    }\n\n    data class A(@Size(min = 1, max = 32) val aString: String, val anInt: Int)\n\n    data class B(@Size(min = 1, max = 32) val anotherString: String, val anotherInt: Int = 1, val string2: String = \"hello world\")\n"
        },
        {
            "code": "\ninternal var foo: String = \"foo\"\n    private set\n"
        },
        {
            "code": "\npublic fun bar(): Bar = Bar()\n\npublic class Bar() {\n    public fun printFoo() {\n        print(foo)\n    }\n}\n"
        },
        {
            "code": "\nimport com.google.gson.Gson\nimport com.google.gson.GsonBuilder\n\n// compile group: 'com.google.code.gson', name: 'gson', version: '2.7'\n\nclass MyTest {\n    var f1: Int? = null\n    var f2: Int? = 123\n    var f3: UInt? = null\n    var f4: UInt? = 123u\n}\n\nfun main() {\n    val engine: Gson = GsonBuilder().serializeNulls().create()\n    val t = MyTest()\n    val j = engine.toJson(t)\n    println(j) // {\"f1\":null,\"f2\":123,\"f3\":null,\"f4\":{\"data\":123}}\n}\n"
        },
        {
            "code": "\nprintln(UInt::class.java)         // int\nprintln(UInt::class)              // class kotlin.Int\n\nval uint: UInt = 0u\nprintln(uint::class.java)         // int\n\nval nuint: UInt? = 0u\nprintln(nuint!!::class.java)      // class kotlin.UInt - the only working solution!\n"
        },
        {
            "code": "\nconst val VERIFY_ASSUMPTIONS = false //deploying to production\n\nfun generateValueInBounds(lowerBound: Int, upperBound: Int): Int {\n    assumeTrue(lowerBound <= upperBound)\n    return lowerBound //fake implementation for demo\n}\n\ninline fun assumeTrue(value: Boolean) {\n    if (VERIFY_ASSUMPTIONS) {\n        assert(value)\n    }\n}\n"
        },
        {
            "code": "\n   something.keyBy { it.f0 }\n"
        },
        {
            "code": "\nsomething.keyBy(KeySelector<Tuple2<String, Int>, String> { println(x); it.f0 })\n"
        },
        {
            "code": "\nshopping_cart_swipe_container.onRefresh {\n    basketAdapter = null\n    presenter.refreshView()\n}\n"
        },
        {
            "code": "\nshopping_cart_swipe_container.setOnRefreshListener {\n    basketAdapter = null\n    presenter.refreshView()\n}\n"
        },
        {
            "code": "\nfun String.printAllWrong() {\n  for (c in this) {\n    println(c)\n  }\n}\n"
        },
        {
            "code": "\noperator fun String.iterator(): IntIterator = object : IntIterator() {\n  private var index = 0\n\n  override fun nextInt() = codePointAt(index).also {\n    index += Character.charCount(it)\n  }\n\n  override fun hasNext(): Boolean = index < length\n}\n"
        },
        {
            "code": "\nfun String.printAll() {\n  for (c in iterator()) {\n    println(c)\n  }\n}\n"
        },
        {
            "code": "\nenum class Color(val rgb: Int) {\n        RED(0xFF0000),\n        GREEN(0x00FF00),\n        BLUE(0x0000FF)\n}\n"
        },
        {
            "code": "\n// COMMON_COROUTINES_TEST\n// WITH_RUNTIME\n// WITH_COROUTINES\n\nimport helpers.*\nimport COROUTINES_PACKAGE.*\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nsuspend fun foo(until: Int): String {\n    suspend fun bar(x: Int): String =\n        if (x == until) \"OK\" else bar(x + 1)\n    return bar(0)\n}\n\nfun box(): String {\n    var res = \"FAIL\"\n    builder {\n        res = foo(10)\n    }\n    return res\n}\n"
        },
        {
            "code": "\ninterface KotlinInterface {\n    fun doSomething(a: String = \"TestA\", b: String = \"TestB\"): String {\n        return a + b;\n    }\n}\n"
        },
        {
            "code": "\nclass KotlinImplementation : KotlinInterface {\n    @JvmOverloads\n    override fun doSomething(a: String, b: String) = super.doSomething(a, b)\n}\n"
        },
        {
            "code": "\n// !LANGUAGE: +PolymorphicSignature\n// TARGET_BACKEND: JVM\n// IGNORE_BACKEND: JVM_IR\n// FULL_JDK\n// SKIP_JDK6\n// WITH_RUNTIME\n\nimport java.lang.invoke.MethodHandles\nimport java.lang.invoke.MethodType\nimport java.lang.invoke.WrongMethodTypeException\n\nclass C {\n    fun string(x: String): Any? = x\n\n    fun varargAny(vararg y: Any?): Any? = y[0]\n}\n\nfun box(): String {\n    val cstr = MethodHandles.lookup().findVirtual(C::class.java, \"string\", MethodType.methodType(Any::class.java, String::class.java))\n\n    val refstr = cstr::invokeExact\n    try {\n        refstr.invoke(arrayOf(\"Hmm\"))\n        return \"Fail\"\n    } catch (e: WrongMethodTypeException) {\n        // OK\n    }\n\n    val cva = MethodHandles.lookup().findVirtual(C::class.java, \"varargAny\", MethodType.methodType(Array<Any>::class.java, Any::class.java))\n    val refva = cva::invokeExact\n\n    return refva.invoke(arrayOf(\"OK\")) as String\n}\n"
        },
        {
            "code": "\npackage test\n\nimport kotlin.reflect.full.declaredMembers\n\ninline fun <reified T> foo() =\n        object {\n            val aClass = T::class // make it specialize\n            fun <X> foo() {}\n        }\n\nprivate fun printTypeParameters(foo: Any) {\n    for (memberFunction in foo::class.declaredMembers) {\n        println(\"-- ${memberFunction.name}:\")\n        for (typeParameter in memberFunction.typeParameters) {\n            println(typeParameter.name)\n        }\n        println(\"----\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val foo = foo<Int>()\n    printTypeParameters(foo)\n}\n"
        },
        {
            "code": "\nfun main() {\n    var uint1 = 1u\n    var uint2 = 2u\n    var uint3 = 3u\n    val uintSet = mutableSetOf(uint1)\n    uintSet.add(uint2)\n    sequenceOf(1).forEach {\n        uintSet.add(uint3)\n        println(\"uintSet contains 1? ${uintSet.contains(1u)}\")\n        println(\"uintSet contains 2? ${uintSet.contains(2u)}\")\n        println(\"uintSet contains 3? ${uintSet.contains(3u)}\")\n    }\n}\n"
        },
        {
            "code": "\nuintSet.add(Integer.valueOf(uint3));\n"
        },
        {
            "code": "\nSystem.out.println(\"uintSet contains 3? \" + uintSet.contains(UInt.box-impl(3)));\n"
        },
        {
            "code": " \nuintSet.add(UInt.box-impl(uint2));\n"
        },
        {
            "code": "\n@RestController\nclass SampleController {\n    @GetMapping(\"/hello\")\n    fun hello(\n        @RequestParam(required = false) flag: Boolean = false\n    ): String =\n        if (flag) \"hello\" else \"goodbye\"\n}\n"
        },
        {
            "code": "\npackage test\n\nclass M(size: Int) {\n    val m = IntArray(size) { 0 }\n}\n\ninline operator fun M.get(a: Any, b: Any, ifn: () -> Int) =\n        m[ifn()]\n\ninline operator fun <reified T> M.set(a: T, b: Any, ifn: () -> Int, v: Int) {\n    if (b !is T) throw AssertionError()\n    m[ifn()] = v\n}\n\nfun main() {\n    val m = M(4)\n    m[\"a\", \"b\", { 1 }] += 10\n    println(m.m[1])\n}\n"
        },
        {
            "code": "\nval value: Boolean? = when (val type = peek()) {\n    JsonToken.BOOLEAN -> nextBoolean()\n    JsonToken.NULL -> nextNull().let { null }\n    else -> throw Error(\"Unexpected type $type\")\n}\n"
        },
        {
            "code": "\nval type = peek()\nval value: Boolean? = when (type) {\n    JsonToken.BOOLEAN -> nextBoolean()\n    JsonToken.NULL -> nextNull().let { null }\n    else -> throw Error(\"Unexpected type $type\")\n}\n"
        },
        {
            "code": "\nvar str: String? = null\n0.apply {\n    str = \"done\"\n}\nprintln(str!!.length)\n"
        },
        {
            "code": "\nval str: String\n0.apply {\n    str = \"done\"\n}\nprintln(str.length)\n"
        },
        {
            "code": "\ninterface A {\n    val foo: String\n}\n\nclass B : A {\n    override var foo: String = \"Fail\"\n        private set\n\n    fun setOK(other: B) {\n        other.foo = \"OK\"\n    }\n}\n\nfun box(): String {\n    val b = B()\n    b.setOK(b)\n    return b.foo\n}\n\nfun main(args: Array<String>) {\n    println(box())\n}\n"
        },
        {
            "code": "\nclass Test {\n    var string: String = \"\"\n        private set\n\n    fun update(i: Int) {\n        string = i.toString()\n    }\n}\n"
        },
        {
            "code": "\ntailrec fun findBreadcrumbPath(\n        appGroup: Int?,\n        groupsMap: Map<Int, Int>,\n        path: List<String> = emptyList()\n): List<String> {\n    if (appGroup != null) {\n        val parentGroup = groupsMap[appGroup]\n        parentGroup?.let {\n            return findBreadcrumbPath(parentGroup, groupsMap, path + it.toString())\n        }\n    }\n\n    return path\n}\n\nfun main() {\n    findBreadcrumbPath(0, emptyMap(), emptyList())\n}\n"
        },
        {
            "code": "\ninline class Ucn(private val i: UInt) {\n    fun toByteArray() = ByteArray(1) { i.toByte() }\n}\n"
        },
        {
            "code": "\nimport com.jayway.jsonpath.DocumentContext\ninline fun <reified T> DocumentContext.read(path: String): T =\n        runCatching { read(path, T::class.java) }.fold( {it}, { throw IllegalStateException(\"Mandatory field [$path] is not present\") } )\n"
        },
        {
            "code": "\npackage sandbox.kotlin\n\nimport org.jetbrains.kotlin.psi.KtFile\nimport org.jetbrains.kotlin.psi.KtScript\nimport org.jetbrains.kotlin.psi.psiUtil.getChildOfType\n\nclass TestBug {\n    fun test(psiFile: KtFile): KtScript? {\n        return psiFile.getChildOfType<KtScript>()\n    }\n}\n"
        },
        {
            "code": "\nimport java.io.IOException\n\nclass Foo {\n    @get:Throws(IOException::class)\n    @set:Throws(IOException::class)\n    var x: Int = 1\n}\n"
        },
        {
            "code": "\ntailrec fun bar(num: Int?): String {\n    num?.let{\n        return bar( 1 )\n    }\n    return \"\"\n}\n"
        },
        {
            "code": "\ninline fun Context.createAlertDialog(title: String? = null,\n                                     message: String?,\n                                     positiveButtonText: String? = null,\n                                     negativeButtonText: String? = null,\n                                     crossinline onPositiveButtonClick: (() -> Unit) = {},\n                                     crossinline onNegativeButtonClick: (() -> Unit) = {}): AlertDialog {\n    val builder = AlertDialog.Builder(this)\n    if (title != null) builder.setTitle(title)\n    builder.setMessage(message)\n    if (positiveButtonText != null) builder.setPositiveButton(positiveButtonText) { _, _ ->\n        onPositiveButtonClick.invoke()\n    }\n    if (negativeButtonText != null) builder.setNegativeButton(negativeButtonText) { _, _ ->\n        onNegativeButtonClick.invoke()\n    }\n    return builder.create()\n}\n"
        },
        {
            "code": "\ninline fun Context.showLocationServiceDialog(crossinline positiveOnClickListener: () -> Unit = {},\n                                             crossinline negativeOnClickListener: () -> Unit = {}) {\n    createAlertDialog(null, getString(R.string.General_Turn_On_Location_Dialog_Message),\n            getString(R.string.General_Ok), getString(R.string.General_Cancel), positiveOnClickListener, negativeOnClickListener)\n            .show()\n}\n"
        },
        {
            "code": "\ninline fun Activity.showLocationRequest(crossinline positiveOnClickListener: () -> Unit = {},\n                                        crossinline negativeOnClickListener: () -> Unit = {}) {\n    val googleApiClient = GoogleApiClient.Builder(this).addApi(LocationServices.API).build()\n    googleApiClient.connect()\n\n    val locationRequest = LocationRequest.create()\n    locationRequest.priority = LocationRequest.PRIORITY_LOW_POWER\n    locationRequest.interval = 60000\n    locationRequest.fastestInterval = (60000 / 2).toLong()\n\n    val builder = LocationSettingsRequest.Builder().addLocationRequest(locationRequest)\n    builder.setAlwaysShow(true)\n\n    val result = LocationServices.SettingsApi.checkLocationSettings(googleApiClient, builder.build())\n    result.setResultCallback { locationSettingsResult ->\n        val status = locationSettingsResult.status\n        when (status.statusCode) {\n            LocationSettingsStatusCodes.SUCCESS -> {\n            }\n            LocationSettingsStatusCodes.RESOLUTION_REQUIRED -> try {\n                // Show the dialog by calling startResolutionForResult(), and check the result\n                // in onActivityResult().\n                status.startResolutionForResult(this, Constants.REQUEST_CODES.CHECK_LOCATION_SETTINGS)\n            } catch (e: IntentSender.SendIntentException) {\n                showLocationServiceDialog(positiveOnClickListener, negativeOnClickListener)\n            }\n\n            LocationSettingsStatusCodes.SETTINGS_CHANGE_UNAVAILABLE ->\n                //Try old method, bring user to settings\n                showLocationServiceDialog(positiveOnClickListener, negativeOnClickListener)\n        }//Good, do nothing\n    }\n}\n"
        },
        {
            "code": "\n    override fun showTurnOnLocationDialog() {\n        activity?.showLocationRequest(positiveOnClickListener = {\n            activity?.startActivity(Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS))\n        })\n    }\n"
        },
        {
            "code": "\npackage test\n\nfun main(args: Array<String>) {\n    val x = A()\n    println(x.a)\n}\n\nclass A {\n    companion object {\n        private val test = 5\n    }\n\n    val a: Int\n\n    init {\n        a = test // (*) breakpoint\n    }\n}\n"
        },
        {
            "code": "\nimport java.lang.invoke.MethodHandles\n\nval handle = MethodHandles.arrayElementVarHandle(ByteArray::class.java)\nval array = ByteArray(10)\n\nhandle.setVolatile(array, 0, 42.toByte())\nprintln(handle.getVolatile(array, 0))\n"
        },
        {
            "code": "\noperator fun <R> KMutableProperty0<R>.setValue(host: Any?, property: KProperty<*>, value: R) = set(value)\noperator fun <R> KMutableProperty0<R>.getValue(host: Any?, property: KProperty<*>): R = get()\n\ninline class Foo(val i: Int)\n\nvar f = Foo(4)\n\nfun modify(ref: KMutableProperty0<Foo>) {\n\tvar a by ref\n\ta = Foo(1)\n}\n\nfun main(vararg args: String){\n\tmodify(::f)\n\tprintln(f.i)\n}\n"
        },
        {
            "code": "\nfun main(){\n    val contract = Contract()\n    contract.asContext()\n}\n\nclass Contract{\n    val factors : String? = null\n}\n\nfun Contract.asContext(){\n    doSomething{\n        var attached = factors?.let{ console.log(\"do not execute this!\") } ?: 3\n        (1..3).forEach{attached = 2} // *1\n    }\n}\n\nfun doSomething(code: ()->Unit){\n    code()\n}\n"
        },
        {
            "code": "\npackage route\n\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.launch\n\ninline fun stringValueArray(crossinline c: suspend () -> Array<String>): suspend () -> Array<String> {\n    val result: suspend () -> Array<String> = { c() + c() }\n    return result\n}\n\ninline fun booleanValueArray(crossinline c: suspend () -> BooleanArray): suspend () -> BooleanArray {\n    val result: suspend () -> BooleanArray = { c() + c() }\n    return result\n}\n\nfun main() {\n    GlobalScope.launch {\n        stringValueArray { arrayOf(\"\") }()\n        booleanValueArray { booleanArrayOf(false) }()\n    }\n}\n"
        },
        {
            "code": "\n  inline val Int.nonZero: Boolean get() = this != 0\n  "
        },
        {
            "code": "\n  fun main(args: Array<String>) {\n    println(1.nonZero)\n  }\n  "
        },
        {
            "code": "\ninline class TestInlineClass(val value: String)\n\nclass TestClassNoInlineClass(\n    val testArg1: Int,\n    val testInlineClass: String\n)\n\nclass TestClassWithInlineClass(\n    val testArg1: Int,\n    val testInlineClass: TestInlineClass\n)\n\nfun main(args: Array<String>) {\n    // prints \"testArg1, testInlineClass\"\n    println(TestClassNoInlineClass::class.java.constructors[0].parameters.map { it.name }.joinToString())\n    // prints \"arg0, arg1, arg2\"\n    println(TestClassWithInlineClass::class.java.constructors[0].parameters.map { it.name }.joinToString())\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val str = \"abcd\"\n    for (c:Char? in str) {\n        println(c)\n    }\n}\n"
        },
        {
            "code": "\ncompileKotlinJs {\n    kotlinOptions {\n        // ...\n        mainFun = 'pack1.pack2.main' // Or somehow including FILE name also.\n    }\n}\n"
        },
        {
            "code": "\nfun main() {\n    val x = sequence {\n        yield(1)\n    }\n}\n"
        },
        {
            "code": "\npackage com.example\n\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.channels.BroadcastChannel\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.selects.select\n\nclass Holder {\n    val channel = BroadcastChannel<Unit>(1)\n    var numbers = mutableListOf<Any>(1, 2, 3, 4)\n    val subscription = channel.openSubscription()\n\n    fun test() {\n        GlobalScope.launch {\n            select<Unit> {\n                subscription.onReceive { _ ->\n                    numbers.removeAll { it is Int }\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.KProperty\n\n// Error:(6, 9) Kotlin: Unsupported [suspend operator \"getValue\"]\nsuspend operator fun Any.getValue(\n        thisRef: Any?,\n        property: KProperty<*>\n): Any = TODO()\n"
        },
        {
            "code": "\nsuspend fun doSomething() = 1\n\nsuspend fun f() {\n    repeat(100) {\n        doSomething()\n    }\n}\n"
        },
        {
            "code": "\nsuspend fun f2() {\n    for (index in 0 until 100) {\n        doSomething()\n    }\n}\n"
        },
        {
            "code": "\nsuspend fun foo(a: Int) {}\nsuspend fun bar(b: Int) {}\nsuspend fun baz(c: Int) {}\n\nsuspend fun quix(a: Int, b: Int, c: Int): Int {\n    foo(a)\n    bar(b)\n    baz(c)\n    return 42\n}\n"
        },
        {
            "code": "\n@JsModule(\"moment\")\nexternal fun moment(inp: Any? = definedExternally,\n                    format: Any? = definedExternally,\n                    strict: Boolean? = definedExternally): moment.Moment\n\nexternal interface Moment {\n  fun format(format: String? = definedExternally /* null */): String\n}\n"
        },
        {
            "code": "\nval sTimestamp = timestamp.toString()\nval dTimestamp = js(\"parseInt(sTimestamp)\")\nspan { +moment(dTimestamp, strict = true).format(\"HH:mm:ss.SSS\") }\n"
        },
        {
            "code": "\ninline class Model(val id: String)\nval model = Model(\"abc\")\n"
        },
        {
            "code": "\nfun f(model: Model) {\n    Log.e(\"TAG\", \"f: ${model.id}\")\n}\n\nf(model)\n"
        },
        {
            "code": "\nval hashMap = hashMapOf<Model, Int>()\nhashMap[model] = 1\n"
        },
        {
            "code": "\nimport kotlin.properties.ReadOnlyProperty\nimport kotlin.reflect.KProperty\n\nclass Foo {\n    val a: Int = 0\n    val b by Delegate(0)\n}\n\ninline class Delegate(val ignored: Int): ReadOnlyProperty<Foo, Int> {\n    override fun getValue(thisRef: Foo, property: KProperty<*>): Int {\n        return thisRef.a\n    }\n}\n"
        },
        {
            "code": "\ninline class Foo(val value: Int)\n\nclass Bar {\n    val foo by Foo(0)\n    private operator fun Foo.getValue(bar: Bar, property: KProperty<*>) = 1\n}\n\nfun main(args: Array<String>) {\n    println(Bar().foo)\n}\n"
        },
        {
            "code": "\ninline class Z(val s: String)\n\nfun main(args: Array<String>) {\n    val a = arrayOf(Z(\"x\"))\n    println(a[0].javaClass)  // java.lang.ClassCastException: Z cannot be cast to java.lang.String\n}\n"
        },
        {
            "code": "\ninline class Z(val s: String)\n\nfun main(args: Array<String>) {\n    val a = arrayOf(Z(\"x\"))\n    a[0].javaClass\n}\n"
        },
        {
            "code": "\nclass Foo {\n    private val fld: String = \"O\"\n        get() = { field }() + \"K\"\n\n    val indirectFldGetter: () -> String = { fld }\n\n    fun simpleFldGetter(): String {\n        return fld\n    }\n}\n\nfun main(args: Array<String>) {\n    val v = Foo()\n    println(\"indirectFldGetter: ${v.indirectFldGetter()}\")\n    println(\"simpleFldGetter: ${v.simpleFldGetter()}\")\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>){\n    var listOf = mutableListOf(1, 2, 3)\n    (listOf[0])++\n}\n"
        },
        {
            "code": "\nclass MenuEvent (\n        @JvmField val type: MenuEventType,\n        @JvmField val data: Any\n)\n"
        },
        {
            "code": "\nenum class MenuEventType {\n    OPTIONS,\n    OVERLAY\n}\n"
        },
        {
            "code": "\ninline class Foo(val x: String)\n\nfun main(args: Array<String>) {\n    val prop: KProperty1<Foo, String> = Foo::x\n    prop.get(Foo(\"123\"))\n}\n"
        },
        {
            "code": "\nfun main() {\n    println(Z::f)\n}\n\ninline class Z(val t2: Int) {\n    fun f(x: Int) {\n        println(x)\n    }\n}\n"
        },
        {
            "code": "\ninline class IcInt(val i: Int) {\n    fun simple() {}\n}\n\nfun test(i: IcInt) {\n    foo(i::simple) // CCE\n}\n\ninline fun foo(init: () -> Unit){\n    init()\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.async\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.runBlocking\n\nfun main() {\n    val face: Face = FaceImpl()\n    face.doSomething()\n}\n\ninterface Face {\n    fun doSomething()\n}\n\n@JvmSuppressWildcards\nclass FaceImpl : Face {\n    override fun doSomething() {\n        println(\"Doing something\")\n\n        runBlocking {\n            delay(200)\n            async {\n                println(1 + 1)\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.resume\nimport kotlin.coroutines.suspendCoroutine\nimport kotlin.reflect.full.memberProperties\n\nabstract class AbstractTest {\n    abstract val x: suspend (Unit) -> Unit\n}\n\nclass Test: AbstractTest() {\n    override val x = ::suspendX\n    private suspend fun suspendX(unit: Unit): Unit = suspendCoroutine {\n        it.resume(unit)\n    }\n}\n\nfun main(args: Array<String>) {\n    val test = Test()\n    test::class.memberProperties.forEach {\n        println(it.getter.call(test))\n    }\n}\n"
        },
        {
            "code": "\ninline class Test(val a: Double)\n\nclass Demo {\n    val a by lazy { Test(0.0) }\n}\n\nfun main(args: Array<String>) {\n    println(Demo().a)\n}\n"
        },
        {
            "code": "\n// Kotlin\ninline class Foo(val x: Int) \n\nfun kotlinFun(f: Foo) {}\n\n// Java:\n\nstatic void test() {\n    kotlinFun(42); // constructor or initialization block wasn't called\n}\n"
        },
        {
            "code": "\ninline class Positive(val x: Int) {\n    init { require(x > 0) } \n}\n\nfun foo(p: Positive) { } // mangled, not visible from Java\n\n@SafeInlitialization\nfun bar(p: Positive) { } // not mangled, visible from Java \n\nfun baz(p: List<Positive>) { } // not mangled, Positive is used as a wrapper here\n\nfun test() {\n    foo(Positive(42)) // OK\n    bar(Positive(13)) // OK\n}\n"
        },
        {
            "code": "\nfun foo(u: Int) {}\nfun foo(u: UInt) {} // No error, because we already mangled name of this function\n"
        },
        {
            "code": "\nsealed class S {\n    companion object {\n        val obj = Obj\n    }\n}\n\nobject Obj : S()\n"
        },
        {
            "code": "\nfun main() {\n    Obj\n    println(S.obj) // prints null\n}\n"
        },
        {
            "code": "\nfun main() {\n    println(S.obj) // prints object as expected\n}\n"
        },
        {
            "code": "\ndata class RGBA(val rgba: Int)\n\ninline class RgbaArray(val array: IntArray) {\n   \tval size: Int get() = array.size\n\tfun fill(value: RGBA, start: Int = 0, end: Int = this.size): Unit = array.fill(value.rgba, start, end)\n}\n\nfun main(args: Array<String>) {\n    RgbaArray(IntArray(16)).fill(RGBA(0))\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class Z(val x: Int) {\n    inner class Inner(val y: Int) {\n        val xx = x\n    }\n}\n\nfun main(args: Array<String>) {\n    println(Z(42).Inner(100).xx)\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class Z(val x: Int) {\n    inner class Inner(val z: Z)\n}\n\nfun main(args: Array<String>) {\n    println(Z(42).Inner(Z(100)).z)\n}\n"
        },
        {
            "code": "\nfun String.testMe(someOtherValue: String) {\n    data class TestMe(\n        val doesThisWork: String = this,\n        val somethingElse: String = someOtherValue\n    )\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val i = 0\n\n    class D(val j: Int = i)\n\n    print(D())\n}\n"
        },
        {
            "code": "\nfun foo() {\n    val i = 1\n    class Test(int: Int = i)\n}\n"
        },
        {
            "code": "\nfun testMethod() {\n  val f: () -> Int = {3}\n\n  class FunClass(\n      val x: Int = f()\n  )\n}\n"
        },
        {
            "code": "\nfun testMethod() {\n  val f: () -> Int = {3}\n\n  class FunClass(\n      val x: Int = 3\n  )\n}\n"
        },
        {
            "code": "\ninline class EthereumABI(val methodList: List<EthereumFunction>) {\n\n    constructor(abiString: String, moshi: Moshi = createMoshi()) : this(parse(abiString, moshi))\n\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class R(private val r: Int) {\n    companion object {\n        @JvmStatic\n        fun foo() {\n            println(\"R.Companion::foo\")\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    J.test();\n}\n"
        },
        {
            "code": "\n@GetMapping(\"/history\")\n    fun decisionPointHistory(@RequestParam(name = \"name\") name: String,\n                             pageable: Pageable,\n                             @RequestParam(name = \"from\", required = false) fromRevision: Int? = null,\n                             @RequestParam(name = \"to\", required = false) toRevision: Int? = null): Page<HistoryDTO> \n"
        },
        {
            "code": "\ninline class A(val i: Int)\ninline class B(val a: A)\nval b: B? = null\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(\"Using for-in-array:\")\n    var xs = intArrayOf(1, 2, 3)\n    for (x in xs) {\n        println(x)\n        xs = intArrayOf()\n    }\n\n    println(\"Using array iterator:\")\n    xs = intArrayOf(1, 2, 3)\n    val xsi = xs.iterator()\n    while (xsi.hasNext()) {\n        val x = xsi.nextInt()\n        println(x)\n        xs = intArrayOf()\n    }\n}\n"
        },
        {
            "code": "\nclass C() {\n    var arr = intArrayOf(1, 2, 3)\n\n    fun updateArr() {\n        arr = intArrayOf()\n    }\n}\n\nfun main(args: Array<String>) {\n    println(\"C.arr:\")\n    val c = C()\n    for (x in c.arr) {\n        println(x)\n        c.updateArr()\n    }\n}\n"
        },
        {
            "code": "\n    var xs = intArrayOf(1, 2, 3)\n    for (x in xs) {\n        println(x)\n        xs = intArrayOf()\n    }\n"
        },
        {
            "code": "\n1\n2\n3\n"
        },
        {
            "code": "\ninline val Boolean.byte: Byte get() = if (this) 1.toByte() else 0.toByte()\n"
        },
        {
            "code": "\nfun x() {\n   true.byte\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class R(private val r: Int) {\n    fun test() = { println(\"lambda\") }()\n}\n\nfun main(args: Array<String>) {\n    R(42).test()\n}\n"
        },
        {
            "code": "\ninline fun <reified T> trickMe(): String? {\n    return T::class.simpleName\n}\n\nfun main() {\n    println(Int::class.simpleName) //1\n    println(trickMe<Int>()) //2\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class S(val string: String)\n\nfun testMangled(s: S) {\n    class Local\n\n    val localKClass = Local::class\n    val localJClass = localKClass.java\n    println(localKClass.simpleName)\n    println(localJClass.simpleName)\n}\n\nfun testNonMangled() {\n    class Local\n\n    val localKClass = Local::class\n    val localJClass = localKClass.java\n    println(localKClass.simpleName)\n    println(localJClass.simpleName)\n}\n\nfun main(args: Array<String>) {\n    testMangled(S(\"\"))\n    testNonMangled()\n}\n"
        },
        {
            "code": "\ninternal class Internal\n\nfun a() {\n    Internal()\n}\n"
        },
        {
            "code": "\ninternal class Internal(val n: Int)\n\nfun main(args: Array<String>) {\n    a()\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class R(private val r: Int) {\n    fun test() = object {}\n}\n\nfun main(args: Array<String>) {\n    println(R(42).test())\n}\n"
        },
        {
            "code": "\ninline class B(val l: Long)\n\ninline class A(val b: B) {\n    override fun toString(): String {\n        return buildString {\n            append(\"asdsa\")\n            append(b.l + 12)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    println(A(B(12)).toString())\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class Z(val z: Int)\n\nfun test(z: Any = Z(42)) = (z as Z).z\n\nfun main(args: Array<String>) {\n    println(test())\n}\n"
        },
        {
            "code": "\n/**\n *\n */\nclass FooBarResource {\n\n    val currentUser: ResponseEntity<Boolean>\n        get() {\n            val zx = loggedInUser.orElseThrow { IllegalArgumentException(\"XX\") }\n            return ResponseEntity.ok(zx)\n        }\n\n    private val loggedInUser: Optional<Boolean>\n        get() = Optional.of(java.lang.Boolean.TRUE)\n}\n"
        },
        {
            "code": "\npublic inline class NullableInt constructor(private val holder: Any?) {\n    val intValue: Int get() = holder as Int\n}\n\nval box = arrayListOf(NullableInt(0))\nprintln(box[0].intValue)\n"
        },
        {
            "code": "\npackage test\n\ninline class Z(val x: Int)\n\nfun <T> id(x: T) = x\n\nfun main(args: Array<String>) {\n    println(Z(42) == id(Z(42)))\n}\n"
        },
        {
            "code": "\nval map: Map<String, Any?> = mapOf(\"anInt\" to null)\n\ndata class MyClass(val map: Map<String, Any?>) {\n    val anInt: Int by map\n}\n\nprintln(MyClass(map)) // Does not fail yet\nprintln(MyClass(map).anInt) // Fails\n"
        },
        {
            "code": "\nval map: Map<String, Any?> = mapOf(\"aString\" to null)\n\ndata class MyClass(val map: Map<String, Any?>) {\n    val aString: String by map\n}\n\nprintln(MyClass(map))\nprintln(MyClass(map).aString == \"null\") // false\nprintln(MyClass(map).aString == null) // true -> Even though the compiler warns, that it is always false (see below)\nprintln(MyClass(map).aString) //null\n"
        },
        {
            "code": "\nfun f1(): List<Result<Int>> {\n    return listOf(\n        runCatching {\n            println(\"1\")\n            10\n        }\n    )\n}\n\nfun main() {\n    val t0 = f1()\n    val t1 = f1()[0]\n\n    val t2 = runCatching {\n        println(\"1\")\n        10\n    }\n\n    println(t0) // [Success(10)]\n    println(t1) // Success(Success(10))\n    println(t2) // Success(10)\n}\n"
        },
        {
            "code": "\ninline class A(val t: Int)\nsuspend fun produce1() = A(10)\nfun produce2() = A(10)\nsuspend fun main() {\n    println(produce1() == produce1()) // ClassCastException\n    println(produce1() == produce2()) // ClassCastException\n    println(produce1() == A(10)) // ClassCastException\n    println(produce2() == produce2()) // OK\n    println(produce2() == A(10)) // OK\n}\n"
        },
        {
            "code": "\nval u = 42u\nval s = \"$u\" // boxing, but method $Erased.box can be called\n"
        },
        {
            "code": "\ninline class Ucn(private val i: UInt)\n\nclass PPInput(private val s: ByteArray) {\n    fun peek(n: UInt = 0u): Ucn? = if (n >= s.size.toUInt()) null else Ucn(s[n.toInt()].toUInt())\n}\n"
        },
        {
            "code": "\ninline class Ucn(private val i: UInt)\n\ninterface Input<T> {\n    fun peek(n: UInt = 0u): T\n}\n\nclass RawInput(private val s: String) : Input<Ucn> {\n    override fun peek(n: UInt): Ucn = if (n >= s.length.toUInt()) Ucn(0u) else Ucn(s[n.toInt()].toInt().toUInt())\n}\n\nfun main(args: Array<String>) {\n    println(RawInput(\"test\").peek())\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class R(private val r: Int) {\n    fun test() = run { println(\"lambda\") }\n}\n\nfun main(args: Array<String>) {\n    R(42).test()\n}\n"
        },
        {
            "code": "\ninline class Foo(val a: String = \"\")\n"
        },
        {
            "code": "\ninline val C.v: Int get() = 1\n\nclass C {\n    fun f(block: suspend C.() -> Unit): Unit = TODO()\n}\n\nfun f(c: C) {\n    c.f {\n        v.toString()\n        kotlinx.coroutines.yield() // fails when appending this line using completion\n    }\n}\n"
        },
        {
            "code": "\nclass Foo : CoroutineScope by GlobalScope {\n\n    fun foo() = synchronized(Any()) {\n        launch {\n            delay(1)\n        }\n    }\n\n}\n"
        },
        {
            "code": "\nclass Foo : CoroutineScope by GlobalScope {\n\n    suspend fun foo() = synchronized(Any()) {\n        delay(1)\n    }\n\n}\n"
        },
        {
            "code": "\n   val result = ArrayList<BuildingRoomSourceRole>()\n   for (possiblyOutdated in props.locationProp.get()) {\n            if (possiblyOutdated.source == RoomSource.SET_MANUALLY) {\n                when (possiblyOutdated.role) {\n                    Role.PRIMARY -> {\n                        val index = result.indexOfFirst { it.building == possiblyOutdated.building }\n                        if (index != -1) {\n                            result[index] = possiblyOutdated\n                        }\n                    }\n                    Role.EXTRA -> {\n                        result += possiblyOutdated\n                    }\n                }\n            }\n        }\n"
        },
        {
            "code": "\nvar mainList = listOf(3, 4, 5)\nvar secondaryList = listOf(3, 4, 5, 7, 8)\nmainList.forEach { listElement ->\n  val elementInSecondary = secondaryList.firstOrNull {\n    it == listElement\n  }\n  when (3) {\n    3 -> {}\n    4 ->{}\n    else->{}\n  }\n}\n"
        },
        {
            "code": "\nfun main(args:Array<String>) {\n    val relation: MutableMap<Long, String> = mutableMapOf()\n    relation[1L] += \"anyvalue\"\n}\n"
        },
        {
            "code": "\nloggerTextArea?.text += message + \"\\n\"\n"
        },
        {
            "code": "\nobject Test\n{\n    //var tester : Tester? = Tester()\n    var tester2 : Tester2? = Tester2()\n    fun logText(message : String)\n    {\n        //tester?.field += message\n        tester2?.field += message\n    }\n\n    class Tester2\n    {\n        var field = \"\";\n    }\n}\n"
        },
        {
            "code": "\npublic class PublicClass {\n    private companion object\n}\n"
        },
        {
            "code": "\n// !LANGUAGE: +InlineClasses\n// IGNORE_BACKEND: JVM_IR\n// WITH_RUNTIME\n\ninline class Ucn(private val i: UInt)\n\ninterface Input<T> {\n    fun foo(n: Int = 0): T\n}\n\nfun Char.toUInt() = toInt().toUInt()\n\nclass Kx(val x: UInt) : Input<Ucn> {\n    override fun foo(n: Int): Ucn =\n        if (n < 0) Ucn(0u) else Ucn(x)\n}\n\nfun box(): String {\n    val p = Kx(42u).foo()\n    if (p.toString() != \"Ucn(i=42)\") throw AssertionError()\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "\npackage test.p1\n\nabstract class A {\n    protected val hello: String = \"hello\"\n\n    protected inline fun <reified T> helloType(): () -> Unit = {\n        println(\"$hello ${T::class.java}\")\n    }\n}\n"
        },
        {
            "code": "\npackage test.p2\n\nimport test.p1.A\n\nclass B: A() {\n    val result = helloType<String>()\n}\n\nfun main(args: Array<String>) {\n    B().result()\n}\n"
        },
        {
            "code": "\npackage test\n\ninterface IFoo {\n    fun foo(): String\n}\n\ninline class InlineFooImpl(val s: String): IFoo {\n    override fun foo(): String = s\n}\n\nclass Test : IFoo by InlineFooImpl(\"abc\")\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.launch\n\n\nclass Foo {\n\n    fun myLaunch() {\n        GlobalScope.launch {\n        }\n    }\n\n}\n"
        },
        {
            "code": "\ninterface IFace {\n    fun foo() = 0\n}\n\ninline class InlineBar(val x: Int) : IFace\n\nfun f(ib: InlineBar) = ib.foo()\n"
        },
        {
            "code": "\ninterface I {\n    val overrideMe: Double\n    fun someFun(that: I) = this.overrideMe + that.overrideMe\n}\n\ninline class C(override val overrideMe: Double) : I\n\nfun main(args: Array<String>) {\n    val x = C(1.0)\n    val y = C(2.0)\n    val z = x.someFun(y)\n}\n"
        },
        {
            "code": "\ninterface A {\n    fun foo()\n}\n\nclass B : A {\n    override fun foo() {\n    }\n}\n\nfun test1() {\n    val b = B()\n    (b as A).foo() // Null-check is absent\n}\n\nfun test2() {\n    val b = getB()\n    (b as A).foo() // Null-check is generated\n}\n\nfun test3() {\n    val b = getB()\n    b.foo() // Null-check is absent\n}\n\nfun getB(): B = B()\n"
        },
        {
            "code": "\nfun testPublic(s: String) = s.substring(1)\nprivate fun testPrivate(s: String) = s.substring(1)\n"
        },
        {
            "code": "\n// in stdlib\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = (this as java.lang.String).substring(startIndex)\n"
        },
        {
            "code": "\nfun wrongBreakLabel() {\n    var n = 10\n    while (n < 10) {\n        when (n) {\n            4 -> {\n                n++\n            }\n            5 -> {\n                println(5)\n                n++\n            }\n            else -> {\n                n++\n                listOf(1).all { true }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\ninline class S(val x: String) {\n    private fun foo() = x\n\n    fun lambda() = { foo() }\n}\n\nfun main(args: Array<String>) {\n    println(S(\"OK\").lambda()())\n}\n"
        },
        {
            "code": "\ninline class Outer(val x: Int) {\n    inner class Inner {\n        fun foo() = x\n    }\n}\n"
        },
        {
            "code": "\ninline class S(val x: String) {\n    private fun foo() = x\n\n    companion object {\n        fun bar(s: S) = s.foo()\n    }\n}\n\nfun main(args: Array<String>) {\n    println(S.bar(S(\"OK\")))\n}\n"
        },
        {
            "code": "\nsuspend fun f(i: Int): Long {\n    return if (i > 0) 1L else f_2()\n    // if (i > 0) return 1L   // this version doesn't lead to state machine generation\n    // return f_2()\n}\n\nprivate suspend fun f_2(): Long = TODO()\n"
        },
        {
            "code": "\nclass CharacterLiteral(private val prefix: NamelessString, private val s: NamelessString) {\n    override fun toString(): String = \"$prefix'$s'\"\n}\n\ninline class NamelessString(val b: ByteArray) {\n    override fun toString(): String = String(b)\n}\n\nfun main(args: Array<String>) {\n    println(CharacterLiteral(NamelessString(\"u\".toByteArray()), NamelessString(\"test\".toByteArray())))\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(\"with parameters\")\n}\n"
        },
        {
            "code": "\nfun main() {\n    println(\"without parameters\")\n}\n"
        },
        {
            "code": "\nobject MainObject {\n    @JvmStatic fun main(args: Array<String>) {\n        println(\"within object with parameters\")\n    }\n}\n"
        },
        {
            "code": "\nobject MainObjectBare {\n    @JvmStatic fun main() {\n        println(\"within object without parameters\")\n    }\n}\n"
        },
        {
            "code": "\nclass ExampleUnitTest {\n    @Test\n    fun testNormal() {\n        runBlocking {\n            launch(Dispatchers.IO) {\n                val channel = produce {\n                    send(1)\n                    send(2)\n                    send(3)\n                }\n\n                channel.consumeEach {\n                    println(it)\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testExtension() {\n        runBlocking {\n            launch(Dispatchers.IO) {\n                val channel = produceExtension()\n\n                channel.consumeEach {\n                    println(it)\n                }\n            }\n        }\n    }\n\n    @Test\n    fun testScope() {\n        runBlocking {\n            launch(Dispatchers.IO) {\n                val channel = produceCoroutineScope()\n\n                channel.consumeEach {\n                    println(it)\n                }\n            }\n        }\n    }\n\n    private suspend fun produceCoroutineScope(): ReceiveChannel<Int> = coroutineScope {\n        produce {\n            send(1)\n            send(2)\n            send(3)\n        }\n    }\n\n    private fun CoroutineScope.produceExtension(): ReceiveChannel<Int> = produce {\n        send(1)\n        send(2)\n        send(3)\n    }\n}\n"
        },
        {
            "code": "\ninline class A(val i: Int) {\n    fun f(): I = object : I {}\n}\ninterface I\n"
        },
        {
            "code": "\ninline class B constructor(val t: String = \"B\") {\n   // this gets an error \"Inline class primary constructor must have only final read-only (val) property parameter\"\n}\n"
        },
        {
            "code": "\ninline class A constructor(val t: String) {\n    constructor(): this(\"A\")\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.CommonPool\nimport kotlinx.coroutines.runBlocking\nimport kotlinx.coroutines.withContext\n\nsuspend inline fun useWith(crossinline block: suspend () -> Unit) {\n    withContext(CommonPool) {\n        block()\n    }\n}\n\nclass SuspendCrash {\n    fun crash() = runBlocking {\n        useWith {\n            withContext(CommonPool) {}\n        }\n    }\n}\n"
        },
        {
            "code": "\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport kotlinx.coroutines.experimental.CoroutineScope\nimport kotlinx.coroutines.experimental.CoroutineStart\nimport kotlinx.coroutines.experimental.Job\nimport kotlinx.coroutines.experimental.android.UI\nimport kotlinx.coroutines.experimental.delay\nimport kotlinx.coroutines.experimental.launch\nimport kotlinx.coroutines.experimental.yield\nimport timber.log.Timber\n\nclass InliningBugReceiverWrapper : BroadcastReceiver() {\n\n    class InliningBugReceiver : BroadcastReceiver() {\n        override fun onReceive(context: Context?, intent: Intent?) {\n            if (intent?.action == Intent.ACTION_BOOT_COMPLETED) goAsyncAndLaunch {\n                try {\n                    delay(0.also { yield() })\n                } catch (e: Exception) {\n                    Timber.e(e)\n                }\n            }\n        }\n    }\n\n    override fun onReceive(context: Context?, intent: Intent?) {\n        TODO()\n    }\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninline fun BroadcastReceiver.goAsyncAndLaunch(crossinline block: suspend () -> Unit) {\n    val pendingResult = goAsync()\n    launchInUi {\n        try {\n            block()\n        } finally {\n            pendingResult.finish()\n        }\n    }\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninline fun launchInUi(\n        parent: Job? = null,\n        noinline block: suspend CoroutineScope.() -> Unit\n): Job {\n    return launch(UI, start = CoroutineStart.UNDISPATCHED, parent = parent, block = block)\n}\n"
        },
        {
            "code": "\nval result: List<Int> = (1..100).filter { it % 2 == 0 }.filter { it % 3 == 0 }.filter { it % 5 == 0 }\nval result: List<Int> = (1..100).asSequence().filter { it % 2 == 0 }.filter { it % 3 == 0 }.filter { it % 5 == 0 }.toList()\n"
        },
        {
            "code": "\nimport kotlin.reflect.KProperty0\nimport kotlin.reflect.KProperty\n\nclass ByteDelegate private constructor(\n    private val position: Int,\n    private val uIntValue: KProperty0<UInt>\n) {\n    operator fun getValue(any: Any?, property: KProperty<*>): UByte {\n        @Suppress(\"CAST_NEVER_SUCCEEDS\")\n        return ((uIntValue.get() as Int).toUInt() shr (position * 8) and 0xffu).toUByte()\n    }\n    companion object {\n        fun byteDelegate(\n            position: Int,\n            uIntValue: KProperty0<UInt>\n        ) = ByteDelegate(\n            position,\n            uIntValue\n        )\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\n\nclass ByteDelegateTest {\n\n    private val uInt = 0xA1B2C3u\n    private val b1: UByte by byteDelegate(0, this::uInt)\n\n    @Test\n    fun `Passing`() {\n        val expected: UByte = 0xC3u\n        val actual = b1\n        assertEquals(expected, actual)\n    }\n\n    @Test\n    fun `Failing`() {\n        val expected: UByte = 0xC3u\n        assertEquals(expected, b1)\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.KProperty\n\ninline class Foo(val arg: Int) {\n    var bar: String by Delegate()\n}\n\nclass Delegate {\n    operator fun getValue(foo: Foo, property: KProperty<*>) = \"foo\"\n    operator fun setValue(foo: Foo, property: KProperty<*>, s: String) {}\n}\n"
        },
        {
            "code": "\npackage test\n\ninline fun List<String>.foo() = \"list of strings\"\n"
        },
        {
            "code": "\npackage test\n\ninline fun List<Int>.foo() = \"list of ints\"\n"
        },
        {
            "code": "\npackage other\n\nimport test.foo\n\nfun main(args: Array<String>) {\n    println(listOf(\"a\", \"b\", \"c\").foo())        // (1)\n    println(listOf(1, 2, 3).foo())              // (2)\n}\n"
        },
        {
            "code": "\nlist of strings\nlist of strings\n"
        },
        {
            "code": "\nclass Test {\n    private companion object {\n        val i = 1\n    }\n}\n\nfun main(args: Array<String>) {\n    println(Test::class)\n}\n"
        },
        {
            "code": "\ncompileKotlin {\n    kotlinOptions {\n        jvmTarget = \"1.8\"\n        languageVersion = \"1.3\"\n    }\n}\n"
        },
        {
            "code": "\nclass A {\n    open inner class AB\n}\n\nfun A.foo() {\n    class FooC : A.AB()\n}\n\nfun main(args: Array<String>) {\n    A().foo()\n}\n"
        },
        {
            "code": "\nimport java.util.*\n\nclass A() {\n    fun foo(a: Int, b: Int): Boolean = a == b\n    \n    private fun foo() {\n        open class B(val b: Int) {\n            fun bar(other: B) = foo(other.b, b)\n        }\n        \n        class C(b: Int, val c: Int) : B(b)\n    }\n}\n"
        },
        {
            "code": "\nclass Outer {\n    open inner class Inner\n\n    fun test() {\n        open class Local1 : Inner()\n        class Local2 : Local1()\n    }\n}\n"
        },
        {
            "code": "\nclass Foo {\n    fun run() {\n        Nested().foo()\n    }\n\n    private companion object {\n        val x: Int = 42\n    }\n\n    private class Nested {\n        fun foo() {\n            println(x)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    Foo().run() // Compiles fine in 1.2, fails with IAE in 1.3\n}\n"
        },
        {
            "code": "\ninterface A {\n    \n    fun foo(): Unit {\n        Runnable{\n            println(\"called $x\")\n        }.run()\n    }\n    \n    private companion object {\n        val x = 45\n    }\n}\n\nclass B: A\n\nfun main(args: Array<String>) {\n    B().foo()\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class Z(val x: Int)\n\nfun <T : Z> foo(x: T) {}\n"
        },
        {
            "code": "\nclass SampleNotWorking {\n    private val builder = StringBuilder()\n    fun addMessage() {\n        builder.append(\"hello\")\n    }\n\n    override fun toString(): String {\n        return builder.toString()\n    }\n}\n\nclass SampleWorking {\n    private val builder = StringBuilder()\n    fun addMessage() {\n        builder.append(\"hello\")\n    }\n\n    override fun toString() = builder.toString()\n}\n"
        },
        {
            "code": "\n     Intrinsics.checkExpressionValueIsNotNull(var10000, \"builder.toString()\");\n "
        },
        {
            "code": "\nfun computeGrade(score: Int): Grade =\n        when (score) {\n            in 90..100 -> Grade.A\n            in 75 until 90 -> Grade.B\n            in 60 until 75 -> Grade.C\n            in 0 until 60 -> Grade.D\n            else -> throw IllegalStateException(\"Wrong score value!\")\n        }\n\nenum class Grade { A, B, C, D }\n"
        },
        {
            "code": "\ninline val IntArray.foo inline get() = indices\n\nfun main(args: Array<String>) {\n    val arr = IntArray(5)\n\n    for (i in arr.foo) {\n        println(i)\n    }\n}\n"
        },
        {
            "code": "\nenum class Order {\n    FIRST, SECOND, THIRD\n}\n\nsuspend fun f1(): Order {\n    coroutineScope {\n        println(\"1\")\n    }\n\n    return Order.THIRD\n}\n\nfun main() {\n    runBlocking {\n        val t = when (val x = f1()) {\n            Order.FIRST -> 1\n            Order.SECOND -> 2\n            Order.THIRD -> 3\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun main() {\n    runBlocking {\n        val t = when (f1()) {\n            Order.FIRST -> 1\n            Order.SECOND -> 2\n            Order.THIRD -> 3\n        }\n    }\n}\n"
        },
        {
            "code": "\ninline fun on(body: () -> Unit) {\n    body()\n}\n\nclass A {\n\n    fun baz() {\n        foo()\n    }\n\n    private companion object {\n        private fun foo() {\n            on {\n                println(this::class.java)\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    A().baz()\n}\n"
        },
        {
            "code": "\ninline class Z(val x: Int) {\n    suspend fun f(x: Int) {\n        coroutineScope {\n            println(x)\n        }\n    }\n}\n"
        },
        {
            "code": "\ninline class Z(val x: Int) {\n    fun f(x: Int) {\n        val f = {\n            println(x)\n        }\n    }\n}\n"
        },
        {
            "code": "\ninline class Z(val x: Int) {\n    fun f(x: Int) {\n        println(x)\n    }\n}\n"
        },
        {
            "code": "\npackage com.github.vmironov\n\nfun main(args: Array<String>) {\n  CrashMe().crashMe()\n}\n\nclass CrashMe {\n  fun crashMe() {\n    \"crashMe\".let {\n      object : Any() {\n        override fun toString() = this@CrashMe.toString()\n      }\n    }.toString()\n  }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n  args?.let {\n    object {\n      val crash = args.toString()\n    }\n  }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val a = \"\"\n    val foo = run {\n        object {\n            val b = a\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun createResolver(project: Project, sourceFile: VirtualFile): Lazy<SourceFileResolver?>? {\n  return lazy(LazyThreadSafetyMode.NONE) {\n    FileUrlMapper.EP_NAME.extensions.computeOrNull {\n      it.createSourceResolver(sourceFile, project)?.let {\n        object : SourceFileResolver {\n          override fun resolve(sourceFile: VirtualFile?, map: ObjectIntHashMap<Url>) = it.resolve(map, project)\n        }\n      }\n    }\n  }\n}\n"
        },
        {
            "code": "\nfun createResolver(project: Project, sourceFile: VirtualFile): Lazy<SourceFileResolver?>? {\n  return lazy(LazyThreadSafetyMode.NONE) {\n    @Suppress(\"LoopToCallChain\")\n    for (fileUrlMapper in FileUrlMapper.EP_NAME.extensions) {\n      val sourceResolver = fileUrlMapper.createSourceResolver(sourceFile, project)\n      if (sourceResolver != null) {\n        object : SourceFileResolver {\n          override fun resolve(sourceFile: VirtualFile?, map: ObjectIntHashMap<Url>) = sourceResolver.resolve(map, project)\n        }\n      }\n    }\n    null\n  }\n}\n"
        },
        {
            "code": "\n    @Test\n    fun testAsyncInitializerFailure() {\n        val resources = mutableListOf<ExpensiveResource>()\n\n        assertThatThrownBy {\n            runBlocking {\n                krool(5, closeOnError = { it.close() }) {\n                    val resource = ExpensiveResource(\"ExpensiveResource $it\")\n                    resource.initialize(it % 2 == 0)\n                    spyk(resource).also { spiedResource -> resources += spiedResource }\n                }\n            }\n        }.hasMessage(\"Resource ExpensiveResource 2 failed to initialize\")\n\n        //TODO One of the resources is null sometimes\n        resources.forEach { println(it) }\n\n        resources.forEach {\n            verify(exactly = 1) {\n                it.close()\n            }\n        }\n\n        assertThat(resources).hasSize(3)\n    }\n"
        },
        {
            "code": "\n                    resource.initialize(it % 2 == 0)\n                    spyk(resource).also { spiedResource -> resources += spiedResource }\n"
        },
        {
            "code": "\npackage test.internal\n\nimport java.util.*\n\nclass A() {\n    val list = ArrayList<Class<*>>()\n\n    inner class B() {\n        inline fun <reified T : Any> add() = list.add(T::class.java)\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\nimport test.internal.A\n\nfun main(args: Array<String>) {\n    A().B().add<String>()\n}\n"
        },
        {
            "code": "\n    inner class B() {\n        val list: MutableList<Class<*>> get() = this@A.list // This prevents the crash\n\n        inline fun <reified T : Any> add() = list.add(T::class.java)\n    }\n"
        },
        {
            "code": "\npackage test\n\ninline class R(private val r: Int) {\n    fun test() = { ok() }()\n\n    fun ok() = println(\"OK\")\n}\n\nfun main(args: Array<String>) {\n    R(0).test()\n}\n"
        },
        {
            "code": "\nval b: UByte = 0xFFu\nval f = \"$f\" // just -1, but should be 255\n"
        },
        {
            "code": "\ninline class R(private val r: Int) {\n    fun test() = pf()\n\n    companion object {\n        private fun pf() = \"OK\"\n    }\n}\n\nfun main(args: Array<String>) {\n    println(R(0).test())\n}\n"
        },
        {
            "code": "\ndata class Something (val collection: List<@NotBlank String> = listOf())\n"
        },
        {
            "code": "\nclass Names {\n\t@NotEmpty var names: List<@Valid @NotNull Name>? = null\n}\n"
        },
        {
            "code": "\nclass Item(\n        id: Long? = null,\n        val name: @Special String = \"\")\n"
        },
        {
            "code": "\n// !LANGUAGE: +InlineClasses\n// IGNORE_BACKEND: JVM_IR\n\ninterface IFoo<T : IFoo<T>> {\n    fun T.foo(): String = bar()\n    fun bar(): String\n}\n\ninline class Z(val x: Int) : IFoo<Z> {\n    override fun bar(): String = \"OK\"\n}\n\ninline class L(val x: Long) : IFoo<L> {\n    override fun bar(): String = \"OK\"\n}\n\ninline class S(val x: String) : IFoo<S> {\n    override fun bar(): String = x\n}\n\nfun Z.testZ() {\n    if (Z(42).foo() != \"OK\") throw AssertionError()\n}\n\nfun L.testL() {\n    if (L(4L).foo() != \"OK\") throw AssertionError()\n}\n\nfun S.testS() {\n    if (S(\"OK\").foo() != \"OK\") throw AssertionError()\n}\n\nfun box(): String {\n    Z(42).testZ()\n    L(4L).testL()\n    S(\"\").testS()\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "\ninterface IFace {\n    fun foo() = 0\n}\n\ninline class InlineClass(val x: String) : IFace\n\nfun main(args: Array<String>) {\n    InlineClass(\"foo\").foo()\n}\n\n"
        },
        {
            "code": "\nfun acceptSuspend(block: suspend () -> Unit) {}\nfun callSuspend() { acceptSuspend {} }\n"
        },
        {
            "code": "\ninline class SnekDirection(private val direction: Int) {\n    companion object {\n        val Up = SnekDirection(0)\n    }\n}\n\nfun testUnbox() : SnekDirection {\n    val list = arrayListOf(SnekDirection.Up)\n    return list[0]\n}\n"
        },
        {
            "code": "\ninline class Foo<T : Foo<T>>(val x: T) \n"
        },
        {
            "code": "\nclass A {\n    private companion object {\n        const val x = 1\n        @JvmField\n        val q = Any()\n    }\n    \n    fun bar() {\n        println(x.toString() + q)\n    }\n}\n"
        },
        {
            "code": "\nfun foo() {\n    val v = SuccessOrFailure.success(\"OK\")\n    check(v == SuccessOrFailure.success(\"OK\"))\n}\n"
        },
        {
            "code": "\ninline class Foo(val x: Any?)\n\ninline fun bar(a: Any?) {\n    println(a)\n}\n\nfun test(f: Foo) {\n    bar(f) // no boxing, but should be\n}\n"
        },
        {
            "code": "\ninline fun <reified T: ModelBase> Connection.getModel(type: String, id: String): T? {\n   // ...\n}\n"
        },
        {
            "code": "\nclass Bug {\n  private fun createRunnable(nested: Nested): Runnable {\n    return object : Runnable {\n      override fun run() {\n        bug()\n      }\n\n      private inline fun bug() {\n        nested.toString()\n      }\n    }\n  }\n\n  private class Nested\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.Continuation\nimport kotlin.coroutines.CoroutineContext\nimport kotlin.coroutines.EmptyCoroutineContext\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\nimport kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn\nimport kotlin.coroutines.startCoroutine\n\nvar continuation: Continuation<Unit>? = null\n\nsuspend fun suspendHere() = suspendCoroutineUninterceptedOrReturn<Unit> {\n    continuation = it\n    COROUTINE_SUSPENDED\n}\n\nsuspend fun foo() {\n    /*\n    A\n    LOT\n    OF\n    EMPTY\n    LINES\n     */\n    suspendHere()\n    suspendHere()\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(object : Continuation<Unit> {\n        override val context: CoroutineContext\n            get() = EmptyCoroutineContext\n\n        override fun resumeWith(result: SuccessOrFailure<Unit>) {\n            result.getOrThrow()\n        }\n\n    })\n}\n\nfun main(args: Array<String>) {\n    builder {\n        foo()\n    }\n    println(\"$continuation\")\n    continuation!!.resumeWith(SuccessOrFailure.success(Unit))\n    println(\"$continuation\")\n}\n"
        },
        {
            "code": "\ninline class WrappedString(val value: String) {\n    constructor() : this(\"Default\")\n}\n\ninline class WrappedBoolean(val value: Boolean) {\n    constructor() : this(false)\n}\n\ninline class WrappedDouble(val value: Double) {\n    constructor() : this(0.0)\n}\n\nfun main(args: Array<String>) {\n    // val a = WrappedString()\n    // val b = WrappedBoolean()\n    // val c = WrappedDouble()\n}\n"
        },
        {
            "code": "\ninline class Foo<T>(val x: Int)\nclass Bar(val z: Foo<Any>)\n"
        },
        {
            "code": "\npackage test\n\ninterface IFoo<T> {\n    fun foo(): T\n}\n\nopen class CFooInt : IFoo<Int> {\n    override fun foo(): Int = 42\n}\n\nopen class CFooUInt : IFoo<UInt> {\n    override fun foo(): UInt = 42u\n}\n"
        },
        {
            "code": "\nclass Outer {\n    data class Inner(val onSuccess: () -> Unit = {})\n\n    val inner = Runnable {\n        Inner().onSuccess()\n    }\n}\n\nfun main(args: Array<String>) = Outer().inner.run()\n"
        },
        {
            "code": "\nfun test(a: Any?) {\n    (a as String).length\n}\n"
        },
        {
            "code": "\nfun test(a: String) {}\n"
        },
        {
            "code": "\ninline class Z1(val x: Int)\ninline class Z2(val x: Z1)\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val a = listOf(10u, 20u, 30u)\n    a.forEachIndexed { index, uInt ->\n        println(index)\n        println(uInt)\n    }\n}\n"
        },
        {
            "code": "\nexternal interface A {\n    fun foo()\n}\n\nexternal abstract class B {\n    abstract fun bar()\n} \n\nexternal class C : B(), A \n"
        },
        {
            "code": "\nexternal interface Tint {\n    fun setTint(\n        topLeft: Int = definedExternally,\n        topRight: Int = definedExternally,\n        bottomLeft: Int = definedExternally,\n        bottomRight: Int = definedExternally\n    ): Tint\n}\n\nexternal class Sprite : Tint {\n}\n"
        },
        {
            "code": "\nexternal class Sprite : Tint {\n    override fun setTint(topLeft: Int, topRight: Int, bottomLeft: Int, bottomRight: Int): Tint = definedExternally\n}\n"
        },
        {
            "code": "\npackage test\n\nclass Foo {\n    fun bar(obj: Any) {\n        with(obj) {\n            Runnable {\n                obj.hashCode()\n                Runnable { }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\npackage kui\n\nabstract class Component\n\ninterface Renderer<C : Component> {\n    val template: Template\n}\n\nclass Template\n\ninline fun <C : Component> buildTemplate(block: TemplateBuilder<C>.() -> Unit): Template {\n    return BaseTemplateBuilder<C>().apply(block).build()\n}\n\nabstract class TemplateBuilder<C : Component> {\n    inline fun div(block: TemplateElement<C>.() -> Unit) {\n        println(\"hello\")\n        TemplateElement<C>().block()\n    }\n}\n\nclass BaseTemplateBuilder<C : Component> : TemplateBuilder<C>() {\n    fun build(): Template {\n        return Template()\n    }\n}\n\nclass TemplateElement<C : Component> : TemplateBuilder<C>() {\n    inline fun <reified C2 : Component> component(renderer: Renderer<C2>) {\n        println(C2::class.simpleName)\n    }\n}\n"
        },
        {
            "code": "\nimport kui.*\n\nclass C1 : Component() {\n    companion object : Renderer<C1> {\n        override val template = buildTemplate<C1> {\n            div {\n                component(C2)\n            }\n        }\n    }\n}\n\nclass C2 : Component() {\n    companion object : Renderer<C2> {\n        override val template = buildTemplate<C2> {\n            div { }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    C1\n}\n"
        },
        {
            "code": "\n@JvmField val x = 1\n"
        },
        {
            "code": "\npackage com.example.testapp\n\nimport android.os.Bundle\nimport android.support.v7.app.AppCompatActivity\nimport android.view.View\nimport java.util.function.Consumer\n\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val view = View(this)\n        Consumer<Int> { view.lpHeight = it }.accept(1)\n    }\n}\n\ninline var View.lpHeight: Int\n    get() = this.layoutParams?.height ?: -1\n    set(value) {\n        layoutParams = this.layoutParams?.apply { height = value }\n    }\n"
        },
        {
            "code": "\nclass Inv<T>\n\ninline operator fun <reified T: Any> Inv<T>.invoke() = T::class\n\noperator fun <K: Any> Inv<K>.get(i: Int): Inv<K> = this\n\nfun <K: Any> test(a: Inv<K>) {\n    a[1]() // should be TYPE_PARAMETER_AS_REIFIED error\n}\n\nfun main(args: Array<String>) {\n    test(Inv<String>())\n}\n"
        },
        {
            "code": "\npackage test\n\nclass Zap<T>\n\ninline val <reified T> Zap<T>.zapper\n    get() = { x: Any -> x as T }\n\nfun main(args: Array<String>) {\n    println(Zap<Int>().zapper(\"abc\"))\n}\n"
        },
        {
            "code": "\ninline fun <reified T> classOf(): Any = { 1 is T }()\n\nfun main(args: Array<String>) {\n    println(classOf<Int>())\n}\n"
        },
        {
            "code": "\n  println(0.0 <= -0.0F) // true\n \n  val zero: Double = 0.0\n  val floatZero: Float = -0.0F    \n  println(zero <= floatZero) // true\n \n  val zeroAny: Any = 0.0\n  val floatZeroAny: Any = -0.0F\n  if (zeroAny is Double && floatZeroAny is Float) {\n      println(zeroAny <= floatZeroAny) //false\n  }\n"
        },
        {
            "code": "\nfun fn1(x: Any) {}\nval f1 = ::fn1 as Any\nf1 is SuspendFunction0<*> // this is true in Kotlin/JS and false in Kotlin/JVM\n"
        },
        {
            "code": "\npackage test\n\nimport kotlinx.coroutines.experimental.*\nimport kotlinx.coroutines.experimental.future.await\nimport java.util.concurrent.CompletableFuture\nimport java.util.concurrent.CompletionStage\n\nprivate suspend fun <T> CompletionStage<T>.myAwait(): T {\n  try {\n    return await()\n  } catch (e: Exception) {\n    throw Exception(e)\n  }\n}\n\nfun main(args: Array<String>) {\n  val future = CompletableFuture<Unit>()\n  launch {\n    delay(1000)\n    future.completeExceptionally(Exception(\"bar\"))\n  }\n  runBlocking {\n    future.myAwait()\n  }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n  val future = CompletableFuture<Unit>()\n  runBlocking {\n    future.completeExceptionally(Exception(\"bar\"))\n    future.myAwait()\n  }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {                          \n    println(\"Hello, world!\")    \n    val v = Vector(1.0, 0.0, 2.0)    \n    println(\"Vector! $v\")\n}\ninline class Vector(val raw: DoubleArray) {\n    constructor(x: Double, y: Double, z: Double): this(doubleArrayOf(x, y, z))\n}\n"
        },
        {
            "code": "\ninline class Z(val x: Int)\n\nvar z = Z(0)\nclass Test(var z: Z)\n"
        },
        {
            "code": "\ninline class IC<T>(val value: T)\n\nfun main(args: Array<String>) {\n    val ic = IC(\"OK\")\n    println(ic)\n}\n"
        },
        {
            "code": "\npublic inline fun <reified T> jaggedArrayOfNulls(rows: Int, cols: Int): Array<Array<T?>>\n        = Array(rows) { arrayOfNulls<T>(cols) }\n\npublic fun jaggedIntArray(rows: Int, cols: Int): Array<IntArray>\n        = Array(rows) { IntArray(cols) }\n\n// etc for primitives\n"
        },
        {
            "code": "\n@Target(AnnotationTarget.PROPERTY_GETTER)\nannotation class Foo\n\nannotation class A(@get:Foo val x: Int)\n"
        },
        {
            "code": "\npackage test\n\nfun nothing_to_do_with_anything() = listOf<String>().associate { it to it }\nfun nothing_to_do_with_anything_either() = listOf<String>().mapNotNull { null }\n\nopen class Parent\n\nclass Child : Parent()\n\nclass StupidThings(map: Map<String, List<Parent>>) {\n\n    private val _map = HashMap<String, List<Child>>()\n\n    init {\n        map.forEach { (key, bindings) ->\n            _map[key] = bindings.map { it as? Child ?: Child() }\n        }\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun foo(): List<Pair<String, List<Child>>> {\n        return _map.keys.map { realKey -> realKey to _map[realKey]!! }\n    }\n\n}\n\nfun main(args: Array<String>) {\n    val test = StupidThings(mapOf(\"coucou\" to listOf(Parent())))\n    test.foo()\n}\n"
        },
        {
            "code": "\ninterface TranslatableEnum {\n\tval name: String\n\t\n\t@JvmDefault\n\tval textKey get() = \"${javaClass.canonicalName}.$name\"\n}\n\nenum class SideOfTheWorld : TranslatableEnum {\n\tNORTHERN,\n\tSOUTHERN,\n\tEASTERN,\n\tWESTERN;\n\t\n\toverride val textKey = super.textKey\n}\n"
        },
        {
            "code": "\nimport com.google.common.base.Functions\nimport java.util.stream.Collectors\n\nclass Test {\n\n    fun test() {\n        emptyList<String>()\n                .stream()\n                .collect(\n                        Collectors.groupingBy(\n                                Functions.identity(),\n                                Collectors.counting()\n                        )\n                )\n    }\n\n}\n"
        },
        {
            "code": "\nfun test(x: UInt) = \"x: $x\"\n"
        },
        {
            "code": "\ninline class Foo(val abc: String)\n\nfun main(args: Array<String>) {\n    Foo(\"abc\").hashCode()\n}\n"
        },
        {
            "code": "\ninline class Foo(val x:Int)\n\nfun foo(f:Foo){\n    f.hashCode()\n}\n"
        },
        {
            "code": "\ninline class IC<T>(val value: T) {\n    override fun toString() = \"IC($value)\"\n}\n\ndata class Box<T>(var ref: T)\n\nfun main(args: Array<String>) {\n    val ic = IC(\"OK\")\n    val box = Box<Any?>(null)\n    box.ref = ic // SHOULD BOX HERE !!!\n    println(box)\n}\n"
        },
        {
            "code": "\nimport kotlin.contracts.*\n\n@ExperimentalContracts\nfun myRun(block: () -> Unit) {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    block()\n}\n\n@ExperimentalContracts\nfun main(args: Array<String>) {\n    val x: String\n    myRun { x = \"abc\" }\n    println(x)\n}\n"
        },
        {
            "code": "\ndata class Data(val x: String, val y: Int)\n\nfun main(args: Array<String>) {\n    runBlocking {\n        foo(Data(\"A\", 1)) { (x, y) ->\n            println(\"$x / $y\")\n        }\n    }\n}\n\nsuspend fun foo(data: Data, body: suspend (Data) -> Unit) {\n    body(data)\n}\n"
        },
        {
            "code": "\n    var a: UByte = 0u\n    val u: Any? = --a\n    println(u)   // prints -1\n    println(u!!.javaClass) // prints java.lang.Byte\n"
        },
        {
            "code": "\n// MODULE: lib\n// FILE: lib.kt\n\ninline fun foo(block: () -> String) = block()\n\nfun String?.ensure() = this ?: \"\"\n\ninline fun String.bar(block: (String) -> String?): String {\n    return block(this).ensure()\n}\n\n// MODULE: main(lib)\n// FILE: main.kt\n\nclass A(val a: String) {\n    init {\n        foo {\n            a.bar { it }\n        }\n    }\n}\n\nclass B(val a: String) {\n    val ok: String\n\n    init {\n        foo {\n            ok = a.bar { it }\n        }\n    }\n}\n\nfun box() = B(\"OK\").ok\n"
        },
        {
            "code": "\n@Target(AnnotationTarget.TYPE)\nannotation class A\n"
        },
        {
            "code": "\nfun <C, R> C.ifEmpty(f: () -> R): R where C: Collection<*>, C: R\n"
        },
        {
            "code": "\npackage com.company.test\n\nval BUILT = buildString { append(STRING) }\n"
        },
        {
            "code": "\npackage com.company.test\n\nconst val STRING = \"Test\"\n"
        },
        {
            "code": "\nval BUILT by lazy { buildString { append(STRING) } }\n"
        },
        {
            "code": "\nimport kotlin.reflect.KProperty\nimport kotlin.reflect.KProperty0\n\nclass ByteDelegate(\n    private val position: Int,\n    private val uIntValue: KProperty0<UInt>\n) {\n    operator fun getValue(any: Any?, property: KProperty<*>): UByte {\n        val uInt = uIntValue.get() shr (position * 8) and 0xffu\n        return uInt.toUByte()\n    }\n}\n"
        },
        {
            "code": "\nimport org.junit.jupiter.api.Test\nimport kotlin.test.assertEquals\n\nclass ByteDelegateTest {\n\n    val uInt = 0xA1B2C3u\n    val uByte  by ByteDelegate(0, this::uInt)\n\n    @Test\n    fun `Failing example`() {\n        val actual = uByte\n        assertEquals(0xC3u, actual)\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.KProperty\nimport kotlin.reflect.KProperty0\n\nclass ByteDelegate(\n    private val position: Int,\n    private val uIntValue: KProperty0<UInt>\n) {\n    operator fun getValue(any: Any?, property: KProperty<*>): UByte {\n        val uInt = (uIntValue.get() as Int).toUInt() shl position and 0xffu\n        return uInt.toUByte()\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n\tprintln(MyThrowable())\n}\n\nclass MyThrowable(message: String?) :  Throwable(\"through primary: \" + message) {\n    constructor() : this(message = \"secondary\") {\n    }\n    \t\n    init { println(\"init block\") }\n}\n// actual output\n// Error: secondary\n\n// expected output\n// init block\n// MyThrowable: through primary: secondary\n"
        },
        {
            "code": "\nclass Err constructor(msg: String?, unused: Any?) {\n    constructor() : this(null, null)\n    constructor(msg: String) : this(msg, null)\n}\n"
        },
        {
            "code": "\ninline fun createErr() {\n    Err(\"createErr\")\n}\n"
        },
        {
            "code": "\nfun useCreateErr()  {\n    createErr()\n}\n"
        },
        {
            "code": "\nfun dummy() {}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.buildSequence\n\nfun main(args: Array<String>) {\n    buildSequence<Unit> {\n        listOf(1)\n            .groupingBy { it }\n            .reduce { _, a, b -> a + b }\n    }.toList()\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.*\n\nfun main(args: Array<String>) {\n    val s = buildSequence {\n        yield(1)\n        val a = awaitSeq()\n        println(a) // (1)\n    }\n    println(s.toList())\n}\n\nsuspend fun SequenceBuilder<Int>.awaitSeq(): Int = 42\n"
        },
        {
            "code": "\ninterface SubMap<K, V> : Map<K, V> {\n    override val values: Set<V>\n}\n"
        },
        {
            "code": "\ninline class Username(val value: String)\n\nfun scenarioB(name: Username?): List<Username?> = listOf(name)\n\nfun main(args: Array<String>) {\n    scenarioB(null)\n}\n"
        },
        {
            "code": "\n// Kotlin\n\nval c: MyClass? = MyClass()\n\nfun main(args: Array<String>) {\n    c?.field += \"566\" // the issue is here\n}\n"
        },
        {
            "code": "\ninline class Empty(val x: Unit)\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val arr = Array(5) { 12u }\n    for (i in arr.indices) {\n        println(\"arr[$i] = ${arr[i]}\")\n    }\n}\n"
        },
        {
            "code": "\nvar intN: Int? = 0\nvar uintN: UInt? = 0u\n\nfun test() = intN == 1\n\nfun testU1() = uintN == 1u\n\nfun testU2() = 1u == uintN\n"
        },
        {
            "code": "\ninline class UInt(private val data: Int)\n\nval unull = UInt(1) ?: null // autoboxing to Integer, not UInt\n"
        },
        {
            "code": "\npackage tech.pronghorn\n\nabstract class C {\n    protected abstract fun optional(): String?\n    protected abstract suspend fun slow(): String\n\n    suspend fun optimized(): String {\n        val value = optional()\n        if(value != null){\n            return value\n        }\n        else {\n            return slow()\n        }\n    }\n\n    suspend fun notOptimized(): String {\n        return optional() ?: slow()\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val x = Wrapper(1)\n    println(x)\n}\n\ninline class Wrapper(private val v: Int)\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val x = Wrapper(112u)\n    println(x)\n}\n\ninline class Wrapper(private val v: UInt)\n"
        },
        {
            "code": "\npackage test\n\ninline class Z(val value: Int)\n\nfun eqZ(x: Z, y: Z?) = x == y\n\nfun main(args: Array<String>) {\n    println(eqZ(Z(1), Z(1))) // false\n}\n"
        },
        {
            "code": "\ninline class InlineDouble(val value: Double)\n\ndata class DataDouble(val double: Double)\n\nfun main(args: Array<String>) {\n    println(InlineDouble(0.0) == InlineDouble(-0.0))\n    println(InlineDouble(Double.NaN) == InlineDouble(Double.NaN))\n\n    println(DataDouble(0.0) == DataDouble(-0.0))\n    println(DataDouble(Double.NaN) == DataDouble(Double.NaN))\n}\n"
        },
        {
            "code": "\ntrue\nfalse\nfalse\ntrue\n"
        },
        {
            "code": "\ninline class Z7(private val data: Int) {\n    override fun equals(other: Any?): Boolean =\n        other is Z7 && other.data % 7 == data % 7\n}\n\nvar za = Z7(1)\nvar zb = Z7(8)\n\nfun box(): String {\n    if (za != zb) throw AssertionError()\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "\nabstract class SuccessOrFailureReceiver<T> {\n    abstract fun receive(result: SuccessOrFailure<T>)\n}\n\ninline fun <T> SuccessOrFailureReceiver(crossinline f: (SuccessOrFailure<T>) -> Unit): SuccessOrFailureReceiver<T> =\n    object : SuccessOrFailureReceiver<T>() {\n        override fun receive(result: SuccessOrFailure<T>) {\n            f(result)\n        }\n    }\n"
        },
        {
            "code": "\n    @Test\n    fun testCrossInline() {\n        var invoked = false\n        val receiver = SuccessOrFailureReceiver<Int> { result ->\n            val intResult = result.getOrThrow() // FAILS HERE !!!\n            assertEquals(42, intResult)\n            invoked = true\n        }\n        receiver.receive(SuccessOrFailure.success(42))\n        assertTrue(invoked)\n    }\n"
        },
        {
            "code": "\npackage co\n\n\n@Suppress(\"UNSUPPORTED_FEATURE\")\ninline class Wrapper(val internal: Int)\n\n\ninline fun <T> foo(callback: () -> T): T {\n    return callback()\n}\n\ninline fun bar(callback: () -> Wrapper): Wrapper {\n    return callback()\n}\n\nfun main(args: Array<String>) {\n    println(foo { Wrapper(10) }.internal) // Boxing\n    println(bar { Wrapper(10) }.internal) // Boxing\n}\n\n"
        },
        {
            "code": "\nval variableName: VariableType = expression\nwhen (variableName) {\n  // 'when' branches\n}\n"
        },
        {
            "code": "\nval x: String by null\n\noperator fun Nothing?.getValue(instance: Any?, metadata: Any?): String = \"OK\"\n\nfun box(): String = x\n\nfun main(args: Array<String>) {\n    println(box())\n}\n"
        },
        {
            "code": "\nsuspend fun foo() {}\n\nsuspend fun bar() {\n    foo()\n    foo()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    suspend fun foo() = \"foo\"\n    runBlocking {\n        println(foo())\n    }\n}\n"
        },
        {
            "code": "\ninterface I {\n    fun bar()\n}\n\nclass A : I {\n    override inline fun bar() {\n        // implementation here\n    }\n}\n\nval x: I = A()\nx.bar() // won't be inlined, since I.bar is not marked as inline \n"
        },
        {
            "code": "\nimport helpers.*\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.*\n\nvar continuation: () -> Unit = { }\nvar log = \"\"\nvar finished = false\n\nsuspend fun <T> foo(v: T): T = suspendCoroutineOrReturn { x ->\n    continuation = {\n        x.resume(v)\n    }\n    log += \"foo($v);\"\n    COROUTINE_SUSPENDED\n}\n\ninterface I {\n    suspend fun bar()\n}\n\nclass A(val v: String) : I {\n    override inline suspend fun bar() {\n        log += \"before bar($v);\"\n        foo(\"1:$v\")\n        log += \"inside bar($v);\"\n        foo(\"2:$v\")\n        log += \"after bar($v);\"\n    }\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(handleResultContinuation {\n        continuation = { }\n        finished = true\n    })\n}\n\nsuspend fun baz() {\n    val a = A(\"A\")\n    a.bar()\n\n    log += \"between bar;\"\n\n    val b: I = A(\"B\")\n    b.bar()\n}\n\nval expectedString =\n        \"before bar(A);foo(1:A);@;inside bar(A);foo(2:A);@;after bar(A);\" +\n        \"between bar;\" +\n        \"before bar(B);foo(1:B);@;inside bar(B);foo(2:B);@;after bar(B);\"\n\nfun box(): String {\n    builder {\n        baz()\n    }\n\n    while (!finished) {\n        log += \"@;\"\n        continuation()\n    }\n\n    if (log != expectedString) return \"fail: $log\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "\nsealed class X {\n    class A : X()\n    class B : X()\n}\n\nsuspend fun process(a: X.A) {}\nsuspend fun process(b: X.B) {}\n\nsuspend fun process(x: X) = when (x) {\n    is X.A -> process(x)\n    is X.B -> process(x)\n}\n"
        },
        {
            "code": "\ninline class Foo(val arg: String)\n\nfun main(args: Array<String>) {\n    for (el in listOf(Foo(\"abc\"))) {\n    }\n}\n"
        },
        {
            "code": "\ninline class Foo(val arg: Int)\n\nfun main(args: Array<String>) {\n    for (el in arrayOf<Foo>()) {\n\n    }\n}\n"
        },
        {
            "code": "\ninline class Foo(val x: Int) {\n    fun bar() {}\n}\n"
        },
        {
            "code": "\n// ext.kotlin_version = '1.2.60-eap-7'\n//\n//compileKotlin {\n//    kotlinOptions.jvmTarget = \"1.8\"\n//    kotlinOptions.freeCompilerArgs = [\"-XXLanguage:+InlineClasses\"]\n//    kotlinOptions.languageVersion = \"1.2\"\n//}\n\ninline class Rgba(val value: Int) {\n    inline val r: Int get() = (value shr 0) and 0xFF\n    inline val g: Int get() = (value shr 8) and 0xFF\n    inline val b: Int get() = (value shr 16) and 0xFF\n    inline val a: Int get() = (value shr 24) and 0xFF\n}\n\nfun Rgba(r: Int, g: Int, b: Int, a: Int): Rgba {\n    return Rgba(\n        ((r and 0xFF) shl 0) or ((g and 0xFF) shl 8) or ((b and 0xFF) shl 16) or ((a and 0xFF) shl 24)\n    )\n}\n\nfun Rgba.withR(r: Int) = Rgba(r, g, b, a)\nfun Rgba.withG(g: Int) = Rgba(r, g, b, a)\nfun Rgba.withB(b: Int) = Rgba(r, g, b, a)\nfun Rgba.withA(a: Int) = Rgba(r, g, b, a)\n\ninline class RgbaArray(val array: IntArray) {\n    constructor(size: Int) : this(IntArray(size))\n    operator fun get(index: Int): Rgba = Rgba(array[index])\n    operator fun set(index: Int, color: Rgba) {\n        array[index] = color.value\n    }\n}\n\nfun main(args: Array<String>) {\n    val result = RgbaArray(32) // Cause exception: AFTER mandatory stack transformations: incorrect bytecode Element is unknownThe root cause was thrown at: MethodVerifier.kt:28\n    //val result = RgbaArray(IntArray(32)) // Works\n    val color = Rgba(128, 128, 0, 255)\n    result[0] = color.withG(64).withA(0)\n    println(result[0].value)\n}\n"
        },
        {
            "code": "\nprivate val ZZ_ACTION = zzUnpackAction()\n\n        private val ZZ_ACTION_PACKED_0 = \"\\u0004\\u0000\\u0003\\u0001\\u0001\\u0002\\u0002\\u0003\\u0001\\u0004\\u0001\\u0005\\u0001\\u0006\\u0001\\u0003\" +\n                \"\\u0001\\u0006\\u0001\\u0007\\u0001\\u0008\\u0001\\u0009\\u0001\\u000a\\u0002\\u000b\\u0001\\u0001\\u0002\\u000b\" +\n                \"\\u0001\\u0000\\u0001\\u0001\\u0003\\u0000\\u0002\\u000c\\u0001\\u000d\\u0001\\u000e\\u0007\\u0000\\u0001\\u0001\" +\n                \"\\u0001\\u000d\\u0003\\u0000\\u0001\\u000f\\u000a\\u0000\\u0001\\u0001\\u000c\\u0000\\u0001\\u0010\\u0002\\u0000\" +\n                \"\\u0001\\u0011\\u0003\\u0000\\u0001\\u000f\\u0005\\u0000\\u0001\\u0010\\u0012\\u0000\\u0001\\u0010\\u0010\\u0000\" +\n                \"\\u0001\\u000f\\u0002\\u0000\\u0001\\u000f\\u003c\\u0000\\u0001\\u000f\\u0172\\u0000\"\n\n        private fun zzUnpackAction(): IntArray {\n            val result = IntArray(553)\n            var offset = 0\n            offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result)\n            return result\n        }\n"
        },
        {
            "code": "\nclass KotlinDelegate(impl: KotlinInterface) : KotlinInterface by impl\n\nclass JavaDelegate(impl: JavaInterface) : JavaInterface by impl\n"
        },
        {
            "code": "\ninterface KotlinInterface {\n    fun plugin(id: String)\n}\n"
        },
        {
            "code": "\nclass CanGetParameterNames {\n\n    @Test\n    fun `from java interface`() {\n        assertParameterNamesOf(JavaInterface::class.java)\n    }\n\n    @Test\n    fun `from kotlin interface`() {\n        assertParameterNamesOf(KotlinInterface::class.java)\n    }\n\n    @Test\n    fun `from kotlin delegate`() {\n        assertParameterNamesOf(KotlinDelegate::class.java)\n    }\n\n    @Test\n    fun `from java delegate`() {\n        assertParameterNamesOf(JavaDelegate::class.java)\n    }\n\n    private\n    fun assertParameterNamesOf(javaClass: Class<*>) {\n\n        val pluginMethod =\n            javaClass.getDeclaredMethod(\"plugin\", String::class.java)\n\n        assertThat(\n            pluginMethod.parameters.map { it.name },\n            equalTo(listOf(\"id\"))\n        )\n    }\n}\n"
        },
        {
            "code": "\npackage com.packageA\n\nabstract class A {\n    protected var x: String? = null\n        private set // important that setter is private\n\n\n    open fun set() {\n        x = \"not_important\"\n    }\n}\n"
        },
        {
            "code": "\npackage com.packageB\n\nimport com.packageA.A\n\nfun <R> nonInlineFunction(block: () -> R): R =  block()\n\nclass B : A() {\n\n    override fun set() {\n        super.set()\n\n        nonInlineFunction {\n            System.out.println(x?.length) // acessing to this field cause generation of accessors\n        }\n    }\n}\n"
        },
        {
            "code": "\noperator fun <T, U> T.invoke(x: U) = \":)\"\n\nfun main(args: Array<String>) {\n    \tval a = String { 1 }\n    \tprintln(a)\n}\n"
        },
        {
            "code": "\noperator fun <T, U> T.invoke(x: U) = \":)\"\n\nfun main(args: Array<String>) {\n    \tval a = KotlinVersion { 1 }\n    \tprintln(a)\n}\n"
        },
        {
            "code": "\nexpect class Sample1(test: Int) {\n    val demo: Int\n}\n\nfun Sample1() = Sample1(10)\n"
        },
        {
            "code": "\nactual class Sample1 actual constructor(val test: Int) {\n    actual val demo: Int = test\n}\n"
        },
        {
            "code": "\ninterface QuotationView {\n    fun showQuote(quote: Quote)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val x = Wrapper(\"Hello\")\n    println(x.toString())\n}\n\ninline class Wrapper(private val v: String)\n"
        },
        {
            "code": "\nfun fakeNotNull(): @EnhancedNullability Any\nfun fakeNotNullInteger(): @EnhancedNullability Int\n"
        },
        {
            "code": "\npackage test\n\nfun main(args: Array<String>) {\n    val a: Any = TestNotNull.fakeNotNull() // (*)\n    println(a)\n}\n"
        },
        {
            "code": "\npackage test\n\nfun testFakeNotNull() = TestNotNull.fakeNotNull()\n\nfun main(args: Array<String>) {\n    val a: Any = testFakeNotNull() // (*)\n    println(a)\n}\n"
        },
        {
            "code": "\npackage test\n\nfun testFakeNotNull() = TestNotNull.fakeNotNull()\n"
        },
        {
            "code": "\npackage test2\n\nimport test.testFakeNotNull\n\nfun main(args: Array<String>) {\n    val a: Any = testFakeNotNull()\n    println(a) // prints null\n}\n"
        },
        {
            "code": "\npackage test\n\nfun testFakeNotNullInt() = TestNotNull.fakeNotNullInteger()\n// JVM signature:\n//      public final static testFakeNotNullInt()Ljava/lang/Integer;\n//      @Lorg/jetbrains/annotations/NotNull;() // invisible\n// Kotlin signature:\n//      fun testFakeNotNull(): [@EnhancedNullability] kotlin.Int \n"
        },
        {
            "code": "\npackage test2\n\nimport test.testFakeNotNullInt\n\nfun main(args: Array<String>) {\n    println(testFakeNotNullInt()) // (*)\n}\n"
        },
        {
            "code": "\nfun km() = J.m() // Inferred type: Any\n"
        },
        {
            "code": "\nfun km2() {\n  km()\n}\n"
        },
        {
            "code": "\nsuspend inline fun <R> inlined(\n    crossinline step: suspend () -> R\n): R = notInlined { step() }\n\nsuspend fun <R> notInlined(\n    block: suspend () -> R\n): R = block()\n"
        },
        {
            "code": "\nsuspend fun test() {\n    inlined {\n        println(\"Oi\")\n    }\n}\n"
        },
        {
            "code": "\ninterface Job {\n    public fun cancel(cause: Throwable? = null): Boolean\n}\n"
        },
        {
            "code": "\nclass JobSupport : Job {  \n   public override fun cancel(cause: Throwable?): Boolean =\n        if (hasCancellingState)\n            makeCancelling(cause) else\n            makeCancelled(cause)\n}\n"
        },
        {
            "code": "\nclass AbstractContinuation : JobSupport, Continuation\n"
        },
        {
            "code": "\nclass CancellableContinuationImpl : AbstractContinuation, CancellableContination\n\ninterface CancellableContination {\n    public fun cancel(cause: Throwable? = null): Boolean\n}\n"
        },
        {
            "code": "\nclass CancellableContinuationImpl : AbstractContinuation, CancellableContination {\n    public override fun cancel(cause: Throwable?): Boolean =\n        super.cancel(cause)\n}\n"
        },
        {
            "code": "\n\nclass Data\n\nexpect interface I {\n    fun f(p: Data? = null)\n}\n\ninterface C : I\n"
        },
        {
            "code": "\n\nactual interface I {\n    actual fun f(p: Data?)\n}\n\nclass Impl : C, I {\n    override fun f(p: Data?) {\n        println(p)\n    }\n}\n\nfun main(args: Array<String>) {\n    Impl().f()\n}\n"
        },
        {
            "code": "\npackage test\n\nimport test.B.x\n\nobject B {\n    var x = 0\n}\n\nfun test() {\n    x += 42\n}\n"
        },
        {
            "code": "\nsuspend fun dummy(a: Int) {}\n\nsuspend fun foo(a: Int) {\n    dummy(a)\n    dummy(a)\n}\n"
        },
        {
            "code": "\n        val d = async<String>(coroutineContext) {\n            expect(3)\n            try {\n                yield() // to main, will cancel\n            } finally {\n                expect(6) // will go there on await (!!!!!!! GETS INVOKED TWICE !!!!!)\n                return@async \"Fail\" // result will not override cancellation\n            }\n            expectUnreached()\n            \"Fail2\"\n        }\n"
        },
        {
            "code": "\nimport kotlin.reflect.*\n\n// var out by atomicRef(listOf<String>()) // works\nfun main(args: Array<String>) {\n\tvar out by atomicRef(listOf<String>()) // fails\n\tval obj = object {\n        init {\n            println(out)\n        }\n    }\n}\n\nclass atomicRef<T>(var initial: T) {\n\tval value = java.util.concurrent.atomic.AtomicReference<T?>(initial)\n\n\tinline operator fun getValue(obj: Any?, property: KProperty<*>): T {\n\t\t@Suppress(\"UNCHECKED_CAST\")\n\t\treturn this.value.get() as T\n\t}\n\n\tinline operator fun setValue(obj: Any?, property: KProperty<*>, v: T) {\n\t\tthis.value.set(v)\n\t}\n}\n"
        },
        {
            "code": "\nsealed class A {\n    companion object {\n        val STATIC = listOf(AA, AB)\n    }\n}\n\nobject AA : A()\nobject AB : A()\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(A.STATIC) // [AA@..., AB@...]\n    println(listOf(AA, AB)) // [AA@..., AB@...]\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(listOf(AA, AB)) // [AA@..., AB@...]\n    println(A.STATIC) // [null, AB@...]\n}\n"
        },
        {
            "code": "\n@Test\nfun testBasicScenario() = runTest {\n    // `this` is suspend lambda\n    expect(1)\n    val broadcast = ConflatedBroadcastChannel<String>()\n    // Buggy line\n    assertTrue(exceptionFromNotInline { broadcast.value } is IllegalStateException) // Getter of broadcast.value throws ISE\n    // Other stuff\n}\n\ninline fun exceptionFrom(block: () -> Unit): Throwable? {\n    try {\n        block()\n        return null\n    } catch (e: Throwable) {\n        return e\n    }\n}\n\nfun exceptionFromNotInline(block: () -> Unit): Throwable? {\n    try {\n        block()\n        return null\n    } catch (e: Throwable) {\n        return e\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.*\n\nenum class Foo(vararg expected: String) {\n    A(\"start\", \"A\", \"end\"),\n    B(\"start\", \"BCD\", \"end\"),\n    C(\"start\", \"BCD\", \"end\"),\n    D(\"start\", \"BCD\", \"end\"),\n    E(\"start\", \"E\", \"end\"),\n    F(\"start\", \"end\");\n    \n    val expected = expected.toList()\n}\n\nfun main(args: Array<String>) {\n    for (v in Foo.values()) {\n        test(v)\n    }\n}\n\nfun test(c: Foo) {\n    print(\"$c: \")\n\n    val actual = getSequence(c).toList()\n    if (actual == c.expected) {\n        println(\"OK -- ${c.expected}\")\n    } else {\n        println(\"Fail -- ${c.expected} != $actual\")\n    }\n}\n\nfun getSequence(a: Foo) =\n    buildSequence {\n//         println(\"start\")\n        yield(\"start\")\n        when (a) {\n            Foo.A -> {\n//                 println(\"A\")\n                yield(\"A\")\n            }\n            Foo.B,\n            Foo.C,\n            Foo.D-> {\n//                 println(\"BCD\")\n                yield(\"BCD\")\n            }\n            Foo.E-> {\n//                 println(\"E\")\n                yield(\"E\")\n            }\n        }\n//         println(\"end\")\n        yield(\"end\")\n    }\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n  var increaseMe: Long = 0\n  val enum = Enum.ONE\n\n  @Suppress(\"NON_EXHAUSTIVE_WHEN\")\n  when (enum) {\n    Enum.ONE -> increaseMe++\n    Enum.TWO -> increaseMe++\n  }\n\n  println(increaseMe)\n}\n\nenum class Enum {\n  ONE, TWO, THREE\n}\n"
        },
        {
            "code": "\nimport java.lang.reflect.Method\nimport java.util.*\n\nfun main(args: Array<String>) {\n    // SAM adapter method returns null element in \"genericParameterTypes\" instead of Object\n    val kotlinSamAdapterTestMethod = Java.getTestMethod(Objects::nonNull)\n    printParameterTypes(\"Kotlin SAM Adapter Method\", kotlinSamAdapterTestMethod)\n\n    val kotlinTestMethod = Java.getTestMethod { Objects.nonNull(it) }\n    printParameterTypes(\"Kotlin Lambda Method\", kotlinTestMethod)\n}\n\nfun printParameterTypes(title: String, method: Method) {\n    println(title)\n    println(\"          parameterTypes ${method.parameterTypes?.contentToString()}\")\n    println(\"   genericParameterTypes ${method.genericParameterTypes?.contentToString()}\")\n    println()\n}\n"
        },
        {
            "code": "\nfun <T> String.parse(): List<T> =\n    this.split(\",\").map {\n        try {\n            it as T\n        } catch (e: ClassCastException) {\n            error(\"fail\") // <-- 1\n        }\n    }\n\nfun main(args: Array<String>) {\n    val list = \"a,b,c\".parse<Int>()\n    println(list)\n    list.forEach {\n        try {\n            it + 1\n        } catch (e: ClassCastException) {\n            error(\"epic fail\") // <-- 2\n        }\n    }\n}\n"
        },
        {
            "code": "\nenum class A {\n    X {\n        val x = 1\n        class Nested {\n            val y = x // It's allowed and seems to be fine, because a Nested instance can use A.X\n        }\n\n        val z = Nested() // There wasn't PUTSTATIC A.X yet, fails with NPE\n    }\n}\n\n\nfun main(args: Array<String>) {\n    println(A.X)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    lateinit var s: String\n    println(s)\n}\n"
        },
        {
            "code": "\nfun readI(): Int = Random().nextInt()\n\nfun f() {\n    var i = 0\n    label@while(true) {\n        i = readI()\n        when(i) {\n            0 -> throw IllegalStateException()\n            -1 -> break@label\n            else -> throw IllegalStateException()\n        }\n    }\n}\n"
        },
        {
            "code": " code\ntrait T {\n    fun ab(n: String)\n}\n\nclass TImpl : T {\n    override fun ab(n: String) {\n    }\n}\n"
        },
        {
            "code": "\nclass Bar\n\nclass Foo {\n    val bar = Bar()\n}\n\ninline operator fun Bar.invoke(f: () -> String) { f() }\n\nfun box(): String {\n    Foo().bar { return \"OK\" }\n    return \"fail\"\n}\n\nfun main(args: Array<String>) {\n    println(box())\n}\n"
        },
        {
            "code": "\nval i = 0x9747b28c.toInt()\n"
        },
        {
            "code": "\nfun F(): String\n{\n    val x = \"X\"\n    return \"Some \" +\n        \"very \" +\n        \"long \" +\n        \"string $x\"\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val sb = StringBuilder()\n    val foo = \"Bar\"\n    sb.append(\"My name is $foo.\")\n}\n"
        },
        {
            "code": "\nclass Node {\n    @Volatile\n    private var state: Any? = null\n    \n    private companion object {\n        @JvmStatic\n        val STATE = AtomicReferenceFieldUpdater.newUpdater(Node::class.java, Any::class.java, \"state\")\n    }\n}\n"
        },
        {
            "code": "\nsuspend fun <R> KCallable<R>.callSuspend(vararg args: Any?): R = \n    suspendCoroutineUninterceptedOrReturn { call(*args) }\n"
        },
        {
            "code": "\nclass QualifierPart(\n        name: String,\n        typeArguments: String? = null\n)\n\nfun foo() {\n    listOf(\"\").map(::QualifierPart)\n}\n"
        },
        {
            "code": "\nfun foo(x: String, y: Int = 0) {}\n\nfun bar(f: (String) -> Unit) {}\n\nfun test() {\n    bar(::foo)\n}\n"
        },
        {
            "code": "\nabstract class Outer {\n    inner class Inner<R>\n    fun <R> foo(): Inner<R>? = null\n}\n\nfun box(): String {\n    Outer::class.java.getDeclaredMethods().single { it.name == \"foo\" }.toGenericString()\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "\nval myObject = json {\n   someField = 1\n   otherField = \"a\"\n}   // myObject of type dynamic\n"
        },
        {
            "code": "\n@Target(AnnotationTarget.PROPERTY)\nannotation class Foo\n\nannotation class A(@Foo val x: Int)\n"
        },
        {
            "code": "\nsealed class TestAxis(val opposite: TestAxis) {\n    object Horizontal : TestAxis(TestAxis.Vertical)\n    object Vertical : TestAxis(TestAxis.Horizontal)\n}\n \nclass Tests {\n    @Test\n    fun test() {\n        // One of these asserts fails.\n        // Debugging shows that one of the 'opposite' fields becomes null\n        assert(TestAxis.Vertical.opposite == TestAxis.Horizontal)\n        assert(TestAxis.Horizontal.opposite == TestAxis.Vertical)\n    }\n}\n"
        },
        {
            "code": "\nabstract class C {\n    protected abstract fun ready(): Boolean\n    protected abstract suspend fun slow(): Boolean\n\n    suspend fun optimized(): Boolean {\n        if(ready()){\n            return true\n        }\n        else {\n            return slow()\n        }\n    }\n\n    suspend fun notOptimized(): Boolean {\n        return ready() || slow()\n    }\n}\n"
        },
        {
            "code": "\ninterface A\n\ndata class B<out T : A>(val a: T)\n\nfun main(args: Array<String>) {\n  val b1 = B(object : A {})\n  val b2 = B(object : A {})\n  println(b1.hashCode() == b2.hashCode())\n}\n"
        },
        {
            "code": "\nannotation class Anno\n\n@Anno\ndata class DataCls(val a: Anno)\n\nfun box(): String {\n    val anno = DataCls::class.annotations.first() as Anno\n    val d1 = DataCls(anno)\n    val d2 = DataCls(anno)\n    val c1 = d1.equals(d2)\n    val c2 = d1.hashCode() \n    return \"OK\"\n}\n"
        },
        {
            "code": "\nexpect object A {\n   val b: B\n}\nobject B{\n  fun foo(){}\n}\n"
        },
        {
            "code": "\nactual object A{\n  actual inline val b get() = B\n}\nfun test() {\n   A.b.foo() // byte code contains a call to getB() but should only contain B.INSTANCE\n}\n"
        },
        {
            "code": "\noverride fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        val a = 213.23\n        a.roundToLong() // <--- Crash occurs here\n    }\n"
        },
        {
            "code": "\n@Target(AnnotationTarget.TYPE)\nannotation class A\n\nfun main(args: Array<String>) {\n    println(A::class.java.declaredAnnotations.toList())\n}\n"
        },
        {
            "code": "\nfun foo(): Int {\n  val x = 0\n  class Bad() {\n          fun getInt(): Int { Bad(); return x }\n  }\n  return Bad().getInt()\n}\n\nSystem.out.println(foo())\n"
        },
        {
            "code": "\nfun testLambdaAsIngestPipelineStep() {\n        val badCategoryPattern = \"\"\"^(\\w+)\\s*\\:\\s*(.+)$\"\"\".toPattern() // Pattern is serializable, Regex is not\n        val scriptFunc = fun EsKotlinScriptTemplate.(): Any? {\n            val newValue = (ctx[\"badContent\"] as? String)\n                    ?.let { currentValue ->\n                        badCategoryPattern.toRegex().matchEntire(currentValue)?.takeIf { it.groups.size >= 3 }\n                                ?.let {\n                                    val typeName = it.groups[1]!!.value.toLowerCase()\n                                    it.groups[2]!!.value.split(',')\n                                            .map { it.trim().toLowerCase() }\n                                            .filterNot { it.isBlank() }\n                                            .map { \"$typeName: $it\" }\n                                } ?: listOf(currentValue)\n                    } ?: emptyList()\n            ctx[\"badContent\"] = newValue\n            return true\n        }\n\n        val simulateSource = makeSimulatePipelineJsonForLambda(scriptFunc)\n\n        val simulateResults = client.admin().cluster().prepareSimulatePipeline(simulateSource).execute().actionGet()\n        simulateResults.results[0]!!.let {\n            val expectedResults = listOf(\"category: history\", \"category: science\", \"category: fish\")\n            // TODO: no response parsing is in the client, need to handle this specially\n        }\n\n    }\n"
        },
        {
            "code": "\n   inline fun Pattern.matchMinimumGroups(text: String, minGroups: Int) =\n            toRegex().matchEntire(text)?.takeIf { it.groups.size >= minGroups }\n"
        },
        {
            "code": "\n badCategoryPattern.matchMinimumGroups(currentValue, 3)\n"
        },
        {
            "code": "\ndata class D(val x: List<String>)\n"
        },
        {
            "code": "\nval o = object : Any() {}\n"
        },
        {
            "code": "\nabstract class TypeReference<T> {\n    val superType: Type = (javaClass.genericSuperclass as ParameterizedType).actualTypeArguments[0]\n}\n"
        },
        {
            "code": "\ninline fun <reified T> type() = object : TypeReference<T>() {} .superType\n"
        },
        {
            "code": "\nprintln(type<Pair<String, Int>>())\n// \"kotlin.Pair<? extends java.lang.String, ? extends java.lang.Integer>\"\n"
        },
        {
            "code": "\ninline fun <reified A1, reified A2> pairType() = type<Pair<A1, A2>>()\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n  val b1 = B(object : A {})\n  val b2 = B(object : A {})\n  println(b1.equals(b2)) // or println(b1 == b2)\n}\n"
        },
        {
            "code": "\npackage samples\n\nimport kotlin.reflect.KClass\nimport kotlin.reflect.KProperty\n\n// Gradle API mockup\n\ninterface Container<T : Any> {\n    fun <U : T> create(name: String, type: KClass<U>, action: U.() -> Unit)\n    fun get(name: String): T\n}\n\ninterface TaskContainer : Container<Task>\n\ninterface Task : ExtensionAware\n\ninterface ExtensionAware\n\ninterface ExtraPropertiesExtension {\n    fun has(name: String): Boolean\n    fun get(name: String): Any?\n    fun set(name: String, value: Any?)\n}\n\n@Suppress(\"unchecked_cast\")\nfun <T> unchecked(o: Any?): T = o as T\n\ninline operator fun <T : Task> Container<T>.invoke(action: Container<T>.() -> Unit) = run(action)\n\ninline fun <reified T : Any, U : T> Container<T>.creating(type: KClass<U>, noinline action: U.() -> Unit): CreatingDelegateProvider<U> =\n    CreatingDelegateProvider(type, unchecked(this), action)\n\nclass CreatingDelegateProvider<T : Any>(\n    private val type: KClass<T>,\n    private val container: Container<T>,\n    private val action: T.() -> Unit) {\n\n    operator fun provideDelegate(receiver: Any?, property: KProperty<*>): Container<T> =\n        container.apply { create(property.name, type, action) }\n}\n\ninline operator fun <reified T : Any> Container<T>.getValue(receiver: Any?, property: KProperty<*>): T =\n    get(property.name)\n\nval ExtensionAware.extra: ExtraPropertiesExtension\n    get() = object : ExtraPropertiesExtension {\n        override fun has(name: String): Boolean = true\n        override fun get(name: String): Any? = \"extra.get(\\\"$name\\\")\"\n        override fun set(name: String, value: Any?) = Unit\n    }\n\noperator fun ExtraPropertiesExtension.provideDelegate(receiver: Any?, property: KProperty<*>): MutablePropertyDelegate =\n    if (isNullable(property)) NullableExtraPropertyDelegate(this, property.name)\n    else NonNullExtraPropertyDelegate(this, property.name)\n\nprivate\nfun isNullable(property: KProperty<*>) =\n    property.returnType.also { println(\"property.returnType == $it\") }.isMarkedNullable\n\ninterface PropertyDelegate {\n    operator fun <T> getValue(receiver: Any?, property: KProperty<*>): T\n}\n\ninterface MutablePropertyDelegate : PropertyDelegate {\n    operator fun <T> setValue(receiver: Any?, property: KProperty<*>, value: T)\n}\n\nprivate\nclass NonNullExtraPropertyDelegate(\n    private val extra: ExtraPropertiesExtension,\n    private val name: String\n) : MutablePropertyDelegate {\n\n    override fun <T> getValue(receiver: Any?, property: KProperty<*>): T =\n        if (!extra.has(name)) cannotGetExtraProperty(\"does not exist\")\n        else unchecked<T>(extra.get(name) ?: cannotGetExtraProperty(\"is null\"))\n\n    override fun <T> setValue(receiver: Any?, property: KProperty<*>, value: T) = TODO()\n\n    private\n    fun cannotGetExtraProperty(reason: String): Nothing =\n        throw IllegalStateException(\"Cannot get non-null extra property '$name' as it $reason\")\n}\n\nprivate\nclass NullableExtraPropertyDelegate(\n    private val extra: ExtraPropertiesExtension,\n    private val name: String\n) : MutablePropertyDelegate {\n\n    override fun <T> getValue(receiver: Any?, property: KProperty<*>): T =\n        unchecked(if (extra.has(name)) extra.get(name) else null)\n\n    override fun <T> setValue(receiver: Any?, property: KProperty<*>, value: T) =\n        extra.set(property.name, value)\n}\n\nclass DefaultTaskContainer : TaskContainer {\n\n    private\n    val map = mutableMapOf<String, Task>()\n\n    override fun get(name: String): Task = map[name]!!\n\n    override fun <T : Task> create(name: String, type: KClass<T>, action: T.() -> Unit) {\n        map[name] = type.constructors.single().call().apply(action)\n    }\n}\n\nval tasks = DefaultTaskContainer()\n\n// User code mockup\n\nclass MyTask : Task {\n    override fun toString() = \"MyTask()\"\n}\n\nval inTopLevelScope by tasks.creating(MyTask::class) {\n    val delegate: String? by extra\n    println(\"inTopLevelScope.delegate: $delegate\")\n}\n\nclass InInitScope {\n    init {\n        val property by tasks.creating(MyTask::class) {\n            val delegate: String? by extra\n            println(\"InInitScope.property.delegate: $delegate\")\n        }\n        println(property)\n    }\n}\n\nprivate\nfun inFunctionScope() {\n    tasks {\n        val property by tasks.creating(MyTask::class) {\n            val delegate: String? by extra\n            println(\"inFunctionScope.tasks.property.delegate: $delegate\")\n        }\n        println(property)\n    }\n}\n\n/**\n * Expected output:\n * "
        },
        {
            "code": "\nenum class AnEnum(val aNonNullField: AnEnum) {\n    A_FIRST_CASE(A_FIRST_CASE)\n}\n"
        },
        {
            "code": "\n@Test\npublic void canUseEnumWithParamFromJava() {\n    assertEquals(AnEnum.A_FIRST_CASE, AnEnum.A_FIRST_CASE.getANonNullField());\n}\n"
        },
        {
            "code": "\nclass Ref<K : Comparable<K>, V>(val key: K, val value: V) : Comparable<Ref<K, *>> {\n    override fun compareTo(other: Ref<K, *>) = key.compareTo(other.key)\n}\n\nfun <K : Comparable<K>, V> smooth(\n    refs: List<Ref<K, V>>,\n    offset: K,\n    normalizer: (value: K, before: K, after: K) -> Double,\n    interpolator: (origin: V, target: V, ratio: Double) -> V\n): V {\n    val index = refs.binarySearchBy(offset) { it.key }\n    if (index >= 0) return refs[index].value\n    val before = refs.getOrNull(-index - 2)\n    val after = refs.getOrNull(-index - 1)\n    return when {\n        before != null && after != null -> interpolator(\n            before.value,\n            after.value,\n            normalizer(offset, before.key, after.key)\n        )\n        before != null && after == null -> before.value\n        before == null && after != null -> after.value\n        else -> error(\"No refs found at $offset\")\n    }\n}\n\ninterface Info<T> {\n    fun interpolate(origin: T, target: T, ratio: Double): T\n}\n\nfun Double.lerp(target: Double, ratio: Double) = this + (target - this) * ratio\nfun Double.unlerp(min: Double, max: Double) = if (min == max) 0.0 else minus(min) / (max - min)\nfun Int.unlerp(min: Int, max: Int) = toDouble().unlerp(min.toDouble(), max.toDouble())\n\nobject DoubleInfo : Info<Double> {\n    override fun interpolate(origin: Double, target: Double, ratio: Double) = origin.lerp(target, ratio)\n}\n\nclass Prop<T>(val info: Info<T>) {\n    val refs = mutableListOf<Ref<Int, T>>()\n}\n\nclass Container {\n    val smooths = mutableListOf<Prop<*>>()\n}\n\nfun main(args: Array<String>) {\n    val container = Container()\n    val prop = Prop(DoubleInfo)\n    container.smooths += prop\n    prop.refs += Ref(0, 4.0)\n    prop.refs += Ref(10, 9.0)\n\n    val atThree = container.smooths.map {\n        smooth(\n            it.refs as List<Ref<Int, Any>>,\n            3,\n            Int::unlerp,\n            it.info::interpolate as (Any, Any, Double) -> Any\n        )\n    }\n    println(atThree)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val container = Container()\n    val prop = Prop(DoubleInfo)\n    container.smooths += prop\n    prop.refs += Ref(0, 4.0)\n    prop.refs += Ref(10, 9.0)\n\n    val atThree = container.smooths.map {\n        it as Prop<Any>  // <- Added cast\n        smooth(it.refs, 3, Int::unlerp, it.info::interpolate)\n    }\n    println(atThree)\n}\n"
        },
        {
            "code": "\ninline fun foo() = false\n\nfun run(x: Boolean, y: Boolean): String {\n    var i = 10\n    l1@ l2@ do {\n        i += 1\n        if (i > 100) return \"NOT_OK\"\n        if (y) continue@l2\n        if (x) continue@l1\n    } while(foo())\n\n    return \"OK\"\n}\n\nfun main(args: Array<String>) {\n    println(run(true, true))\n}\n"
        },
        {
            "code": "\nimport helpers.*\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.*\n\nsuspend fun suspendHere(): String = suspendCoroutineOrReturn { x ->\n    x.resume(\"OK\")\n    COROUTINE_SUSPENDED\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(EmptyContinuation)\n}\n\nfun box(): String {\n    var result = \"\"\n\n    builder(fun () {\n        result = suspendHere()\n    })\n\n    return result\n}\n"
        },
        {
            "code": "\nexpect fun foo(j: Int, i: Int = 1)\n"
        },
        {
            "code": "\n@JvmOverloads\nactual fun foo(j: Int, i: Int = 1) {}\n"
        },
        {
            "code": "\n@JvmOverloads\nactual fun foo(j: Int, i: Int) {}\n"
        },
        {
            "code": "\ninline fun foo() = false\n\nfun run(x: Boolean, y: Boolean): String {\n    var z = 10\n    l1@ l2@ do {\n        z += 1\n        if (z > 100) return \"NOT_OK\"\n        if (x) continue@l1\n        if (y) continue@l2\n    } while(foo())\n\n    return \"OK\"\n}\n\nfun box(): String {\n    return run(true, true)\n}\n"
        },
        {
            "code": "\ninline fun foo(): Boolean {\n    println(\"FAILED\")\n    return false\n}\n\nfun a() = true\n\nfun main(args: Array<String>) {\n    do {\n        println(\"1\")\n        if (a()) break\n        println(\"2\")\n        if (a()) continue\n        println(\"3\")\n    } \n    while(foo())\n}\n"
        },
        {
            "code": "\n1\nFAILED\n"
        },
        {
            "code": "\n1\n"
        },
        {
            "code": "\ninline fun foo() = false\n\nfun run(x: Boolean) {\n    do {     \n        do { } while (false)         \n        if (x) continue\n    } while(foo())\n}\n\nfun main(args: Array<String>) {\n    run(true)\n}\n"
        },
        {
            "code": "\n  function run(x) {\n    do {\n      do {\n      }\n       while (false);\n      if (x)\n        continue;\n      if (!false)\n        break;\n    }\n     while (true);\n  }\n"
        },
        {
            "code": "\ninterface SomeInterface<T>\n\nobject Container {\n    private inline fun <reified T> someMethod() = object : SomeInterface<T> { }\n    class SomeClass : SomeInterface<SomeClass> by someMethod()\n}\n\nfun main(args: Array<String>) {\n    Container.SomeClass()\n}\n"
        },
        {
            "code": "\nval isBefore: Boolean = init@ {\n    if (true) return@init false\n    true\n}()\n"
        },
        {
            "code": "\nclass Test {\n    fun foo() {println(\"Test\")}\n    \n    companion object {\n         @JvmStatic\n         fun foo() {println(\"Companion\")}\n    }\n}\n\nfun main(args: Array<String>) {\n    Test.foo()\n}\n"
        },
        {
            "code": "\n// Utils.kt\n\n@file:MyJvmName(\"MyUtils\")\n\ntypealias MyJvmName = kotlin.jvm.JvmName\n"
        },
        {
            "code": "\ninline fun runMe(block: () -> Unit) {\n    block.invoke() // fails\n//    block() // works\n}\n\nfun box(): String {\n    runMe {\n        return \"OK\"\n    }\n    return \"fail\"\n}\n\nfun main(args: Array<String>) {\n  println(box())\n}\n"
        },
        {
            "code": "\nclass Inline {\n    fun publicCall(): Int = privateCall() * 2\n\n    @SuppressWarnings(\"nothing_to_inline\")\n    private inline fun privateCall(): Int = 42\n}\n"
        },
        {
            "code": "\nclass PromiseTest {\n    @Test\n    fun testPromise(): Promise<Unit> {\n        val p: Promise<Int> = Promise { resolve, reject ->\n            resolve(1)\n        }\n        val q: Promise<String> = p.catch { \"foo\" }\n        val r: Promise<Unit> = q.then { string: String ->\n            // Type system tell us that `string` is of type `String` here, which is not true in fact\n            println(\"Is this a string? ${string is String}\")         \n            println(\"The length of the string is ${string.length}\")\n        }\n        return r\n    }\n}\n"
        },
        {
            "code": "\nclass Promise<T> {\n    fun <S> catch(onRejected: (Throwable) -> S): Promise<S>\n}\n"
        },
        {
            "code": "\nclass Promise<T> {\n    fun <S> catch(onRejected: (Throwable) -> S): Promise<S> where T : S\n}\n"
        },
        {
            "code": "\nfun test() {\n    val c: suspend () -> Unit = {}\n}\n"
        },
        {
            "code": "\nclass DelegationTest {\n    interface DemoInterface {\n        suspend fun foo()\n    }\n\n    class DemoClass : DemoInterface {\n        override suspend fun foo() {\n            delay(1) // use the passed continuation parameter\n            println(\"Hello from DemoClass\")\n        }\n\n    }\n\n    class DecoratorOk(val parent: DemoInterface) : DemoInterface {\n        override suspend fun foo() {\n            println(\"DecoratorOk\")\n            parent.foo()\n        }\n    }\n\n    class DecoratorFails(parent: DemoInterface) : DemoInterface by parent\n\n    @Test\n    fun test() = async {\n        val parent = DemoClass()\n        DecoratorOk(parent).foo()\n        DecoratorFails(parent).foo()\n    }.asPromise()\n}\n"
        },
        {
            "code": "\ndata class Vec2f(var x: Float, var y: Float) {\n    inline var r: Float get() = x; set(value) { x = value }\n    inline var g: Float get() = y; set(value) { y = value }\n}\n"
        },
        {
            "code": "\n    fun createVec2fReadRG() {\n        val vec = Vec2f(1.5f, -2.5f)\n\n        assertEquals(1.5f, vec.r)\n        assertEquals(-2.5f, vec.g)\n    }\n"
        },
        {
            "code": "\nfun createVec2fWithSpecificValues() {\n        val vec = Vec2f(1.5f, -2.5f)\n\n        vec.x = 2.5f\n        vec.y = -5f\n\n        assertEquals(2.5f, vec.x)\n        assertEquals(-5f, vec.y)\n\n        vec.r = 1.25f\n        vec.g = -3f\n\n        assertEquals(1.25f, vec.x)\n        assertEquals(-3f, vec.y)\n    }\n"
        },
        {
            "code": "\nabstract class A : Collection<String> {\n    // public final foo([Ljava/lang/Object;)[Ljava/lang/Object;\n    protected fun <T> foo(x: Array<T>): Array<T> = x // \n}\n"
        },
        {
            "code": "\ninterface GeoJson{\n    val type:String\n    val coordinates:Array<*>\n    \n    fun asPoint() = Point(coordinates as Array<Double>)\n}\ndata class Point(val coordinates:Array<Double>)   \n\nfun main(args: Array<String>) {        \n    val json = \"\"\"{\"type\":\"Point\", \"coordinates\":[1.0, 2.0]}\"\"\"  \n    val obj = JSON.parse<GeoJson>(json).asPoint()        \n    println(\"${obj.coordinates}\")\n}\n"
        },
        {
            "code": "\nfun justRenderTasks(maxIterations: Int = 1500,\n                      chunk: Int = 100,\n                      isActive: () -> Boolean = { true },\n                      image: FractalImage,\n                      area: Rect<Double>): Sequence<MandelbrotRenderTask> {\n\n    val t = Transformation(image.pixelRect, area)\n    val picker = ColorPicker(maxIterations)\n\n    return buildSequence {\n      t.forEachPixel(isActive) { p, c ->\n        yield(p to c)\n      }\n    }.chunked(chunk).map { tasks ->\n      {\n        tasks.forEach { (p, c) ->\n          val pt = MandelbrotPointIteration(c)\n                  .asSequence()\n                  .take(maxIterations)\n                  .last()\n\n          image.putPixel(p, picker.selectColour(pt))\n        }\n      }\n    }\n  }\n"
        },
        {
            "code": "\noperator fun ByteArray.set(i: Int, v: Int) {\n    println(\"operator set invoked\")\n}\n\nfun main(args: Array<String>) {\n    val b = ByteArray(1)\n    val v = 1 // Int type\n    b[0] = v // this line resolves to operator set, which can be seen in IDEA\n    println(\"Done\")\n}\n"
        },
        {
            "code": "\nclass A {\n    operator fun set(\n            i1: Int,\n            i2: Int = 1,\n            v: Int\n    ) {\n        println(i2)\n    }\n}\n\nfun main(args: Array<String>) {\n    A()[1] = 1 // prints \"0\", expected \"1\"\n}\n\n"
        },
        {
            "code": "\nclass Test() {\n    suspend operator fun get(i: Int): Int = i\n}\n\nfun main(args: Array<String>) {\n    async {\n        println(\"Started\")\n        val t = Test()\n        println(\"Got: ${t[42]}\")\n    }.get()\n}\n"
        },
        {
            "code": "\nclass Test() {\n    suspend operator fun set(i: Int, value: String) {\n        println(\"set[$i] = $value\")\n    }\n}\n\nfun main(args: Array<String>) {\n    async {\n        println(\"Started\")\n        val t = Test()\n        t[42] = \"The Answer!\"\n    }.get()\n}\n"
        },
        {
            "code": "\nsuspend fun foo() = 1\nsuspend fun bar(x: Int = foo()) {} // Error: unsupported\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.Continuation\nimport kotlin.coroutines.experimental.EmptyCoroutineContext\nimport kotlin.coroutines.experimental.startCoroutine\n\nclass A {\n    operator suspend fun contains(y: String): Boolean = true\n}\n\nsuspend fun foo(x: A) {\n    println(\"\" !in x)\n}\n\nfun builder(x: suspend () -> Unit) {\n    x.startCoroutine(object: Continuation<Unit> {\n        override fun resume(value: Unit) {\n\n        }\n\n        override fun resumeWithException(exception: Throwable) {\n            throw exception\n        }\n\n        override val context get() = EmptyCoroutineContext\n    })\n}\n\nfun main(args: Array<String>) {\n    builder {\n        foo(A())\n    }\n}\n\n"
        },
        {
            "code": "\nprivate suspend fun awaitMap(): GoogleMap? {\n    return (mapFragment as? SupportMapFragment)?.awaitMap() \n}\n"
        },
        {
            "code": "\nprivate suspend fun awaitMap(): GoogleMap? {\n    val mapFragment = mapFragment as? SupportMapFragment ?: return null\n    return mapFragment.awaitMap()\n}\n"
        },
        {
            "code": "\nclass TestTest {\n    abstract class Point {\n        abstract val x: Double\n        abstract val y: Double\n    }\n\n    data class PointImpl(override val x: Double, override val y: Double) : Point()\n\n    interface PointConsumer<T : Point> {\n        var point: T\n        fun consumePoint(point: T)\n        fun transformPoint(point: T): Point\n    }\n\n    class PointConsumerImpl : PointConsumer<PointImpl> {\n        override var point: PointImpl = PointImpl(1.0, 2.0)\n\n        override fun consumePoint(point: PointImpl) {\n            TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n        }\n\n        override fun transformPoint(point: PointImpl): Point {\n            TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n        }\n    }\n}\n"
        },
        {
            "code": "\nexpect class Foo {\n  val foo: Int\n  fun bar(f: Int = foo): Int\n}\n"
        },
        {
            "code": "\nactual class Foo {\n  actual val foo: Int = 1\n  actual fun bar(f: Int) = 1\n}\n"
        },
        {
            "code": "\npackage test\n\nval x by J().getDelegate()\n\nfun main(args: Array<String>) {\n    println(x)\n}\n"
        },
        {
            "code": "\npackage test\n\nval x by J()\n\nfun main(args: Array<String>) {\n    println(x)\n}\n"
        },
        {
            "code": "\npackage some.pack\n\ninline infix operator fun <T> Int.times(block: () -> T) =\n\tif (this < 0)\n\t\tthrow IllegalArgumentException(\"Cannot repeat negative times, use 0 or greater\")\n\telse\n\t\t(1..this).map { block() }\n"
        },
        {
            "code": "\npackage some.pack\n\nimport org.hamcrest.Matchers.empty\nimport org.junit.Assert.assertThat\nimport org.junit.jupiter.api.Test\n\nclass SomethingTest {\n\n\t@Test fun repeatNegativeTimes() {\n\t\tval repeated = -3 * { 1 }\n\n\t\tassertThat(repeated, empty())\n\t}\n}\n"
        },
        {
            "code": "\nfun String.test(): String {\n  return this\n}\n\nobject Foo {\n  fun bar() {\n    \"hi\".test()\n  }\n}\n"
        },
        {
            "code": "\ninternal expect annotation class JvmOverloads\n\nclass Foo constructor(val s: String = \"\")\n"
        },
        {
            "code": "\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\ninternal actual typealias JvmOverloads = kotlin.jvm.JvmOverloads\n\nclass JvmFoo constructor(val s: String = \"\")\n\n"
        },
        {
            "code": "\nexternal interface Foo {\n    var externalProperty: String?\n        get() = definedExternally\n        set(it) = definedExternally\n}\n\ninterface Bar : Foo\n\nclass DDD : Foo {\n\n}\n"
        },
        {
            "code": "\nexternal interface Foo {\n    var externalProperty: String?\n        get() = definedExternally\n        set(it) = definedExternally\n}\n\ninterface Bar : Foo\n\nclass DDD : Bar {\n\n}\n"
        },
        {
            "code": "\nprivate const val DAY = 24 * 60 * 60 * 1000L\nfun main(args: Array<String>) { println(1L > DAY) }\n"
        },
        {
            "code": "\npackage test\n\nfun main(args: Array<String>) {\n    console.info(testFunction());\n}\n\nfun testFunction() : Int {\n    return 10\n}\n"
        },
        {
            "code": "\ninline class NnFoo(val s: String)\ninline class NullableFoo(val s: String?)\n\nfun test(f: NnFoo?) {} // -> String\nfun test(f: NullableFoo?) // -> NullableFoo\n"
        },
        {
            "code": "\nabstract class WorkingMap<K, V> : Map<K, V> {\n  abstract override fun get(key: K): V?\n}\nabstract class BrokenMap<K, V> : Map<K, V>\n"
        },
        {
            "code": "\n\"\" + System.currentTimeMillis()\n"
        },
        {
            "code": "\nfun bar(): String {\n    val foo = 1\n    return \"${foo}bar\"\n}\n"
        },
        {
            "code": "\na.append(x1).append(x2).append(x3)\n"
        },
        {
            "code": "\nsb.append(s1).append(s2).append(s3)\n"
        },
        {
            "code": "\nsb.append(s1)\nsb.append(s2)\nsb.append(s3)\n"
        },
        {
            "code": "\nvar str = \"var1: $var1 \" +\n        \"var2: $var2 \" +\n        \"var3: $var3 \"\n"
        },
        {
            "code": "\nclass A{\n    fun foo(): String = \"$this\" + \"test: $this\"\n}\n"
        },
        {
            "code": "\nA.prototype.foo = function () {\n    return this.toString() + ('test: ' + this);\n  };\n"
        },
        {
            "code": "\nval zero = object : Function0<Int> {\n    override fun invoke(): Int = 0\n}\n\nfun main(args: Array<String>) {\n    println(zero())\n}\n"
        },
        {
            "code": "\nclass Number(val n: Int) : Function0<Int> {\n    override fun invoke(): Int = n\n}\n\nfun numberAsFunction0(n: Int): Function0<Int> = Number(n)\n\nfun main(args: Array<String>) {\n    // works\n    println(Number(1)()) \n    \n    // crashes\n    println(numberAsFunction0(2)()) \n}\n"
        },
        {
            "code": "\nclass TaggedFunction1<T, R>(val tag: String, val f: (T) -> R): (T) -> R by f\n"
        },
        {
            "code": "\nvar deadline = 10\n\ntailrec fun recursionTest() {\n    if (deadline-- == 0) return\n\n    run {\n        println(\"$deadline\")\n        return recursionTest()\n    }\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.experimental.delay\nimport kotlinx.coroutines.experimental.launch\nimport kotlinx.coroutines.experimental.runBlocking\nimport java.util.*\nimport kotlin.concurrent.schedule\n\nclass Test {\n    fun scheduleTimeout() {\n        Timer(true).schedule(300) {\n            launch {\n                runSuspended(\"hello\")\n            }\n        }\n    }\n\n    suspend fun runSuspended(txt: String) = println(txt)\n}\n\nfun main(args: Array<String>) {\n    Test().scheduleTimeout()\n    runBlocking {\n        delay(10000)\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.concurrent.thread\n\nclass VerifierCrash {\n    init {\n        runOnThread {\n            builder { suspending() }\n        }\n    }\n\n    fun builder(block: suspend () -> Unit) {} /* body does not matter */\n    suspend fun suspending() {} /* body does not matter */\n\n    inline fun runOnThread(crossinline action: () -> Unit) {\n        /* double cross-inline */\n        thread { action() }\n    }\n\n}\n\nfun main(args: Array<String>) {\n    VerifierCrash()\n}\n"
        },
        {
            "code": "\nimport java.io.File\nimport java.io.FileReader\n\nfun main(args: Array<String>) {\n    var file = File(\"removeMe\").apply { createNewFile(); deleteOnExit() }\n    var pop = Array(28, { DoubleArray(32) })\n    val toRz = {\n        synchronized(file) {\n            FileReader(file.path).use { df ->\n                for ((popIdx, paramSet) in pop.withIndex()) {\n                    println(\"foo!\")\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\nopen class A {\n    open fun foo(x: Int = 42) {\n        throw AssertionError()\n    }\n}\n\nclass B : A() {\n    @JvmOverloads\n    override fun foo(x: Int) {\n        if (x != 42) throw AssertionError(x.toString())\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n\n    while (true) {}\n\n}\n"
        },
        {
            "code": "\n//For Simple\ninline fun <T> inlineFunction(crossinline function: () -> T): T = function()\n\n//For Simple\nfun <T> notInlineFunction(function: () -> T): T = function()\n\nfun testFunction(value: Boolean) {\n    inlineFunction {\n        notInlineFunction {\n            if (value) {\n                notInlineFunction {\n                    // this Lambda unresolved references\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    Pair(1.0,2.0).first.equals(2.0)\n}\n"
        },
        {
            "code": "\nclass `A)V`\nfun fails(x: String) {\n    `Â¯|_(ã)_|Â¯`(x, `A)V`())\n}\nfun `Â¯|_(ã)_|Â¯`(x: String, i: `A)V`): `A)V` {\n    System.err.println(x)\n    return i\n}\n"
        },
        {
            "code": "\npackage test\n\nclass In<in I>\n\nfun <S> select(x: S, y: S): S = x\n\nfun <T> foo(a: Array<In<T>>, b: Array<In<String>>) =\n        select(a, b)[0].ofType(true)\n\n\ninline fun <reified K> In<K>.ofType(y: Any?) =\n        y is K\n\nfun main(args: Array<String>) {\n    val a1 = arrayOf(In<Int>())\n    val a2 = arrayOf(In<String>())\n    println(foo(a1, a2))\n}\n"
        },
        {
            "code": "\nexpect open class C() {\n    open fun f(p: Int = 1)\n}\n\nfun main(args: Array<String>) {\n    C().f()\n}\n"
        },
        {
            "code": "\nactual open class C {\n    actual open fun f(p: Int) {\n        println(p)\n    }\n}\n"
        },
        {
            "code": "\ninterface News {\n    val dateTime: DateTime\n}\n\n@Serializable\ndata class Article(\n        val id: Int,\n        val data: ArticleData,\n        override val dateTime: DateTime = data.occurrence\n): News\n\n@Serializable\ndata class ArticleData(\n        val title: String,\n        val subtitle: String,\n        val imageUrl: String,\n        val url: String?,\n        val occurrence: DateTime\n)\n\n@Serializable\ndata class Info(\n        val id: Int,\n        val data: InfoData,\n        override val dateTime: DateTime,\n        val accepted: Boolean\n) : News\n\n@Serializable\ndata class InfoData(\n        val title: String,\n        val imageUrl: String,\n        val description: String,\n        val sources: String,\n        val url: String?,\n        val author: String?,\n        val authorUrl: String?\n)\n\n@Serializable\ndata class Puzzler(\n        val id: Int,\n        val data: PuzzlerData,\n        override val dateTime: DateTime,\n        val accepted: Boolean\n) : News\n\n@Serializable\ndata class PuzzlerData(\n        val title: String,\n        val level: String?,\n        val question: String,\n        val answers: String,\n        val correctAnswer: String,\n        val explanation: String,\n        val author: String?,\n        val authorUrl: String?\n)\n"
        },
        {
            "code": "\nfun NewsData.allNews(): List<News> = articles + infos + puzzlers\n\nval news = newsData.allNews().sortedByDescending { it.dateTime }\n"
        },
        {
            "code": "\nnews.filterIsInstance<Article>() // Always returns nothing\nnews.filterIsInstance<Info>() // Always returns nothing\nnews.filterIsInstance<Puzzler>() // Always returns nothing\nfor (n in news) {\n    when(n) {\n        is Article -> {} // This is never true\n        is Info -> {} // This is never true\n        is Puzzler -> {} // This is never true\n        else -> {} // This is always true\n    }\n}\n"
        },
        {
            "code": "\noverride suspend fun getNewsData(): NewsData {\n    val str = httpGet(Endpoints.news)\n    val parsed = json.parse<NewsData>(str)\n    val articles = parsed.articles.map { Article(it.id, ArticleData(it.data.title, it.data.subtitle, it.data.imageUrl, it.data.url, it.data.occurrence), it.dateTime) }\n    val infos = parsed.infos.map { Info(it.id, InfoData(it.data.title, it.data.imageUrl, it.data.description, it.data.sources, it.data.url, it.data.author, it.data.authorUrl), it.dateTime, it.accepted) }\n    val puzzlers = parsed.puzzlers.map { Puzzler(it.id, PuzzlerData(it.data.title, it.data.level, it.data.question, it.data.answers, it.data.correctAnswer, it.data.explanation, it.data.author, it.data.authorUrl), it.dateTime, it.accepted) }\n    val newsData = NewsData(articles, infos, puzzlers)\n    return newsData\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.experimental.delay\nimport kotlinx.coroutines.experimental.launch\nimport kotlinx.coroutines.experimental.runBlocking\nimport java.util.concurrent.TimeUnit\nimport kotlin.coroutines.experimental.coroutineContext\n\nfun main(vararg args: String) {\n    runBlocking {\n        val delay = delayJob(5)\n        delay.join()\n    }\n}\n\nsuspend fun delayJob(time: Long, unit: TimeUnit = TimeUnit.MILLISECONDS) =\n        launch(coroutineContext) { delay(time, unit) }\n"
        },
        {
            "code": "\n    public fun dequeue(): Int {\n        head.loop { curHead ->\n            val next = curHead.next.value ?: return -1\n            if (head.compareAndSet(curHead, next)) return next.value\n        }\n    }\n"
        },
        {
            "code": "\npublic inline fun <T> AtomicRef<T>.loop(action: (T) -> Unit): Nothing {\n    while (true) {\n        action(value)\n    }\n}\n"
        },
        {
            "code": "\npackage lateinitInCompanionObject\n\nclass Test {\n    companion object {\n        lateinit var buggy: Collection<Int>\n        fun access(): Boolean = this::buggy.isInitialized\n    }\n}\n\nfun main(args: Array<String>) {\n    Test.access()\n}\n"
        },
        {
            "code": "\nfun bar(args: Collection<String>) {\n    args.sortedByDescending { it.length }\n}\n"
        },
        {
            "code": "\nfun main() {\n    foo { it.length }\n    bar { it.size }\n}\n\ninline fun foo(crossinline f: (String) -> Unit) {\n    bar { f(it[0]) }\n}\n\nfun bar(f: (Array<String>) -> Unit) {}\n"
        },
        {
            "code": "\n    val pipe = BroadcastChannel<Int>(Channel.CONFLATED)\n\n    var mode by Delegates.observable(0) { _, _, value -> runBlocking { pipe.send(value) } }\n\n    @Test\n    fun test_observable_conflated_channel() {\n        mode = 1\n    }\n"
        },
        {
            "code": "\npackage foo\n\ninterface Map<K>\n\nclass C\n"
        },
        {
            "code": "\npackage bar\n\nimport foo.*\n\nfun boo(m: Map<Int, String>) {\n  C()\n}\n"
        },
        {
            "code": "\ninline fun toInline(a: String, b: Int, c: Boolean) : String {\n    return \"hi\"\n}\n\nfun caller() {\n    toInline(\"a\", 2, true)\n}\n"
        },
        {
            "code": "\nclass DelegatedPropertyMap(val map: HashMap<String, String>) {\n    var demo by map\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n\tval i = 1000 * 2\n\tprintln(i)\n\t\n\tval j = 1000.double()\n\tprintln(i)\n}\n\nprivate inline fun Int.double() = this * 2\n"
        },
        {
            "code": "\nfun test() {\n    Foo.print()\n    Bar.print()\n}\n\nclass Foo {\n    companion object {\n        inline fun print() {\n            println(\"Foo:print()\")\n        }\n    }\n}\n\nobject Bar {\n    inline fun print() {\n        println(\"Bar:print()\")\n    }\n}\n"
        },
        {
            "code": "\nclass X {\n    val result: String\n        inline get() = \"OK\"\n\n    fun x() {\n        ::result\n    }\n}\n"
        },
        {
            "code": "\npackage pkg1\n\ninternal class Internals {\n    private fun pvt(limit: Int = 0) {\n    }\n\n    internal inline fun failing() {\n        pvt()\n    }\n\n    internal inline fun working() {\n        pvt(0)\n    }\n}\n"
        },
        {
            "code": "\npackage pkg2\n\nimport pkg1.*\n\nfun main(args: Array<String>) {\n    val o = Internals()\n    o.failing()\n    o.working()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    createRunnable {\n        object : Runnable {\n            override fun run() {\n                println(SomeClass(\"hello\")) // NoSuchMethodError: RunMeKt$main$1$1$SomeClass.<init>(LRunMeKt$main$$inlined$createRunnable$1$lambda$1;Ljava/lang/String;)V\n            }\n\n            inner class SomeClass(var prop: String)\n        }.run()\n    }.run()\n}\n\ninline fun createRunnable(crossinline code: ()->Unit): Runnable = object : Runnable {\n    override fun run() = code()\n}\n"
        },
        {
            "code": "\npublic fun <E, R> ReceiveChannel<E>.flatMap(context: CoroutineContext = Unconfined, transform: suspend (E) -> ReceiveChannel<R>): ReceiveChannel<R> =\n        produce(context) {\n            consumeEach {\n                transform(it).consumeEach {\n                    send(it)\n                }\n            }\n        }\n"
        },
        {
            "code": "\nfun <E, R> foo(c: ReceiveChannel<Any>): ReceiveChannel<R> =\n        produce(Unconfined) {\n            for (element in c) {\n                for (e2 in c) {\n                    send(null as R)\n                }\n            }\n        }\n"
        },
        {
            "code": "\nclass CompilerKillingIterator<T, out R>(private val underlying: Iterator<T>, private val transform: suspend (e: T) -> Iterator<R>) {\n    private var currentIt: Iterator<R> = null!!\n\n    suspend tailrec fun next(): R {\n        return if (currentIt.hasNext()) {\n            currentIt.next()\n        } else if (underlying.hasNext()) {\n            currentIt = transform(underlying.next())\n            next()\n        } else {\n            throw IllegalArgumentException(\"Cannot call next() on the empty iterator\")\n        }\n    }\n}\n"
        },
        {
            "code": "\npackage xyz.nulldev\nclass Huh {\n    private interface UriFilter\n\n    open class Filter<V>(val name: String, val state: V) {\n        open class CheckBox(name: String, defValue: Boolean): Filter<Boolean>(name, defValue)\n        open class Select<V>(name: String, state: Array<V>): Filter<Array<V>>(name, state)\n        open class Group<V>(name: String, state: List<V>): Filter<List<V>>(name, state)\n    }\n\n    class AdvancedOption(name: String, defValue: Boolean = false): Filter.CheckBox(name, defValue), UriFilter\n    class RatingOption : Filter.Select<String>(\"\", arrayOf(\"\")), UriFilter\n    class AdvancedGroup : Filter.Group<Filter<*>>(\"\", listOf(\n            AdvancedOption(\"\", true),\n            AdvancedOption(\"\", true),\n            AdvancedOption(\"\"),\n            AdvancedOption(\"\"),\n            AdvancedOption(\"\"),\n            AdvancedOption(\"\"),\n            AdvancedOption(\"\"),\n            AdvancedOption(\"\"),\n            RatingOption()\n    ))\n\n    companion object {\n        @JvmStatic fun main(args: Array<String>) {\n            val test = Huh.AdvancedGroup()\n            println(test.name)\n            println(test.state)\n        }\n    }\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.experimental.*\n\ninterface Consumer { fun consume(s: String) }\n\ninline fun crossInlineBuilder(crossinline block: (String) -> Unit) = object : Consumer {\n    override fun consume(s: String) {\n        block(s)\n    }\n}\n\nclass Container {\n    var y: String = \"\"\n\n    val consumer = crossInlineBuilder { s ->\n        launch(Unconfined) {\n            y = s\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    Container().consumer.consume(\"Test\")\n}\n"
        },
        {
            "code": "\n// TODO: muted automatically, investigate should it be ran for JS or not\n"
        },
        {
            "code": "\nimport Foo.x\n\nobject Foo {\n    var x = 5\n}\n\nfun main(args: Array<String>) {\n    ++x // or x += 1\n}\n"
        },
        {
            "code": "\nclass A(val p: String) {\n    var pp = \"\"\n}\n\noperator fun A.plusAssign(s: String) {\n    pp = s\n}\n\nfun main(args: Array<String>) {\n    \"rrr\".let { A(it) } += \"aaa\"\n}\n"
        },
        {
            "code": "\nfor (i in 0..MAX) {\n     myView.setOnClickListener { myMethod(i) }\n}\n"
        },
        {
            "code": "\n@ModelAttribute(\"user\")\nfun modelAttribute(id: Long? = 0) = when (id) {\n        null, 0L -> User()\n        else -> repository.findById(id).get()\n}\n"
        },
        {
            "code": "\nclass Person(val age: Int)\n\nfun main(args: Array<String>) {\n    println(Person::age.name)\n    printNameOf(Person::age)\n}\n\ninline fun printNameOf(property: KProperty1<*,*>) = println(property.name)\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val name = \"John\"\n    val additionalName = \" Doe\"\n\n    println(\"${name}${additionalName}\")\n}\n"
        },
        {
            "code": "\n    val code = Integer(11)\n    val c = code.toChar()\n"
        },
        {
            "code": "\nclass X {\n    suspend fun execute() {\n        a()\n        b()\n    }\n\n    private suspend fun a() {}\n    private suspend fun b() {}\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(Charsets.UTF_8)\n}\n"
        },
        {
            "code": "\nimport java.util.HashSet\n\nfun test(os: Set<Int>) {\n    val res = HashSet<Int>()\n    os.contains(\"\")\n    res.contains(\"\")\n}\n"
        },
        {
            "code": "\npackage ktor_receivedMessage\n\nimport kotlin.coroutines.experimental.Continuation\nimport kotlin.coroutines.experimental.CoroutineContext\nimport kotlin.coroutines.experimental.EmptyCoroutineContext\nimport kotlin.coroutines.experimental.startCoroutine\n\nprivate var prevSender: String = \"FAIL\"\n\nclass ChatServer {\n    suspend fun who(sender: String) {\n        prevSender = sender\n    }\n    suspend fun sendTo(recipient: String, sender: String, message: String) { }\n    suspend fun memberRenamed(member: String, to: String) { }\n    suspend fun help(sender: String) { }\n    suspend fun message(sender: String, message: String) { }\n}\n\nprivate val server = ChatServer()\n\nprivate suspend fun receivedMessage(id: String, command: String) {\n    when {\n        command.startsWith(\"/who\") -> server.who(id)\n        command.startsWith(\"/user\") -> {\n            val newName = command.removePrefix(\"/user\").trim()\n            when {\n                newName.isEmpty() -> server.sendTo(id, \"server::help\", \"/user [newName]\")\n                newName.length > 50 -> server.sendTo(id, \"server::help\", \"new name is too long: 50 characters limit\")\n                else -> server.memberRenamed(id, newName)\n            }\n        }\n        command.startsWith(\"/help\") -> server.help(id)\n        command.startsWith(\"/\") -> server.sendTo(id, \"server::help\", \"Unknown command ${command.takeWhile { !it.isWhitespace() }}\")\n        else -> server.message(id, command)\n    }\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(object : Continuation<Unit>{\n        override val context: CoroutineContext\n            get() = EmptyCoroutineContext\n\n        override fun resume(value: Unit) {\n        }\n\n        override fun resumeWithException(exception: Throwable) {\n            throw exception\n        }\n    })\n}\n\nfun main(args: Array<String>) {\n    builder {\n        receivedMessage(\"OK\", \"/who\")\n    }\n    println(prevSender)\n}\n"
        },
        {
            "code": "\ninline fun schedule(runner: suspend () -> Unit) { // ERROR\n    launch(CommonPool) {\n        runner()\n    }\n}\n"
        },
        {
            "code": "\ninline fun schedule(crossinline runner: suspend () -> Unit)  {\n    launch(CommonPool) {\n        runner()\n    }\n}\n"
        },
        {
            "code": "\n    val a = listOf(0.0, Double.NaN, 0.0, -0.0, 2.0, Double.NaN, 1.0, 0.0)\n    val b = a.sorted()\n    println(b)\n    println(b.map { 1 / it })\n"
        },
        {
            "code": "\n[0, 0, 0, 0, 1, 2, NaN, NaN]\n[-Infinity, Infinity, Infinity, Infinity, 1, 0.5, NaN, NaN]\n"
        },
        {
            "code": "\n[0, NaN, 0, 0, 2, NaN, 0, 1]\n[Infinity, NaN, Infinity, -Infinity, 0.5, NaN, Infinity, 1]\n"
        },
        {
            "code": "\nclass Foo {\n    companion object {\n        private val bar = \"\"\n    }\n\n    fun hello() {\n        println(bar)\n    }\n}\n"
        },
        {
            "code": "\nfun foo() {}\nval a = foo()\n"
        },
        {
            "code": "\nvar a = foo();\n"
        },
        {
            "code": "\nvar test = 0\n\nfun main(args: Array<String>) {\n    test++\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val x = 10\n    val y = 9\n    if(x == 6) {\n        if(y == 6) {\n            println(\"a\")\n        } else {\n            println(\"b\")\n        }\n    } else {\n        println(\"c\")\n    }\n}\n"
        },
        {
            "code": "\n//Test.kt\n\nfun main(args: Array<String>){\n  val list = listOf(1,2,3)\n  val four = list.first { it == 4 }\n  println(four)\n}\n"
        },
        {
            "code": "\nprivate val listVisitor =\n    { list: MutableList<Char>, action: (MutableList<Char>, Int) -> Unit ->\n        list.withIndex()\n            .reversed()\n            .filter { (_, c) -> c in '0'..'9' }\n            .forEach { (index, _) -> action(list, index) }\n    }\n"
        },
        {
            "code": "\nprivate val listVisitor =\n    { list: MutableList<Char>, action: (MutableList<Char>, Int) -> Unit ->\n                list.indices.reversed()\n                    .filter { list[it] in '0'..'9' }\n                    .forEach { action(list, it) }\n    }\n"
        },
        {
            "code": "\n    override fun test(name: String, ignored: Boolean, testFn: () -> Any) {\n        if (ignored or ignoredSuite) {\n            QUnit.skip(name, wrapTest(testFn))\n        }\n        else {\n            QUnit.test(name, wrapTest(testFn))\n        }\n    }\n\n    private fun wrapTest(testFn: () -> Any): (dynamic) -> Any = { assert ->\n        var assertionsHappened = false\n        assertHook = { testResult ->\n            assertionsHappened = true\n            assert.ok(testResult.result, testResult.lazyMessage())\n        }\n        val potentialPromise = testFn()\n        if (!assertionsHappened) {\n            assertTrue(true, \"A test with no assertions is considered successful\")\n        }\n        potentialPromise\n    }\n\n"
        },
        {
            "code": "\n    @Test\n    fun testPromise()=\n        promise {\n            delay(1000)\n            assertTrue(true)\n        }\n"
        },
        {
            "code": "\ndata class User(val name: String, val age: Int)\n"
        },
        {
            "code": "\nclass NeverNullMap<K, V>(private val backing: MutableMap<K, V> = mutableMapOf(), val default: () -> V): MutableMap<K, V> by backing {\n    override operator fun get(key: K): V = backing.getOrPut(key, default)\n}\n\nfun main(args: Array<String>) {\n    val myMap = NeverNullMap<String, Int> {0}\n    myMap[\"test\"] +=  10\n}\n"
        },
        {
            "code": "\nclass Test<K, V>(map: MutableMap<K, V>): MutableMap<K, V> by map\n\nfun main(args: Array<String>) {\n    val test = Test(mutableMapOf(1 to \"hello\"))\n    test[1] += \" there\"\n}\n"
        },
        {
            "code": "\nfun test(d: dynamic) {\n    new(d, 1, 2, 3)\n/// or:\n    new(d)(1, 2, 3)\n}\n"
        },
        {
            "code": "\n val discord = require(\"discord.js\")\n val client = discord.Client()\n"
        },
        {
            "code": "\n    var discord = require('discord.js');\n    var client = discord.Client();\n"
        },
        {
            "code": "\nabstract class Base {\n    abstract var value: String\n        internal set\n}\n\nclass Derived : Base() {\n    override var value = \"hello\"\n}\n"
        },
        {
            "code": "\n@Test\nfun `instance as derived`() {\n    val instance: Derived = Derived()\n\n    instance.value = \"hello\"\n}\n"
        },
        {
            "code": "\n@Test\nfun `instance as base`() {\n    val instance: Base = Derived()\n\n    instance.value = \"hello\"\n}\n"
        },
        {
            "code": "\n    enum class TestEnum {\n        TEST_1,\n        TEST_2\n    }\n\n    suspend fun suspendFun(value: TestEnum) {\n        println(value)\n    }\n\n    @Test\n    fun testFooAsync() = async {\n        val value = TestEnum.TEST_1\n        return@async when (value) {\n            TestEnum.TEST_1,\n            TestEnum.TEST_2 -> suspendFun(value)\n        }\n    }.asPromise()\n"
        },
        {
            "code": "\n  function testOr(b) {\n    return null;\n  }\n"
        },
        {
            "code": "\nclass A\n\nfun A.ext() {}\n\nclass B() {\n    fun some() {\n        A().ext()\n    }\n}\n"
        },
        {
            "code": "\nvar i = len\nwhile (i > 0) {\n    process(it)\n    i /= 2\n}\n"
        },
        {
            "code": "\ngenerateSequence(len) { it / 2 }.takeWhile { it > 0}.forEach {\n   process(it) \n}\n"
        },
        {
            "code": "\nfun main(par:Array<String>){\n\tm@ val f = {\n\t\treturn@m\t\t// NoClassDefFoundError\n\t}\n\tf()\t\t\t\t\t\n}\n"
        },
        {
            "code": "\nfun main(par:Array<String>){\n\tfun f(p:()->Unit) {p()}\n\tm@ f({return@m})\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.intrinsics.SUSPENDED_MARKER\nimport kotlin.coroutines.intrinsics.suspendCoroutineOrReturn\n\nclass A {\n    var isMinusAssignCalled = false\n    operator suspend fun minusAssign(y: String): Unit = suspendCoroutineOrReturn { x ->\n        if (y != \"56\") return@suspendCoroutineOrReturn Unit\n        isMinusAssignCalled = true\n        x.resume(Unit)\n        SUSPENDED_MARKER\n    }\n}\n\nval a = A()\n\nsuspend fun foo5() {\n    a -= \"56\"\n    if (!a.isMinusAssignCalled) throw RuntimeException(\"fail 6\")\n}\n\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.intrinsics.coroutineContext\n\nsuspend fun <T> suspendingLambda(block: suspend () -> T): T {\n  return block()\n}\n\ninline fun <T> inlinedLambda(block: () -> T): T {\n  return block()\n}\n\nsuspend fun sample() {\n  // works as expected\n  val context = coroutineContext\n  \n  // using already inlined variable\n  suspendingLambda { context } // works\n  inlinedLambda { context }    // works\n  \n  // using coroutineContext directly \n  suspendingLambda { coroutineContext } // works\n  inlinedLambda { coroutineContext }    // crashes the compiler\n}\n"
        },
        {
            "code": "\n// Run with -verbose:gc -Xmx20m\nfun main(args: Array<String>) {\n    while (true) {\n        (0..0).sumBy { it }\n    }\n}\n"
        },
        {
            "code": "\n    for (i in 0..a.size-1) {\n      sum += a[i]\n    }\n"
        },
        {
            "code": "\ninline fun f(noinline p:()->Unit) {\t\t// noinline parameter\n\tp()\n\tprintln(\"A\")\n}\nval v = {print(1)}\nfun main(par:Array<String>){\n\tf(v)\t\t\t\t\t\t\t\t// 1A - INLINED\n\tf(v)\t\t\t\t\t\t\t\t// 1A - INLINED\n}\n"
        },
        {
            "code": "\npackage example\n\nfun main(args: Array<String>) {\n    val a: SomeJavaClass<out Int> = SomeJavaClass()\n    a.someFunction { }\n}\n"
        },
        {
            "code": "\nclass Foo()\n"
        },
        {
            "code": "\nobject Foo\n\n@Deprecated(\"Do not call constructor anymore\", ReplaceWith(\"Foo\"))\n@InlineOnly\ninline fun Foo() = Foo\n"
        },
        {
            "code": "\nval array:Array<String> = arrayOf(\"1\", \"2\", \"3\")\n\nfun <T> Array<T>.getLength(): Int {\nreturn this.size\n}\n\nfun box(): String {\nif (array.getLength() != 3)\nreturn \"FAILURE\"\nreturn \"OK\"\n}\n"
        },
        {
            "code": "\ninline fun xassert(condition: Boolean, messageCallback: () -> Any = { \"Assertion failed\" }) {\n    if (!condition) {\n        throw AssertionError(messageCallback())\n    }\n}\n"
        },
        {
            "code": "\nclass A { companion object }\n"
        },
        {
            "code": "\npackage test\n\nabstract class Base(val x: Any?)\n\nclass Test {\n    companion object : Base(42)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val ctor = Test.Companion::class.java.constructors[0]\n    val companion2 = ctor.newInstance(null)\n    println(Test)\n    println(companion2)\n}\n"
        },
        {
            "code": "\nclass Foo {\n  fun run(i: Bar): Boolean {\n    return i == Bar.ONE // Use === to avoid call to Intrinsics.areEqual.\n  }\n}\n\nenum class Bar {\n  ONE\n}\n"
        },
        {
            "code": "\nopen class Derived : Base() {\n    companion object {\n        @JvmStatic val qux: String get() = \"OK\"\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(Derived.qux)\n    // Derived\n    println(DerivedJava2.getQux())\n    // INVOKESTATIC test/DerivedJava2.getQux ()Ljava/lang/Object;\n    // Base - sic!\n}\n"
        },
        {
            "code": "\nactual fun String.startsWith(s: String): Boolean {\n    return js(\"this.startsWith(s)\")\n}\n"
        },
        {
            "code": "\nactual fun String.startsWith(s: String): Boolean {\n    return js(\"arguments[0].startsWith(s)\")\n}\n"
        },
        {
            "code": "\nactual fun String.startsWith(s: String): Boolean {\n    return this.startsWith(s, ignoreCase = false)\n}\n"
        },
        {
            "code": "\nclass MainWindow : Initializable {\n    @FXML\n    var logBox: TextArea? = null\n\n    init {\n    }\n\n    override fun initialize(location: URL?, resources: ResourceBundle?) {\n        Tooler.mainWindow = this\n    }\n\n    fun log(msg: String) {\n        this.logBox?.text += msg + \"\\n\"\n    }\n}\n"
        },
        {
            "code": "\nimport java.util.Objects\n\nfun main(args: Array<String>) {\n    defineFunc<String>()\n\n    func(1)\n}\n\nvar func: (Any) -> Unit = {}\n\ninline fun <reified T> defineFunc() {\n    func = {\n        val nullable = it as? T\n\n        if (nullable == null)\n            println(\"== catched it\")\n\n        if (Objects.equals(nullable, null))\n            println(\"objects equals catched it\")\n    }\n}\n"
        },
        {
            "code": "\ninline fun <reified T: Number> function() {\n    (\"\" as? T)?.let { throw IllegalStateException(\"never thrown\") }\n    \n    val lambda = { arg: Any ->\n        (arg as? T)?.let { throw IllegalStateException(\"blows up, but shouldn't\") }\n    }\n    \n    lambda(\"\")\n}\n\nfun main(args: Array<String>) {\n    function<Float>()\n}\n"
        },
        {
            "code": "\nimport org.w3c.dom.EventSource\nimport org.w3c.dom.MessageEvent\nimport org.w3c.dom.events.Event\n\nimport kotlin.browser.document\nimport kotlin.browser.window\n\nfun main(args: Array<String>) {\n    window.onload = {\n        val eventSource = EventSource(\"/api/users\")\n        val onMessage: (Event) -> dynamic = {\n            val user = JSON.parse<User>((it as MessageEvent).data as String)\n            var li = document.createElement(\"li\")\n            li.innerHTML = \"User: \" + user.firstName + \" \" + user.lastName\n            document.getElementById(\"users\")!!.appendChild(li)\n        }\n        eventSource.onmessage = onMessage\n    }\n}\n\ndata class User(val firstName: String, val lastName: String)\n"
        },
        {
            "code": "\ninterface HasIncluded {\n    @JsonProperty(\"included\")\n    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n    fun getIncluded(): List<Any> {\n        return listOf()\n    }\n}\n"
        },
        {
            "code": "\npackage cg\n\nimport java.util.concurrent.Callable\n\nclass A {\n    fun f() {\n        listOf(1, 2, 3).forEach {\n            accept(object : Callable<Unit> {\n                override fun call() {\n                    if (Math.random() > 1) {\n                        println(\"ok\")\n                    } else {\n                        try {\n                            x()\n                        } catch(t: Throwable) {\n                        }\n                    }\n                }\n            })\n        }\n    }\n\n    private fun x() {}\n}\n\nfun accept(runnable: Callable<*>) {\n    runnable.call()\n}\n"
        },
        {
            "code": "\nfun foo() {\n    annotation class A\n    typealias T = A;\n    annotation class B(val x : T)\n}\n"
        },
        {
            "code": "\ntypealias Exception = java.lang.Exception\n\nfun main(args: Array<String>) {\n    throw Exception // should be a compilation error\n//    ACONST_NULL\n//    ATHROW\n}\n"
        },
        {
            "code": "\nabstract class C {\n\n    protected abstract fun ready(): Boolean\n    protected abstract suspend fun slow()\n\n    suspend fun optimized() {\n        if (!ready()) {\n            return slow()\n        }\n    }\n\n    suspend fun nonOptimized() {\n        when {\n            ready() -> {}\n            else -> slow()\n        }\n    }\n}\n"
        },
        {
            "code": "\nabstract class C {\n\n    protected abstract fun ready(): Boolean\n    protected abstract suspend fun slow()\n\n    suspend fun notOptimized1() {\n        if (ready()) {\n            return\n        } else {\n            slow()\n        }\n    }\n\n    suspend fun notOptimized2() {\n        if (ready()) {\n            return\n        }\n\n        slow()\n    }\n\n    suspend fun optimized() {\n        if (ready()) {\n            return\n        }\n\n        return slow() // notice return\n    }\n}\n"
        },
        {
            "code": "\n    for ((i, c) in cs.withIndex()) {\n        use(i, c)\n    }\n"
        },
        {
            "code": "\n    val i = 0\n    val tmp_cs = cs\n    while (i < cs.length()) {\n        val c = tmp_cs[i]\n        use(i, c)\n        ++i\n    }\n"
        },
        {
            "code": "\nfor (index in charSeq.indices) {\n  // should be equivalent to for (index in 0 until charSeq.length)\n}\n"
        },
        {
            "code": "\n// WITH_RUNTIME\n\nfun testUnoptimized(): String {\n    var arr = intArrayOf(1, 2, 3, 4)\n    val sb = StringBuilder()\n    val ixs = arr.withIndex()\n    for ((i, x) in ixs) {\n        sb.append(\"$i:$x;\")\n        arr = intArrayOf(10, 20)\n    }\n    return sb.toString()\n}\n\nfun box(): String {\n    val tn = testUnoptimized()\n\n    var arr = intArrayOf(1, 2, 3, 4)\n    val sb = StringBuilder()\n    for ((i, x) in arr.withIndex()) {\n        sb.append(\"$i:$x;\")\n        arr = intArrayOf(10, 20)\n    }\n\n    val s = sb.toString()\n    if (s != \"0:1;1:2;2:3;3:4;\") return \"Fail: '$s'; unoptimized: '$tn'\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "\noverride fun read(position: Long, buffer: ByteArray, offset: Int, len: Int): Int {\n\tcheckPosition(position)\n\tif (position !in 0 until length) return 0\n\tval end = min(this.length, position + len)\n\tval actualLen = max((end - position).toInt(), 0)\n\tarraycopy(this.data.data, position.toInt(), buffer, offset, actualLen)\n\treturn actualLen\n}\n"
        },
        {
            "code": "\nany as Array<in SomeType>\n"
        },
        {
            "code": "\nfun main(args : Array<String>) {\n    val x : Array<Array<*>> = array()\n    val y : Array<in Array<String>> = x\n    println(y.size())\n}\n"
        },
        {
            "code": "\nfun test(a: Boolean, b: Boolean, c: Boolean): Boolean {\n    return a      // line 42\n            && b  // line 43\n            && c  // line 44\n}\n"
        },
        {
            "code": "\n@Test\nfun `my test`() {\n  class Foo // no error with this class alone\n  class Bar(foo: Foo)\n}\n"
        },
        {
            "code": "\nclass ð» \noperator fun ð».times(that: ð»): ð» = ð»()\n"
        },
        {
            "code": "\nval strings = ArrayList<String>()\n\ninline fun String.onlyForNotNull() {\n    strings.add(this)\n}\n\nfun platformString() {\n    System.getProperty(\"unknown\").onlyForNotNull()\n}\n"
        },
        {
            "code": "\ninline fun String.onlyForNotNull(): Int {\n    println(\"precondition check passed\")\n    return this.length\n}\n"
        },
        {
            "code": "\nfun platformString() {\n    System.getProperty(\"unknown\").onlyForNotNull()\n}\n"
        },
        {
            "code": "\nfun function(format: String, vararg args: Any?) = format.format(*args)\n"
        },
        {
            "code": "\nsuspend fun some() {}\n\nsuspend fun test() {\n    try {\n        some()\n    } finally {\n        some()\n    }\n}\n"
        },
        {
            "code": "\ninterface I {\n    fun foo()\n}\n\ninline fun bar(crossinline block: () -> Unit) {\n    object : I {\n        override fun foo() {\n            block()\n        }\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.KClass\n\ninline fun foo(crossinline f: () -> Unit = {}): KClass<*> {\n    val a = object {\n        val a: Any? = f()\n    }\n    return a::class\n}\n\nfun test1() = foo()\nfun test2() = foo()\n\nfun main(args: Array<String>) {\n    println(test1())\n    println(test2())\n\n    println(test1() === test2())\n    println(test1() === test1())\n}\n"
        },
        {
            "code": "\nsuspend fun test(onFail: suspend () -> Unit) {\n  return onFail()\n  return onFail()\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.*\n\nsuspend fun suspendThere(v: A): A = suspendCoroutineOrReturn { x ->\n    x.resume(v)\n    COROUTINE_SUSPENDED\n}\n\nclass A(val value: String) {\n    operator suspend fun plus(other: A) = suspendThere(A(value + other.value))\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(object: Continuation<Unit> {\n        override val context: CoroutineContext\n            get() = TODO(\"not implemented\") //To change initializer of created properties use File | Settings | File Templates.\n\n        override fun resume(value: Unit) {\n            TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n        }\n\n        override fun resumeWithException(exception: Throwable) {\n            TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n        }\n    })\n}\n\n\nfun box(): String {\n    var a = A(\"O\")\n\n    builder {\n        a += A(\"K\")\n    }\n\n    return a.value\n}\n\n"
        },
        {
            "code": "\nsuspend fun firstFun() {}\nsuspend fun secondFun() {  firstFun() }\n"
        },
        {
            "code": "\nsuspend fun secondFun() {  return firstFun() }\n"
        },
        {
            "code": "\nsuspend fun f(): String = suspendCoroutine { continuation ->\n    Thread {\n        continuation.resumeWithException(Exception())\n    }.start()\n}\n\nsuspend fun nonTail(): String {\n    try {\n        return f()\n    } catch (e: Exception) {\n        return \"\"\n    }\n}\n\nfun main(args: Array<String>) {\n    runBlocking {\n        nonTail()\n    }\n}\n"
        },
        {
            "code": "\nvar p: Int = 5846814\nprivate suspend fun optimized() {\n    val c = { c: Continuation<Unit> ->\n        if (p > 52158) Unit else COROUTINE_SUSPENDED\n    }\n\n    return suspendCoroutineOrReturn(c)\n}\n\nprivate suspend fun nonOptimized() {\n    return suspendCoroutineOrReturn { c ->\n        if (p > 52158) Unit else COROUTINE_SUSPENDED\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\n\nclass Foo {\n    @Test\n    fun simple() {\n        assertEquals(1, 2)\n    }\n\n    class Bar {\n        @Test\n        fun simple() {\n            assertEquals(1, 2)\n        }\n    }\n}\n"
        },
        {
            "code": "\nprivate lateinit var file: File\n\nfun main(args: Array<String>) {\n\tif (!::file.isInitialized) {\n\t\tprintln(\"not initialized\")\n\t}\n}\n"
        },
        {
            "code": "\ninline fun ifNotNull(a: Any?) {\n    if (a != null) {\n        println(\"not null\")\n    }\n}\n\nfun test() {\n    val a: String = System.getProperty(\"zzz\")\n    ifNotNull(a)\n}\n"
        },
        {
            "code": "\nimport android.support.design.widget.AppBarLayout\nimport android.support.design.widget.CoordinatorLayout\nimport android.support.v4.widget.NestedScrollView\nimport somepackage.somepackage.common.extensions.dip\nimport somepackage.somepackage.common.extensions.padding\nimport somepackage.somepackage.common.viewdsl.*\nimport somepackage.somepackage.somepackage.R\nimport somepackage.somepackage.somepackage.addAppBar\n\nclass RegisterUi(override val ctx: RegisterActivity) : Ui {\n    override val root = v(::CoordinatorLayout, R.id.cl) {\n        addAppBar(ctx)\n        add(::NestedScrollView, lParams(width = matchParent, height = matchParent) {\n            behavior = AppBarLayout.ScrollingViewBehavior()\n        }) {\n            add(::verticalLayout, lParams(width = matchParent)) {\n                padding = dip(16)\n\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.support.annotation.IdRes\nimport android.support.annotation.StyleRes\nimport android.support.v7.view.ContextThemeWrapper\nimport android.view.View\nimport android.view.ViewGroup\n\ntypealias NewViewRef<V> = (Context) -> V\n\nconst val NO_THEME = 0\n\n@SuppressLint(\"RestrictedApi\")\nfun Context.wrapCtxIfNeeded(theme: Int): Context {\n    return if (theme == NO_THEME) this else ContextThemeWrapper(this, theme)\n}\n\ninline fun <V : View> Context.v(createView: NewViewRef<V>,\n                         @IdRes id: Int = View.NO_ID,\n                         theme: Int = NO_THEME,\n                         initView: V.() -> Unit = {}): V {\n    return createView(wrapCtxIfNeeded(theme)).also {\n        it.id = id\n        it.initView()\n    }\n}\n\ninline fun <V : View> View.v(createView: NewViewRef<V>,\n                      @IdRes id: Int = View.NO_ID,\n                      theme: Int = NO_THEME,\n                      initView: V.() -> Unit = {}) = context.v(createView, id, theme, initView)\n\ninline fun <V : View> Ui.v(createView: NewViewRef<V>,\n                    @IdRes id: Int = View.NO_ID,\n                    theme: Int = NO_THEME,\n                    initView: V.() -> Unit = {}) = ctx.v(createView, id, theme, initView)\n\ninline fun <V : View> ViewGroup.add(createView: NewViewRef<V>,\n                             @IdRes id: Int = View.NO_ID,\n                             @StyleRes theme: Int = NO_THEME,\n                             lp: ViewGroup.LayoutParams,\n                             initView: V.() -> Unit = {}) {\n    val view = createView(context.wrapCtxIfNeeded(theme)).also {\n        it.id = id\n        it.initView()\n    }\n    addView(view, lp)\n}\n\ninline fun <V : View> ViewGroup.add(createView: NewViewRef<V>,\n                             @IdRes id: Int,\n                             lp: ViewGroup.LayoutParams,\n                             initView: V.() -> Unit = {}) {\n    val view = createView(context).also {\n        it.id = id\n        it.initView()\n    }\n    addView(view, lp)\n}\n\ninline fun <V : View> ViewGroup.add(createView: NewViewRef<V>,\n                             lp: ViewGroup.LayoutParams,\n                             initView: V.() -> Unit = {}) {\n    val view = createView(context).apply(initView)\n    addView(view, lp)\n}\n\n"
        },
        {
            "code": "\npublic class Query {}\n"
        },
        {
            "code": "\nclass Queries(queryFactory: QueryFactory) {\n    val example = queryFactory.query()\n}\n"
        },
        {
            "code": "\nabstract class QueryRunner(protected val queries: Queries) {\n    fun performExampleQuery() {\n        performQuery(queries.example)\n    }\n\n    fun performQuery(query: Query) {\n    }\n}\n"
        },
        {
            "code": "\nopen class A {\n    var parent = \"default value\"\n\n    constructor(parent: String?, state: Int)\n}\n\nclass Foo {\n    inner class B : A {\n        constructor(parent: String?, state: Int) : super(parent, state){\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    println(Foo().B(\"ppp\", 123).parent)\n}\n"
        },
        {
            "code": "\nopen class RuleContext : RuleNode {\n    protected var parent : RuleContext?\n\n    constructor() {\n        this.parent = null\n    }\n}\n"
        },
        {
            "code": "\npackage org.antlr.v4.kotlinruntime.atn\n\nclass EmptyPredictionContext : SingletonPredictionContext(null, PredictionContext.EMPTY_RETURN_STATE) {\n\n    override val isEmpty: Boolean\n        get() = true\n\n    override fun size(): Int {\n        return 1\n    }\n\n    override fun getParent(index: Int): PredictionContext? {\n        return null\n    }\n\n    override fun getReturnState(index: Int): Int {\n        println(\"FDEBUG EmptyPredictionContext returnState $returnState\")\n        return returnState\n    }\n\n    override fun equals(o: Any?): Boolean {\n        return this === o\n    }\n\n    override fun toString(): String {\n        return \"EMPTY$\"\n    }\n}\n"
        },
        {
            "code": "\nimport Test.Companion.num\n\nclass Test{\n  companion object {\n    var num = 0\n  }\n}\n\nfun main(args: Array<String>){\n  num++    //error here\n  Test.num++\n}\n"
        },
        {
            "code": "\nclass Outer {\n    open inner class Inner\n}\n\nfun main(args: Array<String>) {\n    Outer().run {\n        class InnerDerived : Outer.Inner()\n    }\n}\n"
        },
        {
            "code": "\nopen class A1(y: String) {\n    val x = \"[A1.x,$y]\"\n}\n\nopen class A2(y: String) {\n    val x = \"[A2.x,$y]\"\n\n    inner open class B1 : A1 {\n        constructor(p: String) : super(\"[B1.param,$p]\")\n\n        fun foo() = x + \";\" + this@A2.x + \";\"\n    }\n\n    fun bar(): String {\n        // Stacktrace1\n        return with(A2(\"#bar\")) {\n            class C : B1(\"bar\") {}\n            C().foo()\n        }\n    }\n\n    fun foo() = A2(\"#baz\").baz()\n\n    fun A2.baz(): String {\n        // Stacktrace2\n        class C : B1(\"baz\") {}\n        return C().foo()\n    }\n}\n\nfun box(): String {\n    val r3 = A2(\"f\").bar()\n    if (r3 != \"[A1.x,[B1.param,bar]];[A2.x,#bar];\") return \"fail3: $r3\"\n    val r4 = A2(\"gg\").foo()\n    if (r4 != \"[A1.x,[B1.param,baz]];[A2.x,#baz];\") return \"fail3: $r4\"\n\n    return \"OK\"\n}\n\nfun main(args: Array<String>) {\n    println(box())\n}\n"
        },
        {
            "code": "\nfun foo(x: Int, y: Int = 0) {}\n"
        },
        {
            "code": "\ninterface Test {\n    fun methodWithImpl(parameterName: String) {\n        println(\"test\")\n    }\n}\n\nfun main(args: Array<String>) {\n    println(\n            Class.forName(\"Test\\$DefaultImpls\").declaredMethods\n                    .flatMap { it.parameters.asList() }\n                    .map { it.name }\n    )\n}\n"
        },
        {
            "code": "\npackage testinline\n\nclass DomainException(override val message: String = \"\"): Throwable(message)\n\ninline fun verify(test: Boolean, lazyMessage: ()->Any = { \"\" }) {\n    if(!test) {\n        throw DomainException(lazyMessage().toString())\n    }\n}\n\nfun main(args: Array<String>) {\n    verify(true)\n}\n"
        },
        {
            "code": " inline "
        },
        {
            "code": " String"
        },
        {
            "code": " Any "
        },
        {
            "code": "\n// works:\n//suspend fun <T> AsyncSequence<T>.toList(): List<T> {\n//\tval out = arrayListOf<T>()\n//\tval it = this.iterator()\n//\twhile (it.hasNext()) {\n//\t\tout += it.next()\n//\t}\n//\treturn out\n//}\n\n// fails with java.lang.ClassCastException: java.lang.Object cannot be cast to java.lang.Boolean\nsuspend fun <T> AsyncSequence<T>.toList(): List<T> {\n\tval out = arrayListOf<T>()\n\tfor (e in this@toList) out += e // fails at this line\n\treturn out\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.KClass\nimport kotlin.reflect.jvm.javaType\n\nfun main(args: Array<String>) {\n    println(\"not nullable : \" + object : Type<String> {}.name)\n    //    not nullable : String\n    println(\"nullable : \" + object : Type<String?> {}.name)\n    //    nullable : String?\n    println(\"inline not nullable : \" + Type.of<String>().name)\n    //    inline not nullable : String\n    println(\"inline nullable : \" + Type.of<String?>().name)\n    //    inline nullable : String\n}\n\ninterface Type<T> {\n    companion object {\n        inline fun <reified T> of() = object : Type<T> {}\n    }\n\n    val nullable: Boolean\n        get() = extractType().isMarkedNullable\n\n    val type: Class<T>\n        get() = Class.forName(extractType().javaType.typeName) as Class<T>\n\n    val name: String get() = type.simpleName + if (nullable) \"?\" else \"\"\n\n    private fun extractType() = this::class.supertypes\n            .first { it.classifier.let { it is KClass<*> && it.java == Type::class.java } }\n            .arguments[0].type!!\n}"
        },
        {
            "code": "\nclass MyThrowable : Throwable {\n    constructor() : super()\n    constructor(cause: Throwable?) : super(cause)\n}\n\nfun main(args: Array<String>) {\n    println(MyThrowable().message)\n    println(MyThrowable(cause = null).message)\n}\n// prints:\n// undefined\n// undefined\n"
        },
        {
            "code": "\nafterEvaluate {\n    tasks.unpackDependenciesTestKotlinJs.enabled = false\n}\n"
        },
        {
            "code": "\ninterface A {\n    var bar: Boolean\n        get() = false\n        set(value) { throw AssertionError(\"Fail set\") }\n}\n\ninterface B : A\n\ninterface C : A {\n    override var bar: Boolean\n        get() = true\n        set(value) {}\n}\n\ninterface D : B, C\n\nclass Impl : D\n\nfun box(): String {\n    Impl().bar = false\n    if (!Impl().bar) return \"Fail get\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "\n  Object.defineProperty(B.prototype, 'bar', Object.getOwnPropertyDescriptor(A.prototype, 'bar'));\n  Object.defineProperty(D.prototype, 'bar', Object.getOwnPropertyDescriptor(B.prototype, 'bar')); // <-- Should be C.prototype instead of B.prototype\n  Object.defineProperty(Impl.prototype, 'bar', Object.getOwnPropertyDescriptor(D.prototype, 'bar'));\n"
        },
        {
            "code": "\nclass MyTest { \n   @Test\n   fun testFoo() = Promise<Int> { _, reject -> reject(RuntimeException()) } // should fail, but does not fail now!\n}\n"
        },
        {
            "code": "\nclass X {\n    fun x() {\n        listOf<Any>().map(::y)\n    }\n    fun y(a: Any) {\n    }\n}\n"
        },
        {
            "code": "\nimport java.io.ByteArrayInputStream\nimport java.io.InputStream\nimport kotlin.properties.ReadOnlyProperty\nimport kotlin.reflect.KProperty\n\nobject DataSourceObject {\n    fun dataValue() = ByteArray(1)\n}\n\nobject DataSourceCache {\n    val dataValue by LazyStream()\n\n    private class LazyStream : ReadOnlyProperty<Any, InputStream> {\n        private lateinit var value: ByteArray\n\n        override fun getValue(thisRef: Any, property: KProperty<*>): InputStream {\n            synchronized(lock) {\n                if (!this::value.isInitialized) {\n                    val source = DataSourceObject::class.java.getDeclaredMethod(property.name)\n                    value = source.invoke(DataSourceObject) as ByteArray\n                }\n            }\n\n            return ByteArrayInputStream(value)\n        }\n    }\n\n    private val lock = Any()\n}\n"
        },
        {
            "code": "\nimport kotlin.properties.Delegates\n\nfun main(args: Array<String>) {\n    var k by Delegates.observable (0, { _, old, new -> println(\"Change from $old to $new\")})\n    k+=1\n}\n"
        },
        {
            "code": "\nimport kotlin.Double.Companion.POSITIVE_INFINITY\n\nfun main(args: Array<String>) {\n    println(POSITIVE_INFINITY)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(Double.POSITIVE_INFINITY)\n}\n"
        },
        {
            "code": "\npackage org.kaqui\n\nimport org.junit.Test\n\nimport org.junit.Assert.*\nimport kotlin.system.measureTimeMillis\n\ndata class Stuff(val one: Double, val two: Double, val three: Double, val four: Double)\n\nfun funRaw(one: Double, two: Double, three: Double, four: Double): Double {\n    return one + two + three + four\n}\n\nfun benchRaw(): Double {\n    var sum = 0.0\n    val one = 1.0;\n    val two = 2.0;\n    val three = 3.0;\n    val four = 4.0;\n    var i = 0\n    while (i < 200000) {\n        sum += funRaw(one, two, three, four)\n        i += 1\n    }\n    return sum\n}\n\nfun funDataClass(stuff: Stuff): Double {\n    return stuff.one + stuff.two + stuff.three + stuff.four\n}\n\nfun benchDataClass(): Double {\n    var sum = 0.0\n    val stuff = Stuff(1.0, 2.0, 3.0, 4.0)\n    var i = 0\n    while (i < 200000) {\n        sum += funDataClass(stuff)\n        i += 1\n    }\n    return sum\n}\n\n\nclass UtilsKtTest {\n    @Test\n    fun getBackgroundFromScore() {\n        for (i in 0..100)\n            benchRaw()\n\n        val timeRaw = measureTimeMillis({\n            for (i in 0..100)\n                benchRaw()\n        })\n\n        for (i in 0..100)\n            benchDataClass()\n\n        val timeDataClass = measureTimeMillis({\n            for (i in 0..100)\n                benchDataClass()\n        })\n\n        println(\"raw: $timeRaw, dataClass: $timeDataClass\")\n    }\n\n}\n"
        },
        {
            "code": "\npackage alraune\n\nobject BloodyBug {\n    // If `doStuff` function is commented out, stuff works\n    fun doStuff(f: () -> Unit = {}) = DoStuff()\n\n    class DoStuff(f: () -> Unit = {})\n\n    @JvmStatic fun main(args: Array<String>) {\n        DoStuff {}    ; println(\"First works\")\n        DoStuff()     ; println(\"Second works\")\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val cl: Class<out Int> = Int::class.java\n    TakeMyFun.make(cl).take { _ -> println(\"Never called\") }\n    // java.lang.ClassCastException: MainKt$main$1 cannot be cast to TakeMyFun$MyFun\n}\n"
        },
        {
            "code": "\npackage bug\n\nimport bug.Position.woops\nimport bug.Position.ok\n\nobject Position\n{\n  var woops: Int = 0\n  var ok: Int = 0\n}\n\nfun error()\n{\n  woops += 0\n}\n\nfun worksFine()\n{\n  Position.ok += 0\n}\n"
        },
        {
            "code": "\nobject obj {\n    var variable:Int = 0\n}\n"
        },
        {
            "code": "\nimport obj.variable\n\nfun main(args:Array<String>){\n     variable+=5 // if you build this, there will be an error\n     variable=variable+5 // if you replace the line above with this one, there won't be an error\n     obj.variable+=5 // neither if you replace by this line\n}\n"
        },
        {
            "code": "\npackage test\n\n fun <T: Task<*>> T.test() {\n    execute()\n}\n"
        },
        {
            "code": "\n    for (i in array) {\n        print(i)\n    }\n"
        },
        {
            "code": "\nclass C(val foo: IFoo) : IFoo by foo\n"
        },
        {
            "code": "\nclass C(val foo: Delegate) {\n    val bar by foo\n}\n"
        },
        {
            "code": "\nopen class ClickEvent(val callback: () -> Unit) {\n    fun doThings() {\n        callback()\n    }\n}\n\nclass Foo {\n    val myString: String = \"\"\n\n    private inner class BarClickEvent : ClickEvent({\n        myString.length // This errors out\n    })\n}\n"
        },
        {
            "code": "\nclass Foo {\n    val myString: String = \"\"\n\n    private inner class BarClickEvent : ClickEvent {\n        constructor(): this(this@Foo)\n\n        private constructor(foo: Foo):super({\n            foo.myString.length // Must use foo to access myString\n        })\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\nclass Top(val x: String) {\n    open class In1(val f: () -> String)\n\n    inner class In2 : In1({ x })\n\n    fun test() = In2().f()\n}\n\nfun main(args: Array<String>) {\n    Top(\"OK\").test()\n}\n"
        },
        {
            "code": "\nclass TestClass {\n    fun `test name with spaces`() {\n        data class MyClass(val blah:String)\n    }\n}\n"
        },
        {
            "code": "\nenum class E(val a: String? = null) { // removing \"a\" argument fixes the problem\n    A { // changing to A() fixes the problem\n        override fun f() = \"\" // removing overridden method fixes the problem\n    };\n\n    open fun f() = \"\"\n}\n\nfun main(args: Array<String>) {\n    E.A // generates java.lang.NoSuchMethodError: integration.E: method <init>(Ljava/lang/String;I)V not found\n}\n"
        },
        {
            "code": "\npackage alraune\n\nclass DoesntWork : Banana {\n    constructor() : super()\n    constructor(f: () -> String) : super(f)\n\n    companion object {\n        @JvmStatic fun main(args: Array<String>) {\n            val inst = DoesntWork {\"Hi there\"}\n            inst.goCrazy()\n        }\n    }\n}\n\nclass ThisWorks(f: () -> String) : Banana(f) {\n    companion object {\n        @JvmStatic fun main(args: Array<String>) {\n            val inst = ThisWorks {\"Hi there\"}\n            inst.goCrazy()\n        }\n    }\n}\n"
        },
        {
            "code": "\ninline fun foo(f: () -> String): () -> String {\n    val result = f()\n    return { result }\n}\n"
        },
        {
            "code": "\nfun bar(f: () -> String) = foo(f)()\n\nfun main(args: Array<String>) {\n    println(bar { \"OK\" })\n}\n"
        },
        {
            "code": "\nimport java.util.concurrent.Executors\n\nfun main(args: Array<String>) {\n    val executor = Executors.newSingleThreadExecutor()\n    val execute: (() -> Unit) -> Unit = executor::execute\n    val function = { }\n    execute(function)\n}\n"
        },
        {
            "code": "\nclass X {\n    fun foo(y: Y) {}\n}\n\nsealed class Y\n\nclass Z(val x: X) : Y() {\n    fun bar() {\n        x.foo(this)\n    }\n}\n"
        },
        {
            "code": "\n    for (i in cs) {\n        print(i)\n    }\n"
        },
        {
            "code": "\ninline fun <R, T> R.foo(property: KMutableProperty1<R, T>, value: T) {\n    val name = property.name\n    val oldValue = property.get(this)\n    property.set(this, value)\n    println(\"Set $name to $value, previously was $oldValue\")\n\n}\n\nclass Foo(var bar: String) {\n    fun baz() {\n        foo(Foo::bar, \"new\")\n    }\n}\n"
        },
        {
            "code": "\nsuspend fun sid(v: String): String = v\n\ninline suspend fun foo(): String {\n    println(sid(\"1\"))\n    println(sid(\"2\"))\n    return \"OK\"\n}\n\nsuspend fun bar(): String {\n    println(\"before\")\n    return foo()\n}\n"
        },
        {
            "code": "\nsuspend fun <T> foo(v: T): T = v\n\ninline suspend fun boo(v: String): String {\n    foo(\"!$v\")\n    return foo(v)\n}\n\ninline suspend fun bar(v: String) {\n    val x = boo(v)\n    println(\"bar($x)\")\n}\n"
        },
        {
            "code": "\nsuspend fun baz() {\n    bar(\"A\")\n    bar(\"B\")\n}\n"
        },
        {
            "code": "\ninterface I {\n    val a: Char\n}\n\nobject X : I {\n    override var a = '#'\n}\n\nvar result = \"\"\n\nobject Y : I {\n    override var a = '#'\n        get() {\n            result = jsTypeOf(field.asDynamic())\n            return field\n        }\n}\n\nfun main(args: Array<String>) {\n    foo(X.a)\n    Y.a = '@'\n    println(Y.a)\n    println(result)\n}\n\nfun foo(x: Any) {\n    println(jsTypeOf(x.asDynamic()))\n}\n"
        },
        {
            "code": "\nobject\nnumber\n"
        },
        {
            "code": "\ninterface A {\n    fun foo(): String\n}\n\nclass B : A {\n    override fun foo(): String = \"OK\"\n}\n\nfun box(): String {\n    val b = B::class.js\n    val c = js(\"\"\"\n    function C() {\n    \tb.call(this);\n    };\n    C.prototype = Object.create(b.prototype);\n    C.prototype.constructor = C;\n    new C();\n    \"\"\")\n    \n    println(\"c is B = ${c is B}\")\n    println(\"c is A = ${c is A}\")\n\n    return \"OK\"\n}\n\nfun main(args: Array<String>) {\n    println(box())\n}\n"
        },
        {
            "code": "\nprintln((0.0..Double.NaN).isEmpty())\n"
        },
        {
            "code": "\ntrue\n"
        },
        {
            "code": "\n// Call contains function explicitly.\nprintln((0.0..Double.NaN).contains(1.0))\n\n// Use in operator to variable.\nval range = 0.0..Double.NaN\nprintln(1.0 in range)\n"
        },
        {
            "code": "\nfalse\nfalse\n"
        },
        {
            "code": "\n// Use in operator to Range created by an operator.\nprintln(1.0 in (0.0..Double.NaN))\n"
        },
        {
            "code": "\ntrue\n"
        },
        {
            "code": "\n    var arr = arrayOf(1, 2, 3)\n    for (i in arr) {\n        print(i)\n        arr = emptyArray()\n    }\n"
        },
        {
            "code": "\nclass FunRefTest() {\n    fun someFun() {}\n}\n\nfun test(ref: () -> Unit) {\n    println(ref::class.java)\n}\n\nfun main(args: Array<String>) {\n    val test = FunRefTest()\n    test(test::someFun)\n    test(test::someFun)\n}\n"
        },
        {
            "code": " kotlin\nclass IntAddition(val value: Int) {\n    fun addTo(i: Int) = i + value\n    fun addToAll(ints: Iterable<Int>) = ints.map(::addTo) // reference to this::addTo\n}\n"
        },
        {
            "code": "\nopen class Base(val callback: () -> String)\n\nclass Outer {\n    val ok = \"OK\"\n\n    inner class Inner : Base {\n        constructor() : super({ ok })\n    }\n}\n\nfun box(): String =\n        Outer().Inner().callback()\n"
        },
        {
            "code": "\nval a by lazy {\n    1\n}\n\nfun main(args: Array<String>) {\n \tval b by lazy {\n    \t2\n\t}   \n    \n    println(a)\n    println(b)\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.*\n\nobject Ddd {\n    operator fun getValue(thisRef: Any?, p: KProperty<*>): Any {\n        println(\"get\")\n        return 1\n    }\n}\n\nval b by Ddd\n\nfun main(args: Array<String>) {\n    val a by Ddd\n    println(a)\n    println(a)\n    println(b)\n    println(b)\n}\n"
        },
        {
            "code": "\nclass A(var x: Char) {\n    var y: Char = '0'\n}\n"
        },
        {
            "code": "\n  function A(x) {\n    this.x = x;\n    this.y = toBoxedChar(48);\n  }\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val a = object : A {}\n    val c = object : C {}\n    println(a.greet())\n    println(a.greet(\"world\"))\n    println(c.greet())  // <-- crashes here\n    println(c.greet(\"world\"))\n}\n\ninterface A {\n    fun greet(name: String = \"everybody\"): String = \"Hello, $name!\"\n}\n\ninterface B : A {\n    override fun greet(name: String): String\n}\n\ninterface C : B {\n    override fun greet(name: String): String = \"Hi, $name!\"\n}\n"
        },
        {
            "code": "\nfun foo() {\n    bar {\n        try {\n            baz()\n        }\n        catch (e: RuntimeException) {\n            e.toString()\n        }\n    }\n\n    bar {\n        when (boo()) {\n            \"boo\" -> baz()\n            else -> \"111\"\n        }\n    }\n}\n\ninline fun bar(x: () -> String): String {\n    return x()\n}\n\nfun baz() = \"baz\"\n\nfun boo() = \"boo\"\n\nfun main(args: Array<String>) {\n    foo()\n}\n"
        },
        {
            "code": "\n    val x = bar {\n        try {\n            baz()\n        }\n        catch (e: RuntimeException) {\n            e.toString()\n        }\n    }\n\n    val y = bar {\n        when (boo()) {\n            \"boo\" -> baz()\n            else -> \"111\"\n        }\n    }\n"
        },
        {
            "code": "\nfun foo() {\n    bar { it?.baz() }\n}\n\nfun bar(x: suspend (A?) -> Unit) {}\n\nclass A {\n    suspend fun baz() {}\n}\n"
        },
        {
            "code": "\nfun foo(x: Int) {\n    println(when (x) {\n        1 -> \"one\"\n        2 -> \"two\"\n        else -> \"many\"\n    })\n}\n"
        },
        {
            "code": "\nfun foo(f: suspend () -> Unit) {\n}\n\nfun main(args: Array<String>) {\n    foo {\n        println(\"aaa\")\n        js(\"debugger;\")\n        println(\"bbb\")\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val a = object : A {}\n    val b = object : B {}\n    println(a.greet())\n    println(a.greet(\"world\"))\n    println(b.greet())\n    println(b.greet(\"world\"))\n}\n\ninterface A {\n    fun greet(name: String = \"everybody\"): String = \"Hello, $name!\"\n}\n\ninterface B : A {\n    override fun greet(name: String): String = \"Hi, $name!\"\n}\n"
        },
        {
            "code": "\ninterface My {\n    fun foo()\n    suspend fun foos()\n}\n\nclass Your : My {\n    override fun foo() {}\n    suspend override fun foos() {}\n}\n"
        },
        {
            "code": "\nfun `some desc here`() {\n//fun foo() {\n\n    data class Friend(val name: String, val birthDay: LocalDate) {}\n\n    Friend(\"Max\", LocalDate.parse(\"2007-12-03\"))\n}\n"
        },
        {
            "code": "\nopen class Base(o: Any)\n\nopen class Outer {\n    open inner class Inner\n\n    inner class JavacBug : Base(object : Outer.Inner() {})\n}\n\nfun main(args: Array<String>) {\n    Outer().JavacBug()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val dbl = 1.toDouble()\n    println(\"M$dbl\") \n    println(moveTo(1.toDouble()))  \n}\nfun moveTo(x:Double) = \"M$x\"\n"
        },
        {
            "code": "\nM1\nM1\n"
        },
        {
            "code": "\n  function main(args) {\n    var dbl = 1;\n    println('M1.0');     // <-- Constant evaluate during compile time!\n    println(moveTo(1));\n  }\n  function moveTo(x) {\n    return 'M' + x;\n  }\n"
        },
        {
            "code": "\ninterface I {\n    fun foo(x: Int = 23)\n}\n\nabstract class Base : I\n\nclass C : Base() {\n    override fun foo(x: Int) {\n        println(\"C:$x\")\n    }\n}\n\nfun bar(x: I) {\n    x.foo()\n    x.foo(42)\n}\n\nfun main(args: Array<String>) {\n    bar(C())\n}\n"
        },
        {
            "code": "\nenum class Gender {\n    MALE, FEMALE\n}\n\ninline fun postInline(block: () -> Unit) = block()\n\nfun post(block: () -> Unit) = block()\n\nfun main(args: Array<String>) {\n    postInline { enumValueOf<Gender>(\"MALE\") }\n    post { enumValueOf<Gender>(\"MALE\") }\n}\n"
        },
        {
            "code": "\nfun foo(a: () -> Boolean, b: () -> Boolean) {\n    println(a() or b())\n}\n"
        },
        {
            "code": "\ntypealias ArrayB = Array<Boolean>\n\nfun foo(): Boolean {\n    val ba = ArrayB(1) { return true }\n    \n    return false\n}\n\nfun bar(): Boolean {\n    val ba = Array<Boolean>(1) { return true }\n    \n    return false\n}\n\nfun main(args: Array<String>) {\n    println(foo())\n    println(bar())\n}\n"
        },
        {
            "code": "\nfalse\ntrue\n"
        },
        {
            "code": "\ntrue\ntrue\n"
        },
        {
            "code": "\nclass ExampleClass {\n    var batch: SpriteBatch? = null\n\n    fun render() {\n        batch?.begin()\n        batch?.end()\n    }\n}\n"
        },
        {
            "code": "\nfun main(args : Array<String>) {\n    val testObject = Test()\n    testObject.testFunction() // Line 3\n}\n\nclass Test {\n    inline fun testFunction(): Unit = null!! // Line 7\n}\n// Line 9 (empty)\n"
        },
        {
            "code": "\ninterface IDemo {\n    val Int.twice get() = this * 2\n}\n\nopen class Demo {\n    val Int.twice get() = this * 2\n}\n\n//class MyDemo : Demo() { // WORKS\nclass MyDemo : IDemo { // FAILS\n    fun yay() {\n        println(10.twice)\n    }\n}\n\nfun main(args: Array<String>) {\n    val demo = MyDemo()\n    demo.yay()\n}\n"
        },
        {
            "code": "\npackage test\n\nclass C\n\nvar C?.p: Int\n    get() = 42\n    set(value) {}\n\noperator fun Int?.inc(): Int? = this?.inc()\n\nfun test(nc: C?) {\n    nc?.p++\n}\n"
        },
        {
            "code": "\nimport java.util.stream.IntStream\n\nfun main(args:Array<String>) {\n\tval n = 1000000000\n\tval delta = 1.0 / n\n\tval startTimeNanos = System.nanoTime()\n\tval pi = 4.0 * delta * IntStream.range(1, n).mapToDouble{i ->\n\t\tval x = (i - 0.5) * delta\n\t\t1.0 / (1.0 + x * x)\n\t}.sum()\n\tval elapseTime = (System.nanoTime() - startTimeNanos) / 1e9\n\tout(\"Sequential Streams\", pi, n, elapseTime)\n}\n"
        },
        {
            "code": "\nenum class Foo(val bar: String, val closure: () -> String) {\n    VALUE(\"Hello\", {\n        VALUE.bar\n    })\n}\n"
        },
        {
            "code": "\nclass Foo {\n    lateinit var bar: String\n\n    fun callable(): Boolean = true\n\n    fun test(): Boolean {\n        if (!::bar.isInitialized) {\n            bar = \"a\"\n            return false\n        }\n        return (::callable)()\n    }\n}\n\nfun main(args: Array<String>) {\n    val foo = Foo()\n    println(foo.test())\n    println(foo.bar)\n}\n"
        },
        {
            "code": "\nfalse\na\n"
        },
        {
            "code": "\nclass MainActivity : AppCompatActivity() {\n    private var x: Int = 0\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        Problem()\n    }\n\n    abstract class AbstractProblem(action: () -> Unit)\n\n    inner class Problem : AbstractProblem({ x++ })\n}\n"
        },
        {
            "code": "\nimport org.khronos.webgl.Uint8ClampedArray\nimport org.khronos.webgl.get\nimport org.khronos.webgl.set\nimport org.w3c.dom.CanvasRenderingContext2D\nimport org.w3c.dom.HTMLCanvasElement\nimport org.w3c.dom.ImageData\n\ndata class Color(val r: Int, val g: Int, val b: Int, val a: Int)\n\nclass JSCanvas(htmlCanvas: HTMLCanvasElement, override val density: Density) : ICanvas {\n\n    override val width = htmlCanvas.width\n    override val height = htmlCanvas.height\n\n    override fun setPixel(x: Int, y: Int, c: Color) {\n        var pixelIndex = pixelIndex(x, y)\n        val data = imageData.data\n        // data holds Uint8 values but kotlin's getter is declared as Byte\n        // This leads to wrong conversion of values above 127\n        data[pixelIndex++] = c.r.asDynamic()\n        data[pixelIndex++] = c.g.asDynamic()\n        data[pixelIndex++] = c.b.asDynamic()\n        data[pixelIndex++] = c.a.asDynamic()\n    }\n\n    override fun getPixel(x: Int, y: Int): Color {\n        var pixelIndex = pixelIndex(x, y)\n        val data: Uint8ClampedArray = imageData.data\n        val r = data[pixelIndex++].asDynamic()\n        val g = data[pixelIndex++].asDynamic()\n        val b = data[pixelIndex++].asDynamic()\n        val a = data[pixelIndex++].asDynamic()\n        return Color(r, g, b, a)\n    }\n\n    override fun commit() {\n        context.putImageData(imageData, 0.0, 0.0)\n    }\n\n    private val context = htmlCanvas.getContext(\"2d\") as CanvasRenderingContext2D\n    private val imageData: ImageData = context.createImageData(width.toDouble(), height.toDouble())\n\n    private fun pixelIndex(x: Int, y: Int): Int = (y * imageData.width + x) * BYTES_PER_PIXEL\n\n    private fun Any?.asDynamic(): dynamic = this\n\n    companion object {\n        const val BYTES_PER_PIXEL = 4\n    }\n\n}\n"
        },
        {
            "code": "\nimport java.io.File\n\nfun main(args: Array<String>) {\n    val file1 = File(\"\")\n\n    val filesMap = arrayListOf<Map<File, String>>()\n    fun X.filesMap(): Map<File, String> =\n            files.associateBy({ file1 }, { \"\" })\n\n    X(listOf(file1)).apply {\n        filesMap.add(filesMap())\n    }\n}\n\nprivate class X(val files: Iterable<File>)\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val env = Pair(0, 0)\n    fun point(z: Int) = env.first\n    fun point() = point(0)\n\n    arrayOf(10).forEach {\n        point()\n        point(0)\n    }\n}\n"
        },
        {
            "code": " kotlin\nfun main(args: Array<String>) {\n    var x = \"\"\n    class Outer() {\n        var p = \"\"\n\n        inner class Inner() {\n            fun foo() {\n                Outer().p = x\n            }\n        }\n    }\n\n    Outer().Inner().foo()\n}\n\n"
        },
        {
            "code": "\npackage bug\n\nopen class A {\n    val foo: Int = 0\n    var bar: Int = 0\n}\n\nclass B : A() {\n    fun test() {\n        super.foo\n        super.bar\n        super.bar = 2\n    }\n }\n\nfun main(args: Array<String>) {\n    B().test()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    var i = 0\n    js(\"this = i;\")\n}\n"
        },
        {
            "code": "\n//import java.util.logging\n\ninterface StaticInitializerSSCCE {\n  companion object {\n\n    val Any.Log2: Logger get() = Logger.getLogger(this.javaClass.canonicalName)\n\n    val DefaultAssumedUserCharset = Charsets.UTF_8\n\n    init {\n      Log2.info { \"DefaultAssumedUserCharset is $DefaultAssumedUserCharset\" }\n    }\n  }\n\n\n  @Test fun `when using static initializer should properly load variables`(){\n    val x = StaticInitializerSSCCE.DefaultAssumedUserCharset\n  }\n}\n"
        },
        {
            "code": "\ninit {\n  val extracted = DefaultAssumedUserCharset\n  Log.info { \"Default is $extracted\" }\n}\n"
        },
        {
            "code": "\ninterface A {\n    companion object {\n        private val instance: A? = null\n\n        fun getInstance(): A = instance!!\n    }\n}\n"
        },
        {
            "code": "\nfun doRun(fn: dynamic.()->Unit) {\n    val o: dynamic = object {}\n    o.fn()\n}\n\nfun main(args: Array<String>) {\n    doRun {\n        println(10)\n    }\n}\n"
        },
        {
            "code": "\nclass A {\n    override fun equals(o: Any?) = super.equals(o)\n    override fun hashCode() = super.hashCode()\n}\n\nfun main(args: Array<String>) {\n    val a = A()\n    val b = A()\n\tprintln(a == a)\n\tprintln(a == b)\n\tprintln(a.hashCode())\n\tprintln(b.hashCode())\n}\n"
        },
        {
            "code": "\nclass Node\nclass Options\nclass Data\nclass Column\n\nclass Grid(container: Node, data: Array<Data>, columns: Array<Column>, options: Options) {\n}\n\nfun foo<T>(a: Int): T {\n    println(a)\n    return null as T\n}\n\nfun bar(vararg a: Any) {}\n\nfun main(args : Array<String>) {\n    Grid(foo(0), array(foo(1), foo(2)), array(), foo(3))\n    bar(foo(0), array<Any>(foo(1), foo(2)), array<Any>(), foo(3))\n}\n"
        },
        {
            "code": "\n1\n2\n0\n3\n1\n2\n0\n3\n"
        },
        {
            "code": "\nenum class Foo {\n  A;\n  \n  object d {\n    val a = A\n    val b = println(\"1\")\n  }\n    \n  companion object {\n    val a = A\n    val b = println(\"2\")\n  }\n}\n\nfun main(args : Array<String>) {\n  println(Foo.d.a)\n  println(Foo.A)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    var i = 0\n    js(\"\"\"\n        for (;i < 10; ++i) {\n            console.log(i);\n        }\n    \"\"\")\n}\n"
        },
        {
            "code": "\nopen class A {\n    fun constructor() : Int {\n        println(\"fun\")\n        return 42\n    }\n    init {\n        println(\"init\")\n    }\n}\nclass B : A()\n\nfun main(args: Array<String>) {\n\n    val b = B()\n    val res = b.constructor()\n    println(res)\n\n}\n"
        },
        {
            "code": "\nclass A {\n    companion object prototype\n}\nclass B { \n    object prototype\n}\n"
        },
        {
            "code": "\nclass A {\n    inner class length\n}\n\nfun main(args: Array<String>) {\n    val a= A()\n    println(a.length())\n}\n"
        },
        {
            "code": "\nconst val MY_VAL = 42\n\nfun someFunc() {\n  someCall(MY_VAL.toFloat())\n}\n"
        },
        {
            "code": "\nconst val MY_VAL = 42\nconst val MY_VAL_F = MY_VAL.toFloat()\n\nfun someFunc() {\n  someCall(MY_VAL_F)\n}\n"
        },
        {
            "code": "\nwithType(\"CharArray\", js(\"new Uint16Array([].slice.call(arguments))\"))\n"
        },
        {
            "code": "\nwithType(\"CharArray\", js(\"new Uint16Array(arguments)\"))\n"
        },
        {
            "code": "\npackage test\n\nclass C {\n    lateinit var zz: String\n\n    fun test() = ::zz.isInitialized\n}\n"
        },
        {
            "code": "\nopen class A(c: Char) {\n    open val c: Char = c\n    fun foo(): Char = 'a'\n    open fun bar(): Char = 'a'\n}\n\ninterface B {\n    val c: Any\n    fun foo(): Any\n    fun bar(): Char\n}\n\nclass C(c: Char) : A(c), B\n\nfun main(args: Array<String>) {\n    val b = (C('c') as B)\n    println(b.c)\n    println(b.foo())\n    println(b.bar())\n}\n"
        },
        {
            "code": "\nc\na\na\n"
        },
        {
            "code": "\n99\n97\na\n"
        },
        {
            "code": "\nfun main(args : Array<String>) {\n    println(Double.MAX_VALUE.toInt())\n    println(Double.MIN_VALUE.toInt())\n    println(Double.NaN.toInt())\n    println(Double.POSITIVE_INFINITY.toInt())\n    println(Double.NEGATIVE_INFINITY.toInt())\n}\n"
        },
        {
            "code": "\n0\n0\n0\n0\n0\n"
        },
        {
            "code": "\n2147483647\n0\n0\n2147483647\n-2147483648\n"
        },
        {
            "code": "\nfun test1() {\n    var a = \"outer\"\n    js(\"a = 'js';\")\n    run {\n        println(a)\n    }\n}\n\nfun test2() {\n    var a = \"outer\"\n    js(\"a = 'js';\")\n    println(a)\n}\n"
        },
        {
            "code": "\ndata class SomeClass(val unit: Unit)\n\ninline fun inlining(block: () -> Unit) {\n    SomeClass(block())\n}\n\nfun noop() {\n}\n\nfun function() {\n    inlining(::noop)\n}\n"
        },
        {
            "code": "\nimport java.util.function.Supplier\n\nfun testSupplier(message: () -> String) {\n    Supplier(message)\n}\n"
        },
        {
            "code": "\njavadoc {\n\toptions.memberLevel = org.gradle.external.javadoc.JavadocMemberLevel.PROTECTED\n\toptions.author = true\n\toptions.header = project.name\n\toptions.addStringOption('Xdoclint:html,syntax', '-quiet')\n\toptions.encoding = 'UTF-8'\n}\n"
        },
        {
            "code": "\nimport java.util.function.Supplier\n\nfun testSupplier(message: () -> String) {\n    Supplier { message() }\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.*\nimport kotlin.js.Promise\n\nsuspend fun <T> Promise<T>.await() = suspendCoroutine<T> { c ->\n    then({\n             c.resume(it)\n         }, {\n             c.resumeWithException(it)\n         })\n}\n\ninline suspend fun foo(a: Promise<*>, b: Promise<*>) {\n    a.await()\n    b.await()\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.COROUTINE_SUSPENDED\nimport kotlin.js.Promise\n\nfun <T> promiseAsync(c: suspend () -> T): Promise<T> {\n    return Promise { resolve, reject ->\n        c.startCoroutine(object : Continuation<T> {\n            override fun resume(value: T) = resolve(value)\n\n            override fun resumeWithException(exception: Throwable) = reject(exception)\n\n            override val context = EmptyCoroutineContext\n        })\n    }\n}\n\nfun <T> promise(value: T): Promise<T> {\n    return Promise.resolve(value)\n}\n\nfun main(args: Array<String>) {\n    promiseAsync {\n        foo(promise(\"1\"), promise(\"2\"))\n        foo(promise(\"3\"), promise(\"4\"))\n    }\n}\n"
        },
        {
            "code": "\nsuspend inline fun <reified T : Any> demo() {\n\tdemo(T::class)\n}\n\nsuspend fun <T : Any> demo(clazz: KClass<T>) {\n}\n"
        },
        {
            "code": "\nsuspend fun test() {\n\tprintln(\"[1]\")\n\tdemo<Int>()\n\tdemo<Int>()\n\tdemo<Int>()\n\tdemo<Int>()\n\tdemo<Int>()\n\tprintln(\"[2]\")\n\tdemo(Int::class)\n\tdemo(Int::class)\n\tdemo(Int::class)\n\tdemo(Int::class)\n}\n"
        },
        {
            "code": "\nclass TestClass<out T : Any>(@get:JvmName(\"renamedGetter\") val value : T?)\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val test = TestClass(\"foo\")\n    println(test.value)\n}\n"
        },
        {
            "code": "\nclass A {\n    val prop: Int\n    constructor(arg: Boolean) {\n        if (arg) {\n            prop = 1\n            run { return }\n            throw RuntimeException(\"fail 0\")\n        }\n        prop = 2\n    }\n}\n"
        },
        {
            "code": "\nval x = js(\"{}\")\nx.a = \"hello\"\nconsole.log(x.a)\n"
        },
        {
            "code": "\nval x = js(\"new Object()\")\nx.a = \"hello\"\nconsole.log(x.a)\n"
        },
        {
            "code": "\npackage test\n\ninline fun printValueOrExn(fn: () -> Any?) {\n    try {\n        println(fn())\n    }\n    catch (e: Throwable) {\n        println(e::class.simpleName)\n    }\n}\n\nfun main(args: Array<String>) {\n    printValueOrExn { J.LONG.equals(null) }             // true\n    printValueOrExn { J.DOUBLE.equals(null) }           // true\n    printValueOrExn { J.STRING.equals(null) }           // NPE\n    printValueOrExn { J.obj(J.LONG).equals(null) }      // NPE\n    printValueOrExn { J.obj(J.DOUBLE).equals(null) }    // NPE\n}\n"
        },
        {
            "code": "\nclass A {\n    lateinit var a: Any\n}\n\nfun main(args: Array<String>) {\n    println(\"a = \" + A().a)\n}\n"
        },
        {
            "code": "\na = undefined\n"
        },
        {
            "code": "\nfun f() {\n    js(\"delete foo()\")\n}\n"
        },
        {
            "code": "\n\"max = ${Long.MAX_VALUE}\"\n"
        },
        {
            "code": "\nKotlin.println('aaa ' + Kotlin.modules['stdlib'].kotlin.js.internal.LongCompanionObject.MAX_VALUE);\n"
        },
        {
            "code": "\nval funcReference = ::func\n\nfun func(): Any = true\n\nfun main(args: Array<String>) {\n    val output = funcReference.invoke()\n    when {\n        output is Unit -> print(true)\n        output::class != Boolean::class -> throw Exception()\n        // Here\n        else -> printBool(output as Boolean)\n    }\n}\n\nfun printBool(bool: Boolean) {\n    println(bool)\n}\n"
        },
        {
            "code": "\npackage test\n\nimport b.B\n\nfun main(args: Array<String>) {\n    println(B().getOK())\n}\n"
        },
        {
            "code": "\npackage a\n\nopen class A<T> {\n    protected fun getOK(x: T) = \"OK\"\n}\n"
        },
        {
            "code": "\npackage b\n\nimport a.A\n\nclass B : A<Long>() {\n    inner class Inner {\n        fun innerGetOK() = getOK(0L)\n    }\n\n    fun getOK() = Inner().innerGetOK()\n}\n"
        },
        {
            "code": "\nmap.forEach { k, v ->\n       this[k, fn].write {\n              // Do something\n       }\n}\n"
        },
        {
            "code": "\nmap.forEach { (k, v) ->\n       this[k, fn].write {\n              // Do something\n       }\n}\n"
        },
        {
            "code": "\npackage test\n\nfun foo(vararg xs: Int) {}\n\nfun test() = foo(*intArrayOf(1, 2, 3, 4))\n"
        },
        {
            "code": "\nfun qwe_works() {\n    fun f(): Promise<Unit> = async {\n        delay(1000)\n        throw Exception(\"Aarrgghh...\") // <-- This is kotling-bugs.kt, line 10\n        delay(1000)\n        console.log(\"OK\")\n    }\n\n    async<Unit> {\n        try {\n            await(f())\n        } catch (e: Throwable) {\n            console.log(e.asDynamic().stack)\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun qwe_breaks() {\n    fun f(): Promise<Unit> = async {\n        delay(1000)\n        null!! // <-- This is kotling-bugs.kt, line 27\n        delay(1000)\n        console.log(\"OK\")\n    }\n\n    async<Unit> {\n        try {\n            await(f())\n        } catch (e: Throwable) {\n            console.log(e.asDynamic().stack)\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun qwe_works_sync() {\n    try {\n        js(\"undefined\").lalala\n    } catch (e: dynamic) {\n        console.log(\"Aaarrgghh\", e.message)\n    } finally {\n        console.log(\"Finally\")\n    }\n}\n\nfun qwe_works_async_simple() {\n    val promise = async {\n        js(\"undefined\").lalala\n    }\n\n    async {\n        try {\n            await(promise)\n        } catch (e: dynamic) {\n            console.log(\"Aaarrgghh\", e.message)\n        } finally {\n            console.log(\"Finally\")\n        }\n    }\n}\n\nfun qwe_breaks_async_addedDelay() {\n    val promise = async {\n        await(Promise<Unit> {resolve, _ -> window.setTimeout(resolve, 100)}) // <-- Added this line\n        console.log(\"After delay\")\n        js(\"undefined\").lalala\n    }\n\n    async {\n        try {\n            await(promise)\n        } catch (e: dynamic) {\n            console.log(\"Aaarrgghh\", e.message)\n        } finally {\n            console.log(\"Finally\")\n        }\n    }\n}\n\nfun qwe_works_async_wrappedNativeError() {\n    val promise = async {\n        await(Promise<Unit> {resolve, _ -> window.setTimeout(resolve, 100)}) // <-- Added this line\n        console.log(\"After delay\")\n        try {\n            js(\"undefined\").lalala\n        } catch (e: dynamic) {\n            throw Exception(\"Wrapped: ${e.message}\")\n        }\n    }\n\n    async {\n        try {\n            await(promise)\n        } catch (e: dynamic) {\n            console.log(\"Aaarrgghh\", e.message)\n        } finally {\n            console.log(\"Finally\")\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun isMutedOn1(emails: List<String>) : Map<String, Boolean> {\n    val mutedEmails = setOf<String>()\n    return emails.associate { it to (it in mutedEmails) }\n}\n"
        },
        {
            "code": "\nfun isMutedOn2(emails: List<String>) : Map<String, Boolean> {\n    val mutedEmails = setOf<String>()\n    return emails.associate { it to mutedEmails.contains(it) }\n}\n"
        },
        {
            "code": "\nval strSet = setOf<String>()\n\nfun xTo(s: String) = s to (s in strSet)\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    0.0f in 0.0f.rangeTo(1.0f)\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.intrinsics.COROUTINE_SUSPENDED\nimport kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn\n\ninline suspend fun suspendThere(v: String): String = suspendCoroutineOrReturn { x ->\n    x.resume(v)\n    COROUTINE_SUSPENDED\n}\n\nsuspend fun complexSuspend(): String {\n    return run { return suspendThere(\"K\") }\n}\n\n"
        },
        {
            "code": "\nfun <T> foo (t : T) : Unit {\n    println(\"$t$t\")\n}\n\nfun bar (i : Int) : Unit {\n    println(\"$i$i\")\n}\n\nfun baz (a : Any) : Unit {\n    println(\"$a$a\")\n}\n\nfun main(args: Array<String>) {\n    foo(21)\n    bar(21)\n    baz(21)\n}\n"
        },
        {
            "code": "\n  function foo(t) {\n    println(t + t);\n  }\n  function bar(i) {\n    println(i.toString() + i);\n  }\n  function baz(a) {\n    println(a + a);\n  }\n"
        },
        {
            "code": "\ninterface I {\n    @JsName(\"bar\") \n    fun foo() {println(\"I.foo\")}\n    @JsName(\"foo\") \n    fun bar() {println(\"I.bar\")}\n}\ninterface J {\n    fun foo() {println(\"J.foo\")}\n    fun bar() {println(\"J.bar\")}\n}\n\nopen class A : I,J {\n    override fun foo() {println(\"A.foo\")}\n    override fun bar() {println(\"A.bar\")}\n}\n\nfun main(args: Array<String>) {\n    try {\n        val a = A()\n        a.foo()\n        a.bar()\n    } catch (e: Throwable) {\n        println(e)\n    }\n}\n"
        },
        {
            "code": "\ninterface J {\n    @JsName(\"bar1\") \n    fun foo() {println(\"J.foo\")}\n    fun bar() {println(\"J.bar\")}\n}\n"
        },
        {
            "code": "\nimport java.lang.ref.WeakReference\n\nfun main(args: Array<String>) {\n    val list = mutableListOf<WeakReference<Any>>()\n    \n    for (i in 1..3) {\n        val obj = Any()\n        list.add(WeakReference(obj))\n    }\n    \n    Runtime.getRuntime().gc()\n    Runtime.getRuntime().runFinalization()\n    Runtime.getRuntime().gc()\n    \n    list.forEach {\n        println(it.get().toString())\n    }\n}\n"
        },
        {
            "code": "\nnull\nnull\nnull\n"
        },
        {
            "code": "\nfun foo() {\n    val x = 1\n    class A {\n        val a = x\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    for (mx in -100L..100) {\n        println(mx)\n    }\n}\n"
        },
        {
            "code": "\n@Suppress(\"HEADER_WITHOUT_IMPLEMENTATION\")\n/** Asserts that a [block] fails with a specific exception of type [exceptionClass] being thrown. */\nheader fun <T : Throwable> assertFailsWith1(exceptionClass: KClass<T>, message: String?, block: () -> Unit): T\n"
        },
        {
            "code": "\n// common.kt\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"AKt\")\n\nheader val p: String\n"
        },
        {
            "code": "\n// jvm.kt\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"AKt\")\n\nimpl val p: String\n    get() = \"OK\"\n"
        },
        {
            "code": "\nclass Foo : List<String> by emptyList()\n"
        },
        {
            "code": "\nfun test() {\n    CrashTest().crashByAccess \n}\n\nclass CrashTest {\n    val crashByAccess by className<String>()\n}\n\ninline fun <reified T : Any> className() =\n    object : ReadOnlyProperty<Any?, String> {\n        override operator fun getValue(thisRef: Any?, property: KProperty<*>): String =\n            T::class.js.name\n    }\n"
        },
        {
            "code": "\nfun retrieveFrames(file: File, chanel: Channel<Bitmap>) = async(CommonPool) {\n        val step = 333333L //tried to get each third frame\n        val duration = getVideoDurationInSeconds().toInt()\n        for (i in (step..duration) step 33333L) { //For some reason getting compilation error when using step function\n            val looper = step + i\n            val bitmap = getVideoFrame(looper)\n            if (bitmap != null) {\n                if (!chanel.isClosedForReceive)\n                    chanel.send(bitmap)\n                frameList.add(bitmap)\n            } else Log.e(\"FRAMER\", \"Crashed frame number $i step $looper\")\n        }\n\n        deleteFile(file)\n        retriever.release()\n        frameList\n    }\n"
        },
        {
            "code": "\nsuspend fun foo() {}\nsuspend fun bar() {\n    return foo()\n}\n"
        },
        {
            "code": "\nfun main(args : Array<String>) {\n    for(i in 10 downTo 0 step 2) {}\n    for(i in 1..20 step 2) {}\n    \n    val p = 1..2\n    for(i in p) {}\n    \n    val p2 = 1..2 step 2\n    for(i in p2) {}\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val (a) = Pair(1, 2)\n    // val (*, b) = Pair(1, 2) // not yet supported\n}\n"
        },
        {
            "code": "\n@native interface A {\n    var i: Int\n}\n\nclass C : A {\n       override var i: Int = 2\n}\n\nfun main(args: Array<String>) {\n\tval o = object : A {\n        override var i = 1\n    }\n    \n    println(js(\"Object.getOwnPropertyNames(o)\"))\n    val c = C()\n    println(js(\"Object.getOwnPropertyNames(c)\"))\n}\n"
        },
        {
            "code": "\ni\ni\n"
        },
        {
            "code": "\nfun g() {\n    println(\"Something\")\n}\n\nfun main(args: Array<String>) {\n\n    val d = g()\n    println(d)\n    val u = Unit\n    println(u)\n    if (u==d) {\n        println(\"Yes\")\n    } else {\n        println(\"No\")\n    }\n    \n}\n"
        },
        {
            "code": "\nval arr = arrayOf(\"aa\", 1, null, charArrayOf('d'))\nassertEquals(\"[aa, 1, null, [d]]\", arr.contentDeepToString())\n"
        },
        {
            "code": "\nNotificationOptions(\n        body = \"test me\",\n        icon = \"\",\n        vibrate = null,\n        sound = \"\"\n)\n"
        },
        {
            "code": "\nfun main(args : Array<String>) {\n    array(0, 1)\n    var a = array(0, 1)\n    println(array(0, 1))\n    println(array(0, 1) == array(0, 1))\n}\n"
        },
        {
            "code": "\nclass A {\n    var i: Int = 0\n//     \tget() {\n//             println(\"get(), i = ${$i}\")\n//           return $i  \n//         } \n//     \tset(v) {\n//             println(\"set($v), i = ${$i}\")\n//             $i = v\n//         }\n}\nfun main(args : Array<String>) {\n  var a = A();\n  a.i++;\n  js(\"a.i++\")\n}\n"
        },
        {
            "code": "\npackage foo\n\nopen class Foo {\n    internal inline fun bar(noinline bazz: () -> Unit = {}) {\n    }\n}\n"
        },
        {
            "code": "\nclass Test {\n  internal inline fun test(noinline fn: () -> Unit = {}) = Unit\n}\n"
        },
        {
            "code": "\nval flag = true\n\nfun box(): String {\n  val test = if (flag) {} else Unit\n  return if (test == Unit) \"OK\" else \"Fail: $test\"\n}\n"
        },
        {
            "code": "\nfun test1(): Unit = Unit\n//returns 'undefined'\n//  test1: function () {\n//      Kotlin.kotlin.Unit;\n//  }\n\nfun test2(): Unit? = test1()\n//returns 'undefined'\n//  test2: function () {\n//      return _.test.test1();\n//  }\n\nfun test3(): Unit? = Unit\n//returns 'kotlin.Unit'\n//  test3: function () {\n//      return Kotlin.kotlin.Unit;\n//  }\n"
        },
        {
            "code": "\npackage test\n\nclass C {\n    fun foo() {}\n}\n\nfun test(nc: C?) =\n        nc?.foo()\n"
        },
        {
            "code": "\nfun test() {\n    for (i in 1..5) {\n\t\tval a = if (i%2==0) {/*EMPTY!*/} else {i}\n        println(a)\n    }\n}\n"
        },
        {
            "code": "\nfun test() {\n    for (i in 1..5) {\n\t\tval a = foo(i)\n        println(a)\n    }\n}\ninline fun foo(i : Int) = if (i%2==0) {/*EMPTY!*/} else {i}\n"
        },
        {
            "code": "\nval nx: Any? = '0'\n\nfun box(): String =\n        when {\n            '0' != nx -> \"Fail 0\"\n            else -> \"OK\"\n        }\n"
        },
        {
            "code": "\nfun bar(i: Int) {\n    //do nothing\n}\n\nfun foo1() {\n    for (i in 1..10) {\n        bar(i)\n    }\n}\n\nfun foo2() {\n    for (i in (1..10)) { // difference only in parentheses\n        bar(i)\n    }\n}\n\nfun main(args: Array<String>) {\n    foo1()\n    foo2()\n}\n"
        },
        {
            "code": "\nclass Foo(val map: Map<String, Any?>) {\n    @JsName(\"a\") val `;`: String by map\n}\n\nfun main(args: Array<String>) {\n    val user = Foo(mapOf(\";\" to \"a\"))\n}\n"
        },
        {
            "code": "\nvar l = \"\"\n\nfun log(message: String) {\n    l += message + \";\"\n}\n\nfun baz(x: String){\n    log(\"baz($x)\")\n}\nfun baz(x: String, i: Int) {\n    log(\"baz($x, $i)\")\n}\n\ninline fun bar() {\n    boo {\n        baz(\"AAA\")\n        foo()\n    }\n}\n\nfun boo(x: () -> Unit) = x()\n\ninline fun foo() {\n    log(\"foo()\")\n    baz(\"BBB\", 333)\n}\n\nfun box(): String {\n    bar()\n    if (l != \"baz(AAA);foo();baz(BBB, 333);\") return \"fail: $l\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "\npackage test\n\nfun main(args: Array<String>) {\n    System.getProperty(\"yay\").length\n}\n"
        },
        {
            "code": "\ninline fun Double.foo(f: (Double) -> Double): Double {\n    return f(this)\n}\n\nfun bar() {\n    0.5.foo(if (true) Math::ceil else Math::floor)\n}\n"
        },
        {
            "code": "\ninline fun Double.foo(f: (Double) -> Double): Double {\n    return f(this)\n}\n\nfun bar(f: (Double) -> Double) {\n    0.5.foo(f)\n}\n"
        },
        {
            "code": "\npackage test\n\nimport java.util.function.Consumer\n\ninline fun makeRunnable(crossinline lambda: () -> Unit) =\n        object : Runnable {\n            override fun run() {\n                lambda()\n            }\n        }\n\nfun main(args: Array<String>) {\n    makeRunnable {\n        J.invokeWithNull(object : Consumer<Any> {\n            override fun accept(t: Any) { // NB t is non-null\n                println(t)\n            }\n        })\n    }.run()\n}\n"
        },
        {
            "code": "\n    val a : dynamic = \"123\"\n    println(a.`length + 12`)\n    println(a.`length + Math.random`())\n"
        },
        {
            "code": "\n    var a = '123';\n    println(a.length + 12);\n    println(a.length + Math.random());\n"
        },
        {
            "code": "\nfun test(d: dynamic) {\n    d.`hello-world` =  1\n}\n"
        },
        {
            "code": "\npackage a\n\nimport b.*\n\nclass Child: Parent()\n\nfun main(args: Array<String>) {\n  Child().b()\n}\n"
        },
        {
            "code": "\npackage b\n\nimport c.*\n\nopen class Parent {\n  inline fun b() = c()\n}\n"
        },
        {
            "code": "\npackage c\n\nfun c() {}\n"
        },
        {
            "code": "\nprivate fun nullable(): Int? = null\nprivate fun otherwise(): Int = 1\nprivate fun inc(i: Int) = i + 1\n\nprivate fun letElvis(): Int =\n    nullable()?.let { inc(it) } ?: otherwise()\n\nprivate fun ifElse(): Int {\n  val nullable = nullable()\n  return if (nullable != null) inc(nullable)\n  else otherwise()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    foo(1)\n}\n\ninline fun <reified T : Any> foo(arg: T) {\n    val intClass = Int::class\n    println(T::class == Int::class.java)\n    println(T::class == intClass) \n//     when (null) { Int::class.java, intClass -> { println(\"hello\") } }\n    println(T::class == intClass)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    foo(1)\n}\n\ninline fun <reified T : Any> foo(arg: T) {\n    println(T::class == Int::class.java)\n    println(T::class == Int::class)\n    when (T::class) { Int::class.java, Int::class -> { println(\"hello\") } }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(42.doSwitchInt()) // blam!\n    println(\"\".doSwitchString()) // success\n}\n\ninline fun <reified E> E.doSwitchInt(): String = when(E::class) {\n    Int::class -> \"success!\"\n    else -> \"blam!\"\n}\n\ninline fun <reified E> E.doSwitchString(): String = when(E::class) {\n    String::class -> \"success!\"\n    else -> \"blam!\"\n}\n"
        },
        {
            "code": "\ninline fun bar(crossinline f: () -> Int) = { f() }\n"
        },
        {
            "code": "\ninline fun foo(crossinline f: () -> Int) = fun () = f()\n"
        },
        {
            "code": "\nexternal object Test {\n    fun test(vararg rest: dynamic)\n}\n\nfun test2(vararg rest: dynamic) {\n    test(*rest)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val b = B()\n\n    println(b.getFooA())\n    println(b.getFooB())\n    println(b.getBarA())\n    println(b.getBarB())\n}\n\nopen class A {\n    open val foo by lazy {\n        \"A.foo\"\n    }\n\n    private val bar by lazy {\n        \"A.bar\"\n    }\n\n    fun getBarA() = bar\n}\n\nclass B : A() {\n    override val foo by lazy {\n        \"B.foo\"\n    }\n\n    private val bar by lazy {\n        \"B.bar\"\n    }\n\n    fun getFooB() = foo\n    fun getFooA() = super.foo\n    fun getBarB() = bar\n}\n"
        },
        {
            "code": "\nA.foo\nB.foo\nA.bar\nB.bar\n"
        },
        {
            "code": "\nB.foo\nB.foo\nB.bar\nB.bar\n"
        },
        {
            "code": "\nimport org.json.JSONException\nimport org.json.JSONObject\n\nclass TestExtraConst {\n    companion object {\n        private const val JSON = \"{}\"\n\n        fun getJsonObject(): JSONObject? {\n            return try {\n                JSONObject(JSON)\n            } catch (e: JSONException) {\n                null\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\nimport java.util.*\n\nclass MySet : TreeSet<Int>() {\n    override fun remove(element: Int): Boolean {\n        return super.remove(element)\n    }\n}\n\nfun main(args: Array<String>) {\n    MySet()\n}\n"
        },
        {
            "code": "\nopen class A<T> {\n\n    inline suspend fun foo() {\n        bar()\n    }\n}\n\nsuspend fun bar() {\n    TODO()\n}\n\nsuspend fun A<Unit>.baz() = foo()\n"
        },
        {
            "code": "\nfun foo(): Boolean {\n    val map: Map<String, Boolean>? = mapOf()\n    return map?.get(\"\") == true\n}\n"
        },
        {
            "code": "\ndata class ThingsData(val things: List<Thing>) \n{\n  // synthetic property\n  val hasTrueThing get() = things.firstOrNull()?.field == true\n}\n\ndata class Thing(val field: Boolean?)\n\nfun main(args: Array<String>) {\n    val testData = ThingsData(things = listOf(Thing(null)))\n    println(testData.hasTrueThing) // <-- crashes here\n}\n"
        },
        {
            "code": "\n  val hasTrueThing: Boolean get() {\n    val temp = things.firstOrNull()?.field\n    return temp == true\n  }\n"
        },
        {
            "code": "\nfun tryMe() {\n    try {\n        println(\"I'm trying...\")\n    } finally {\n        println(\"Done trying\")\n    }\n}\n"
        },
        {
            "code": "\nclass KT19779_SSCCE {\n\n    private val pipeScheduler = FakePipeScheduler2()\n\n    @Test fun `when using a suspend operator should successfully compile`() = runBlocking {\n        pipeScheduler += \"a\" to RuntimeException(\"blam!\")\n    }\n\n    class FakePipeScheduler2 {\n        suspend operator fun plusAssign(requestResponsePair: Any): Unit {\n            TODO()\n        }\n    }\n}\n"
        },
        {
            "code": "\npublic inline fun String.indexOf(ch : Char): Int = indexOf(ch.toString())\n"
        },
        {
            "code": "\nval semi = stringVar.indexOf(';')\n"
        },
        {
            "code": "\nvar semi = indexOf(contentType, ';');\n"
        },
        {
            "code": "\nvar semi = contentType.indexOf(';');\n"
        },
        {
            "code": "\npackage com.empowerops.language\n\nimport org.junit.Test\nimport javax.inject.Inject\nimport javax.inject.Provider\n\nclass NoSuchMethodSSCCE{\n\n    @Test fun `asking for statically initialized field should not get NoSuchMethodError`(){\n        OptimizationExecutor2.NullInstance\n    }\n}\n\nopen class OptimizationExecutor2 @Inject constructor(\n        private val optimizerProvider: Provider<Int>\n) {\n\n    class Null : OptimizationExecutor2(Provider { throw IllegalStateException() })\n\n    companion object {\n\n        val NullInstance: OptimizationExecutor2 = Null()\n    }\n}\n\n"
        },
        {
            "code": "\nobject Singleton {\n    @JvmField val INSTANCE = \"42\"\n    @JvmField val INSTANCE = 42\n}\n"
        },
        {
            "code": "\nobject Singleton {\n    @JvmField val INSTANCE = Singleton\n}\n"
        },
        {
            "code": "\nobject Singleton {\n    @JvmField val INSTANCE = \"42\"\n}\n"
        },
        {
            "code": "\n// Not necessarily List<*> is required, can be any type with wildcard, originally I had\n// Array<Interactor<*,*>>\nabstract class BaseClass(private val array: Array<List<*>>) {\n\n}\n\nclass MyClass(private val s: String) : BaseClass(arrayOf(arrayListOf(s))) {\n\n}\n\n// elsewhere\nval v = MyClass(\"hello\")\nprintln(v)\n"
        },
        {
            "code": "\ninterface MyInterface {\n    fun something() {\n        val thing by lazyOf(1)\n    }\n}\n"
        },
        {
            "code": "\npackage foo\n\nvar log = \"\"\nfun log(a: String) {\n    log += a + \";\"\n}\n\ninterface C {\n    fun foo(x: Int): Unit {\n        log(\"C.foo($x)\")\n    }\n}\n\ninterface I {\n    fun foo(x: Int = 1): Unit\n}\n\nclass G(c: C) : C by c, I\nclass H(c: C) : I, C by c\n\nfun test1(): String {\n    log = \"\"\n    \n    val g1 = G(object: C {})\n    g1.foo(2)\n    g1.foo()\n    val g2 = G(object: C {\n        override fun foo(x: Int) {\n            log(\"[2] object:C.foo($x)\")\n        }\n    })\n    g2.foo(2)\n    g2.foo()\n\n    if (log != \"C.foo(2);C.foo(1);[2] object:C.foo(2);[2] object:C.foo(1);\") return \"log = $log\"\n\n    return \"OK\"\n}\n\nfun test2(): String {\n    log = \"\"\n    \n    val h1 = H(object: C {})\n    h1.foo(2)\n     h1.foo()\n    val h2 = H(object: C {\n        override fun foo(x: Int) {\n            log(\"[2] object:C.foo($x)\")\n        }\n    })\n    h2.foo(2)\n    h2.foo()\n\n    if (log != \"C.foo(2);C.foo(1);[2] object:C.foo(2);[2] object:C.foo(1);\") return \"log = $log\"\n\n    return \"OK\"\n}\n\n\nfun main(args: Array<String>) {\n    println(test1())\n    try {\n\t    println(test2())\n    }\n    catch(e: dynamic) {\n        println(e)\n    }\n}\n"
        },
        {
            "code": "\nclass PrivateVarInline {\n    @Volatile\n    private var state: Int = 0\n    \n    private inline fun loopOnState(block: (Int) -> Unit) {\n        while (true) {\n            block(state)\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    A().i = B.I {}\n}\n"
        },
        {
            "code": "\nclass C: B {\n    constructor() {\n        this.i = I {}\n    }\n}\n"
        },
        {
            "code": "\ninterface Iface<in T>  {\n    fun f(t: T = error(\"no T passed\")): Any\n}\n\nclass Impl : Iface<Int> {\n    override fun f(t: Int): Any = this\n}\n\nfun main(args: Array<String>) {\n    val i = Impl()\n    i.f()\n}\n"
        },
        {
            "code": "\ninterface A\ninterface B\n\nclass C1 : A, B\nclass C2 : A, B\n\nopen class SomeClass(a: A)\n\nclass SomeOtherClass : SomeClass(if (true) C1() else C2())\n\nfun main(args: Array<String>) {\n    SomeOtherClass()\n}\n"
        },
        {
            "code": "\nsuspend inline fun <R> Mutex.withLock(action: () -> R): R {\n    lock()\n    try {\n        return action()\n    } finally {\n        unlock()\n    }\n}\n"
        },
        {
            "code": "\nprivate fun run(file: File, keyIndex: Int, valueIndex: Int) = runBlocking {\n    val maxFieldIndex = maxOf(keyIndex, valueIndex)\n\n    val partition1 = RandomAccessFile(file, \"r\")\n    val partition2 = RandomAccessFile(file, \"r\")\n\n    val fileLength = file.length()\n    var secondPartitionStartIndex = fileLength / 2L\n\n    partition2.seek(secondPartitionStartIndex)\n\n    while (true) {\n        val byte = partition2.read()\n        secondPartitionStartIndex++\n        if (byte < 0 || byte.toChar() == '\\n') {\n            break\n        }\n    }\n\n    val firstPartitionMaxEntry = async(CommonPool) {\n        maxOfPartition(partition1, keyIndex, valueIndex, maxFieldIndex, secondPartitionStartIndex.toInt())\n    }\n\n    val secondPartitionMaxEntry = async(CommonPool) {\n        maxOfPartition(partition2, keyIndex, valueIndex, maxFieldIndex, fileLength.toInt())\n    }\n\n    val maxEntry = listOf(firstPartitionMaxEntry, secondPartitionMaxEntry)\n            .map { it.await() }\n            .maxBy { it.component2().int }\n\n    if (maxEntry == null || maxEntry.first.isEmpty()) {\n        println(\"No entries\")\n    } else {\n        val (key, value) = maxEntry\n        println(\"max_key: $key, sum: $value\")\n    }\n}\n"
        },
        {
            "code": "\nprivate suspend fun maxOfPartition(partition: RandomAccessFile,\n                                   keyIndex: Int,\n                                   valueIndex: Int,\n                                   maxFieldIndex: Int,\n                                   lastByteIndex: Int): Pair<String, IntBox>\n"
        },
        {
            "code": "\npackage test\n\nopen class Base {\n    @JvmField val x = \"O\"\n}\n\nclass Host: Base() {\n    fun foo() = bar(x)\n\n    companion object {\n        val x = \"K\"\n\n        fun bar(s: String) = s + x\n    }\n}\n\nfun main(args: Array<String>) {\n    println(Host().foo())\n}\n"
        },
        {
            "code": "\nprivate inline fun <reified T> Gson.fromJson(json: String): T =\n        gson.fromJson<T>(json, object : TypeToken<@JvmSuppressWildcards T>() {}.type)\n"
        },
        {
            "code": "\ngson.fromJson<@JvmSuppressWildcards Pair<Map<SomeEnum, Int>, Unit>>(json)\n// TypeToken:\n// kotlin.Pair<? extends java.util.Map<...SomeEnum, ? extends java.lang.Integer>, ? extends kotlin.Unit>\n"
        },
        {
            "code": "\ngson.fromJson<Pair<Map<SomeEnum, Int>, Unit>>(json, object : TypeToken<@JvmSuppressWildcards Pair<Map<SomeEnum, Int>, Unit>>() {}.type)\n// TypeToken:\n// kotlin.Pair<java.util.Map<...SomeEnum, java.lang.Integer>, kotlin.Unit>\n"
        },
        {
            "code": "\nabstract class Base(params: Array<Any>)\n\nclass Derived() : Base(arrayOf(1))\n"
        },
        {
            "code": "\nabstract class Base(params: Array<Any> = emptyArray())\n"
        },
        {
            "code": "\nabstract class Base(val params: Array<Any> = emptyArray())\n\nclass Derived() : Base(arrayOf(1))\n\nfun main(args: Array<String>) {\n    println(Derived().params.contentToString()) // prints \"[]\"\n}\n"
        },
        {
            "code": "\npackage test\n\nclass Service {\n    private val disposable = \"\"\n\n    fun doSomeWork() {\n        apply {\n            println(disposable.length)\n        }\n    }\n\n    companion object {\n        val disposable = 5\n    }\n}\n\nfun main(args: Array<String>) {\n    Service().doSomeWork()\n}\n"
        },
        {
            "code": "\nclass Service {\n        private val disposable = CompositeDisposable()\n        fun doSomeWork(){\n            disposable.add(Disposables.empty())\n        }\n        companion object {\n            var disposable: Disposable? = null\n        }\n    }\n"
        },
        {
            "code": "\nobject Caller {\n    private val map: MutableMap<Performer, MutableList<String>> = mutableMapOf()\n    fun call(transform: Performer) {\n        map.computeIfAbsent(transform, { mutableListOf() })\n    }\n}\n\nfun main(args: Array<String>) {\n    val performer = Performer { TODO() }\n    Caller.call(performer)\n}\n"
        },
        {
            "code": "\nimport Foo.bar0 as bar\n\nobject Foo {\n    val bar0 = \"OK\"\n\n    fun test() = bar\n}\n\nfun main(args: Array<String>) {\n    println(Foo.test())\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n\tval nano = 3L.toNanoSeconds(from = TimeUnit.SECONDS)\n\tprintln(nano)\n}\n\nprivate inline fun Long.toNanoSeconds(from: TimeUnit): Long = when (from) {\n\tTimeUnit.NANOSECONDS -> this\n\tTimeUnit.MICROSECONDS -> this * 1_000\n\tTimeUnit.MILLISECONDS -> this * 1_000_000\n\tTimeUnit.SECONDS -> this * 1_000_000_000\n\tTimeUnit.MINUTES -> this * 1_000_000_000 * 60\n\tTimeUnit.HOURS -> this * 1_000_000_000 * 60 * 60\n\tTimeUnit.DAYS -> this * 1_000_000_000 * 60 * 60 * 24\n}\n"
        },
        {
            "code": "\ntypealias NumberType = Double\n\ninline fun Number.toNumberType() = when (NumberType::class) {\n    Double::class -> this.toDouble() as NumberType\n    Float::class -> this.toFloat() as NumberType\n    Long::class -> this.toLong() as NumberType\n    Int::class -> this.toInt() as NumberType\n    Short::class -> this.toShort() as NumberType\n    Byte::class -> this.toByte() as NumberType\n    else -> throw IllegalArgumentException(\"NumberType must be in [Double, Float, Long, Int, Short, Byte]\")\n}\n"
        },
        {
            "code": "\nfun test(p: Pair<Int, Int>) {\n    val (x, y) = p\n//  ACONST_NULL\n//  ASTORE 3    \n}\n"
        },
        {
            "code": "\nabstract class Introspector<M : Model>(protected val model: Model) {\n    protected abstract inner class Retriever(protected val transaction: Any) {\n        protected var model: Model = this@Introspector.model\n    }\n\n    protected abstract inner class SchemaRetriever(transaction: Any): Retriever(transaction) {\n        protected inline fun inSchema(crossinline modifier: (Any) -> Unit) =\n                model.modify { schema -> modifier.invoke(schema) }\n    }\n}\n"
        },
        {
            "code": "\nclass IntrospectorImpl(model: ModuleImpl) : Introspector<ModuleImpl>(model) {\n    private inner class SchemaRetriever(transaction: Any) : Introspector<ModuleImpl>.SchemaRetriever(transaction) {\n        internal fun retrieve() {\n            inSchema { schema -> println(schema) }\n        }\n    }\n}\n\nclass ModuleImpl : Model {\n    override fun modify(modifier: ModelModifier) {}\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    var s: String? = \"abc\"\n    println(s + \"d\")\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val map = hashMapOf<String, String>()\n    map[\"foo\"] += \"bar\"\n} \n"
        },
        {
            "code": "\nfun <T> ReceiveChannel<T>.reduce(reducer: (T, T) -> T) = produce<T>(Unconfined) {\n    var prev: T? = null            // Line 1        \n    for (elem in this@reduce) {    // Line 2\n        if (prev == null) {\n            prev = elem\n            send(elem)\n        } else {\n            val new = reducer(prev, elem) \n            prev = new                        \n            send(new)   \n        }\n    }\n}\n\nprivate fun numbers() = produce(CommonPool) {\n    repeat(5) {\n        send(it)\n        delay(500) \n    }\n}\n\nfun main(args: Array<String>) = runBlocking<Unit> {\n    numbers().reduce { prev, curr -> prev + curr }.consumeEach { println(it) }\n}\n"
        },
        {
            "code": "\n0\n1\n3\n6\n10\n"
        },
        {
            "code": "\n0\n1\n2\n3\n4\n"
        },
        {
            "code": "\npackage test\n\nfun someCondition(): Boolean? = true\n\nfun test() {\n    if (someCondition() ?: false) { // *\n        println(\"true\")\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\nfun someCondition(): Boolean? = true\n\nfun test() {\n    if (someCondition() == true) {\n        println(\"true\")\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\nopen class KFoo {\n    fun foo(): String {\n        if (this is KFooBar) return bar\n        throw AssertionError()\n    }\n}\n\nclass KFooBar : KFoo(), JBar\n\nfun main(args: Array<String>) {\n    println(KFooBar().foo())\n}\n"
        },
        {
            "code": "\nopen class KFoo {\n    fun foo(): String {\n        if (this is KFooQux) return qux\n        throw AssertionError()\n    }\n}\n\nclass KFooQux : KFoo()\nval KFooQux.qux get() = \"OK\"\n\nfun main(args: Array<String>) {\n    println(KFooQux().foo())\n}\n"
        },
        {
            "code": "\nfun eval(x: Int, message: String): Int {\n    println(message)\n    return x\n}\n\nfun main(args: Array<String>) {\n    if (0 in eval(1, \"low-1\") .. eval(100, \"high-1\"))\n        println(\"yes\")\n    else\n        println(\"no\")\n\n    if ((eval(1, \"low-2\") .. eval(100, \"high-2\")).contains(0))\n        println(\"yes\")\n    else\n        println(\"no\")\n\n    if (0 >= eval(1, \"low-3\") && 0 <= eval(100, \"high-3\"))\n        println(\"yes\")\n    else\n        println(\"no\")\n}\n"
        },
        {
            "code": "\nlow-1\nno\nlow-2\nhigh-2\nno\nlow-3\nno\n"
        },
        {
            "code": "\nfun test(x: Int, a: Any) = x == a\n"
        },
        {
            "code": "\npackage test\n\nfun foo(): Any? = 42L\n\nfun test() {\n    val b = foo()\n    if (b is Long && b == 42L) {\n        println(\"magic!\")\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\nfun test2() =\n        JFoo.foo2<String>(\n                { _ -> },\n                null // (*)\n        )\n"
        },
        {
            "code": "\nfun test1() = JFoo.foo1(null)\n"
        },
        {
            "code": "\nfun test() {\n    val s = \"\"\n}\n"
        },
        {
            "code": "\nprivate fun when1(number: Int) = when (number) {\n\t0 -> \"zero\"\n\t1 -> \"one\"\n\telse -> \"other\"\n}\n\nprivate fun when2(number: Int): String {\n\treturn when (number) {\n\t\t0 -> \"zero\"\n\t\t1 -> \"one\"\n\t\telse -> \"other\"\n\t}\n}\n\nprivate fun when3(number: Int): String {\n\twhen (number) {\n\t\t0 -> return \"zero\"\n\t\t1 -> return \"one\"\n\t\telse -> return \"other\"\n\t}\n}\n"
        },
        {
            "code": "\nprivate fun if1(number: Int) = if (number == 0) {\n\t\"zero\"\n} else if (number == 1) {\n\t\"one\"\n} else {\n\t\"other\"\n}\n\nprivate fun if2(number: Int): String {\n\treturn if (number == 0) {\n\t\t\"zero\"\n\t} else if (number == 1) {\n\t\t\"one\"\n\t} else {\n\t\t\"other\"\n\t}\n}\n\nprivate fun if3(number: Int): String {\n\tif (number == 0) {\n\t\treturn \"zero\"\n\t} else if (number == 1) {\n\t\treturn \"one\"\n\t} else {\n\t\treturn \"other\"\n\t}\n}\n"
        },
        {
            "code": "\ninterface IA {\n    fun f()\n}\n\nclass ABC {\n    private companion object Comp : IA {\n        override fun f() {}\n    }\n}\n"
        },
        {
            "code": "\nfun test(a: Any?) = a == JavaClass.CONST_NULL\n"
        },
        {
            "code": "\nfun test(s: String?) =\n        when (s?.length) {\n            null -> \"null\" \n            0 -> \"empty\"\n            1 -> \"one\"\n            2 -> \"two\"\n            else -> \"many\"\n        }\n"
        },
        {
            "code": "\nfun test1(a: Any?) {\n    val n: Any? = null\n    if (a == n) {\n        println(\"null\")\n    }\n}\n\nfun test2(a: Any?) {\n    if (a == null) {\n        println(\"null\")\n    }\n}\n"
        },
        {
            "code": "\nprivate interface I {\n\tfun method()\n}\n\nprivate class A : I {\n\toverride fun method() {\n\t\tprintln(\"test\")\n\t}\n}\n\nprivate inline fun test(obj: I, function: (I) -> Unit) {\n\tfunction(obj)\n}\n\nfun main(args: Array<String>) {\n\ttest(A(), I::method)\n}\n"
        },
        {
            "code": "\nprivate class IntIterable(private vararg val elements: Int) : Iterable<Int> {\n\toverride fun iterator(): IntIterator = elements.iterator()\n}\n\nprivate inline fun <T> test(elements: Iterable<T>, function: (T) -> Unit) {\n\tfor (element in elements) {\n\t\tfunction(element)\n\t}\n}\n\nfun main(args: Array<String>) {\n\ttest(IntIterable(1, 2, 3)) { println(it) }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    // println(listOf(true).map(true::equals))\n    true::equals\n}\n"
        },
        {
            "code": "\nprivate fun test(list: List<String>) {}\n\nfun main(args: Array<String>) {\n\tval arrayList = ArrayList<String>()\n\ttest(arrayList)\n}\n"
        },
        {
            "code": "\nenum class X { \n    A, B;\n    val isA get() = this === A \n}\n"
        },
        {
            "code": "\nobject OnlyJvmStatic {\n    @JvmStatic\n    val prop = \"Example\"\n\n    @JvmStatic\n    fun someMethod() {\n    }\n}\n"
        },
        {
            "code": "\nval arr = IntArray(20, 10::pow) // compiler crash\nval arr1 = IntArray(20) { 10.pow(it) } // compiles\nval arr2 = Array(20, \"\"::pow) // compiles\n\nfun Int.pow(num: Int) = 5\nfun String.pow(num: Int) = 3\n"
        },
        {
            "code": "\nfun test(x: Long, low: Int, high: Int) = \n        x in low..high\n"
        },
        {
            "code": "\nfun test(a: IntArray) = 42 in a.indices\n"
        },
        {
            "code": "\nfun test1(x: Int, low: Int, high: Int) {\n    if (x in low..high) {\n        println(\"Yes\")\n    }\n}\n"
        },
        {
            "code": "\nfun test2(x: Int, low: Int, high: Int) {\n    if (x >= low && x <= high) {\n        println(\"Yes\")\n    }\n}\n"
        },
        {
            "code": "\nfun testString(x: String, a: String, b: String) =\n        if (x !in a .. b) \"no\" else \"yes\"\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    // Should be KNPE!\n    val f = System.getProperty(\"abcde\")::capitalize\n\n    // This line is successfully executed\n    println(f)\n\n    // NPE only happens here\n    println(f())\n}\n"
        },
        {
            "code": "\nfun test(x: Any) = x.run { hashCode() }\n"
        },
        {
            "code": "\ninline fun <T, R> T.run2(f: T.() -> R) = f()\n\nfun test2(x: Any) = x.run2 { hashCode() }\n"
        },
        {
            "code": "\nsealed class ApiResult<Response : Any> {\n\n\tdata class Failure<Response : Any>(\n\t\tval exception: FailureException\n\t) : ApiResult<Response>()\n\n\n\tdata class Success<Response : Any>(\n\t\tval iterator: String?,\n\t\tval response: Response?\n\t) : ApiResult<Response>()\n}\n"
        },
        {
            "code": "\n//suspend inline fun <reified T : Scene> changeTo(\n// \tvararg injects: Any,\n// time: TimeSpan = 0.seconds,\n// transition: Transition = AlphaTransition\n// ) = changeTo(T::class.java, *injects, time = time, transition = transition)\n"
        },
        {
            "code": "\nfun test(a: Any, b: Any) =\n        if (a != b) \"N\" else \"Y\"\n"
        },
        {
            "code": "\nclass A(initialBigObject: Any) {\n    private val someContainer = object {\n        var ref = initialBigObject\n    }\n\n    fun updateRef(nextBigObject: Any) {\n        someContainer.ref = nextBigObject\n    }\n}\n\nfun main(args: Array<String>) {\n    val a = A(object { val name = \"First\" })\n    a.updateRef(object { val name = \"Second\" })\n}\n"
        },
        {
            "code": "\nval il = listOf(1, 2, 3)\nfun test() = il.maxBy { it }\n"
        },
        {
            "code": " kotlin\ninterface Listener {\n        val order: Int;\n    \n        companion object {\n            private var calls = 0;\n            val order = calls++;\n            val implementation = object : Listener {\n                override val order = calls++; // threw a java.lang.ExceptionInInitializerError \n            }\n        }\n}\n"
        },
        {
            "code": "\nval v = 42.0\nv.hashCode()  // => Double.valueOf(v).hashCode()\n"
        },
        {
            "code": "\ninline fun foo( f : () -> Unit ) {\n    a@ for (i in 1..2) {\n        f()\n        break\n    }\n}\n\n\nfun main(args: Array<String>) {\n\n    foo {foo {foo {foo {foo {foo {foo {foo {\n        foo {foo {foo {foo {foo {foo {foo {foo {\n            foo {foo {foo {foo {foo {foo {foo {foo { //here is 24 foo's\n                println(42)\n            }}}}}}}}}}}}}}}}}}}}}}}}\n\n}\n"
        },
        {
            "code": "\nabstract class A {\n    suspend open fun run() { // function need to be non-final to reproduce the bug \n    }\n}\n\nclass C : A()\n"
        },
        {
            "code": "\nconst val TARGET = \"world\"\n\nfun printMessageNormal() {\n    println(\"Hello \" + TARGET + \"!\")\n}\n\nfun printMessageTemplate() {\n    println(\"Hello $TARGET!\")\n}\n"
        },
        {
            "code": "\nfun test1(a: String, b: String, c: String) = \n        a + (b + c)\n"
        },
        {
            "code": "\ninline fun Int.until(other: Int) = this..other - 1\n\nfor (i in 1 until 2) {} // Unnecessary IntRange object is created\n"
        },
        {
            "code": "\nimport javax.persistence.Entity\n\n@Entity\nclass Foo(foo: String) {\n    private val bar = foo\n}\n"
        },
        {
            "code": "\ninline fun <reified `-`> foo(t : `-`) {\n\tprintln(t)\n    println(`-`::class)\n} \n\nfun main(args: Array<String>) {\n    val a = foo(1)\n}\n"
        },
        {
            "code": "\n    val a: Any? = arrayOf(null, 1)\n    println(a)               // prints ,1\n    println(a.toString())    // prints [null, 1]\n    println(a!!.toString())  // prints ,1\n"
        },
        {
            "code": "\nobject O {\n    const val a = 1\n    val b = foo()\n    fun foo() : Int {\n        println(a)\n        return 2\n    }\n}\n\nobject P {\n    val b = foo() // in this object declaration of a and b are reversed\n    const val a = 1\n    fun foo() : Int {\n        println(a)\n        return 2\n    }\n}\n\nfun main(args: Array<String>) {\n    println(O.b)\n    println(P.b)\n}\n"
        },
        {
            "code": "\nfun builder(block: suspend () -> Unit) {} // any coroutine builder, impl not important\nsuspend fun dummy() {} // any suspending function, impl not important\n\nsuspend fun problem(): Unit = suspendCoroutine<Unit> { cont ->\n    builder {\n        dummy() // suspend fun for different(!) coroutine started by builder\n    }\n    cont.resume(Unit)\n}\n"
        },
        {
            "code": "\n\n\nimport kotlin.coroutines.experimental.*\n\n\nfun main(args: Array<String>) {\n    val cont = TestContinuation()\n\n    val test: suspend () -> Unit = {\n        println(\"before\")\n        suspendCoroutine<Unit> { c -> c.resume(Unit) }\n        println(\"after\")\n    }\n\n    test.startCoroutine(cont)\n}\n\n\nprivate class TestContinuation : Continuation<Unit> {\n    override val context: CoroutineContext = EmptyCoroutineContext\n\n    override fun resume(value: Unit) {\n        println(\"resume\")\n    }\n\n    override fun resumeWithException(exception: Throwable) {\n        println(\"resume with exception!!!!\")\n        exception.printStackTrace()\n    }\n\n}\n"
        },
        {
            "code": "\nbefore\nafter\nresume\n"
        },
        {
            "code": "\n    testAllDeclaredMembers(TestRaw::class, expectedIsRaw = true) ?:\n    testAllDeclaredMembers(TestNotRaw::class, expectedIsRaw = false)?.let { return it }\n"
        },
        {
            "code": "\n    testAllDeclaredMembers(TestRaw::class, expectedIsRaw = true)?.let { return it }\n    testAllDeclaredMembers(TestNotRaw::class, expectedIsRaw = false)?.let { return it }\n"
        },
        {
            "code": "\nfun testFindBugsWarning(strings: List<String>): List<String> {\n    return strings.filter({ it.length > 5 })\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val a: KProperty1<Array<String>, Int> = Array<String>::size\n    a.get(args)\n}\n"
        },
        {
            "code": "\nsuspend fun testFoo(s: String) {\n    println(s)\n}\n\ninline suspend fun testIS(block: () -> Unit) {\n    block()\n    testFoo(\"Test\")\n}\n\nfun testLaunch(block: suspend () -> Unit) {\n    block.startCoroutine(object : Continuation<Unit> {\n        override val context: CoroutineContext get() = EmptyCoroutineContext\n        override fun resume(value: Unit) {}\n        override fun resumeWithException(exception: Throwable) { throw exception }\n    })\n}\n\nfun main(args: Array<String>) {\n    testLaunch {\n        testIS {\n            testFoo(\"Block\")\n        }\n    }\n}\n"
        },
        {
            "code": "\nBlock\nTest\n"
        },
        {
            "code": "\nfun foo() = \"OK\"\n"
        },
        {
            "code": "\ninline fun bar() = foo()\n"
        },
        {
            "code": "\nfun box() = bar()\n"
        },
        {
            "code": "\ninterface I {\n    fun foo() {println(\"I\")}\n}\ninterface J : I {\n    override fun foo() {println(\"J\")}\n}\nopen class A : I, J \nopen class B : I by A()\n\nfun main(args: Array<String>) {\n    B().foo()\n}\n"
        },
        {
            "code": "\ninterface I {\n    fun foo() {\n        println(\"foo\")\n    }\n}\n\ninterface J : I\n\nclass A : J, I\n"
        },
        {
            "code": "\n  J.prototype.foo = I.prototype.foo;\n"
        },
        {
            "code": "\n  J.prototype.foo = I.prototype.foo;\n  A.prototype.foo = J.prototype.foo;\n"
        },
        {
            "code": "\ninline fun Any?.zap() {\n    if (this != null) println(\"not null\")\n}\n\nfun test() {\n    val heh = System.getProperty(\"heh\")\n    val z = heh!!\n    heh.zap() // (*)\n}\n"
        },
        {
            "code": "\nfun foo(a: Any) {}\n\nfun test() {\n    val heh = System.getProperty(\"heh\")\n    foo(heh)\n    foo(heh)\n}\n"
        },
        {
            "code": "\ninterface I\n\nclass A<T : I>(a: T) : T by a\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    `\"`@ while (true) {\n        break@`\"`\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    `console.log(\"Mua-ha-ha\");{//`@ while (true) {\n        break@`console.log(\"Mua-ha-ha\");{//`\n    }\n}\n"
        },
        {
            "code": "\nconsole.log(\"Hello, World\"::class.js.name)\nconsole.log(42::class.js.name)\n"
        },
        {
            "code": "\nconsole.log(String::class.js.name)\nconsole.log(Int::class.js.name)\n"
        },
        {
            "code": "\n// charcode in comments\nobject `Â¢` //162\nobject `Â£` //163\nobject `Â¤` //164\nobject `Â¥` //165\n"
        },
        {
            "code": "\npackage `//`\nclass A\n"
        },
        {
            "code": "\nval d : String? = \"\"\nval s = d + \"1\"\n"
        },
        {
            "code": "\n      var d = '';\n      var s = plus(d, '1');\n"
        },
        {
            "code": "\nval d : String = \"\" // d is not null\nval s = d + \"1\"\n"
        },
        {
            "code": "\n@JsModule(\"foo\")\nexternal fun foo(vararg arg: Any)\n\nfun bar() = foo(*arrayOf(1))\n"
        },
        {
            "code": "\nclass User(val map: Map<String, Any?>) {\n    val name: String by map\n}\n\nfun main(args: Array<String>) {\n    val user = User(mapOf(\"name\" to 42))\n    println(user.name + user.name) // actually this is number\n}\n"
        },
        {
            "code": "\nfun test(i: Int) {\n    val a: Any = i\n    println(a)\n    println(\"a=$a\")\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val name = run {\"qwe\"}        // Force compiler to actually do some concatenation\n    println(\"${'$'}name = $name\") // Wrong\n    println(\"${\"$\"}name = $name\") // Right\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) = runBlocking<Unit> {\n    foo()\n}\n\nsuspend fun foo(tries: Int = 3): String? {\n    for (i in 1..tries) {\n        val s = bar()\n        if (s is String) return s\n\n        if (i == tries) return null\n    }\n\n    throw AssertionError()\n}\n\nsuspend fun bar() = if (Math.random() < 0.5) Any() else \"\"\n"
        },
        {
            "code": "\nsuspend fun readRangeBytes(range: LongRange): ByteArray = openUse {\n\tthis.position = range.start\n\tthis.readBytes((range.endInclusive - range.start + 1).toInt())\n}\n\nAssert.assertEquals(\"ay\", file[\"hello.bin\"].readRangeBytes(1L .. 2L).toString(Charsets.UTF_8)) // CompilationException in Kotlin 1.1.1 -> Couldn't transform method node (probably related to long)\n"
        },
        {
            "code": "\nbuildSequence { (0L..200L).forEach {yield(UUID(0,it))} }\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.suspendCoroutine\n\nopen class A {\n    open suspend fun foo() {\n        suspendCoroutine<Unit> { it.resume(Unit) }\n        println(\"foo\")\n        suspendCoroutine<Unit> { it.resume(Unit) }\n    }\n}\n\nclass B : A() {\n    suspend override fun foo() {\n        super.foo() // doResume of `A::foo` will invoke `B::foo` again\n\n        suspendCoroutine<Unit> { it.resume(Unit) }\n        println(\"bar\")\n        suspendCoroutine<Unit> { it.resume(Unit) }\n    }\n}\n\n"
        },
        {
            "code": "\nval a: String? = null\nval b = a?.isBlank() == true\n"
        },
        {
            "code": "\nval a: String? = null\nval b = a?.isBlank() ?: false\n"
        },
        {
            "code": "\nfun foo(begin: Int, end: Int) {\n    for (x in begin..end) {\n    }\n}\n"
        },
        {
            "code": "\nimport java.util.stream.IntStream\nimport uk.org.winder.pi_quadrature.out\nfun main(args:Array<String>) {\n  val n = 1000000000\n  val delta = 1.0 / n\n  val startTimeNanos = System.nanoTime()\n  val pi = 4.0 * delta * IntStream.range(1, n).parallel().mapToDouble({i ->\n    val x = (i - 0.5) * delta\n    1.0 / (1.0 + x * x)\n  }).sum()\n  val elapseTime = (System.nanoTime() - startTimeNanos) / 1e9\n  out(\"pi_streams\", pi, n, elapseTime)\n}\n"
        },
        {
            "code": "\nprivate fun testNullableChar() {\n    var sum = \"\"\n    for (ch: Char? in '1' until '5') {\n        sum += (ch ?: break)\n    }\n    assertEquals(\"1234\", sum)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n\n    val t = \"test\"\n\n    val indicies = intArrayOf(1, -1, 10)\n\n    fun checkMethod(sample: String, f: (sample: String, index: Int) -> Unit) {\n        for (i in indicies) {\n            try {\n                f(sample, i)\n            } catch (e: Throwable) {\n                //print(\"\\t$e\") \n                // Actually there is different exceptions. \n                // I replaced all of them by #excp# only for readable output\n                print(\"\\t#excp#\")\n            }\n        }\n    }\n\n    print(\"indicies:\")\n    for (i in indicies) {\n        print(\"\\t$i\")\n    }\n\n    print(\"\\nsample[index]\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample[index]}\") }\n    print(\"\\nsample.elementAt(index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.elementAt(index)}\") }\n    print(\"\\nsample.dropLast(index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.dropLast(index)}\") }\n    print(\"\\nsample.padEnd(index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.padEnd(index)}\") }\n    print(\"\\nsample.padStart(index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.padStart(index)}\") }\n    print(\"\\nsample.take(index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.take(index)}\") }\n    print(\"\\nsample.takeLast(index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.takeLast(index)}\") }\n\n    print(\"\\nsample.removeRange(index..2)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.removeRange(index..2)}\") }\n    print(\"\\nsample.removeRange(2..index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.removeRange(2..index)}\") }\n\n    print(\"\\nsample.replaceRange(index..2, \\\"\\\")\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.replaceRange(index..2, \"\")}\") }\n    print(\"\\nsample.replaceRange(2..index, \\\"\\\")\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.replaceRange(2..index, \"\")}\") }\n\n    print(\"\\nsample.subSequence(index, 2)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.subSequence(index, 2)}\") }\n    print(\"\\nsample.subSequence(2, index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.subSequence(2, index)}\") }\n\n    print(\"\\nsample.slice(index..2)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.slice(index..2)}\") }\n    print(\"\\nsample.slice(2..index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.slice(2..index)}\") }\n\n    print(\"\\nsample.substring(index..2)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.substring(index..2)}\") }\n    print(\"\\nsample.substring(2..index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.substring(2..index)}\") }\n\n    print(\"\\nsample.substring(index,2)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.substring(index,2)}\") }\n    print(\"\\nsample.substring(2,index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.substring(2,index)}\") }\n\n    print(\"\\nsample.substring(index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.substring(index)}\") }\n\n    println()\n\n}\n"
        },
        {
            "code": "\nfun foo() = 0\n\nfun main(args: Array<String>) {\n\n    val i = 1/foo()\n    println(i)\n\n    val l = 1L/foo()\n    println(l)\n\n}\n"
        },
        {
            "code": "\nimport kotlin.js.Math\n\n    val pz : Double = 0.0\n    val nz : Double = -pz\n\n    println(Math.pow(pz, -1.0)) //Infinity\n    println(Math.pow(pz, -2.0)) //Infinity\n    println(Math.pow(nz, -1.0)) //-Infinity\n    println(Math.pow(nz, -2.0)) //Infinity\n"
        },
        {
            "code": "\nfun foo() = 0\n\n    val intPozitiveZero : Int = foo()\n    val intNegativeZero : Int = -foo() // here is two different int zeros!\n\n    println(Math.pow(intPozitiveZero.toDouble(), -1.0)) //Infinity\n    println(Math.pow(intNegativeZero.toDouble(), -1.0)) //-Infinity\n"
        },
        {
            "code": "\nprintln(Enum.Companion)\n"
        },
        {
            "code": "\nopen class X {\n    open suspend fun foo(message : Any) {\n        println(\"X.foo($message)\")\n        delay(100)\n    }\n}\nclass Y : X() {\n    override suspend fun foo(message: Any) {\n        super.foo(message)\n        println(\"Y.foo($message)\")\n    }\n}\nclass SuspendTest {\n    @Test\n    fun x() = runBlocking {\n        Y().foo(\"b\")\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n     val x = intArrayOf(42) as Array<Int>\n     println(x[0])\n}\n"
        },
        {
            "code": "\n    val arr: Any = charArrayOf('d')\n    println(arr is CharArray) // prints 'false', expected 'true'\n"
        },
        {
            "code": "\n val chars = charArrayOf('a', 'b', 'c')\n val ci: CharIterator = chars.iterator()\n ci.forEach(::println)\n"
        },
        {
            "code": "\na\nb\nc\n"
        },
        {
            "code": "\n97\n98\n99\n"
        },
        {
            "code": "\nfun foo() : Int {\n    js(\"return 1\")\n}\n"
        },
        {
            "code": "\nfun foo() : Int {\n    js(\"return 1\")\n    return 2\n}\n"
        },
        {
            "code": "\ninline fun foo(s: String = \"s\") {\n    /* body */\n}\n\nfun test() {\n    foo()\n}\n"
        },
        {
            "code": "\nobject SomeObject {\n    var aDefault = 0\n    inline fun inlineWithDefaults(a: Int = aDefault, b: Int? = null) {\n    }\n\n}\n\nfun inlinedUsage() {\n    SomeObject.inlineWithDefaults(a = 1)\n}\n"
        },
        {
            "code": "\nprivate var _value: String = \"old\"\nfun overrideValueAndReturnOld(newValue: String) = _value.also { _value = newValue }\n\nfun main(args: Array<String>) {\n\tprintln(overrideValueAndReturnOld(\"new\"))\n}\n"
        },
        {
            "code": " js\n  function overrideValueAndReturnOld(newValue) {\n    _value = newValue;\n    return _value;\n  }\n"
        },
        {
            "code": "\n    if (null === undefined) {\n        println(\"yes\")\n    } else {\n        println(\"no\")\n    }\n"
        },
        {
            "code": "\nfun zap(s: String) = s\n\ninline fun tryZap(string: String, fn: (String) -> Unit) {\n    fn(try { zap(string) } catch (e: Exception) { \"\" })\n}\n\nfun main(args: Array<String>) {\n    tryZap(\"\") {}\n}\n"
        },
        {
            "code": "\n\nfun returnMaybeNull():String? {\n    return if (System.currentTimeMillis() == 0L) null else \"thing\"\n}\n\ninternal inline fun Array<String>.matchAll(collector: (String) -> Unit) {\n    for (string in this) {\n        // Works:\n        // val returned = returnMaybeNull() ?: continue\n        // collector(returned)\n\n        // Crashes:\n        collector(returnMaybeNull() ?: continue)\n    }\n}\n\nfun main(args: Array<String>) {\n    arrayOf(\"strings\").matchAll {\n    }\n}\n"
        },
        {
            "code": "\nfun zap(s: String) = s\n\ninline fun tryZap(string: String, fn: (String) -> Unit) {\n    fn(try { zap(string) } finally {})\n}\n\nfun main(args: Array<String>) {\n    tryZap(\"\") {}\n}\n"
        },
        {
            "code": "\nfun zap(s: String): String? = s\n\ninline fun tryZap(s: String, fn: (String) -> String): String {\n    return fn(zap(s) ?: return \"null\")\n}\n\nfun box() = tryZap(\"OK\") { it }\n"
        },
        {
            "code": "\ninline fun alwaysOk(s: String, fn: (String) -> String): String {\n    return fn(return \"OK\")\n}\n\nfun box() = alwaysOk(\"OK\") { it }\n"
        },
        {
            "code": "\nclass A {\n    class D(\n            val i: Int? = null,\n            val b: Boolean? = null\n    )\n\n    init {\n        var nflag: Boolean? = null\n\n        val a2: String = \"123\"\n        try {\n            a2.let { a2 ->\n                nflag = false\n            }\n        } finally {\n            a2.hashCode()\n        }\n        D(null, nflag)\n    }\n}\n"
        },
        {
            "code": "\nnative\nclass Object {\n    val foo: String = noImpl\n    val bar: String? = noImpl\n}\n\nfun foo(a: Any? = \"default value\") = a\n\nfun main(args: Array<String>) {\n    val t1 = Object().foo\n    print(\"t1#0 = \")\n    println(t1)\n    println(\"t1#1 = $t1\")\n    println(\"foo(t1) = ${foo(t1)}\")\n    \n    val t2 = Object().bar\n    print(\"t2#0 = \")\n    println(t2)\n    println(\"t2#1 = $t2\")\n    println(\"foo(t2) = ${foo(t2)}\")\n}\n"
        },
        {
            "code": "\nconst val s0 = \"abcdef0123456789\"\nconst val s1 = s0 + s0 + s0 + s0 + s0 + s0 + s0 + s0\nconst val s2 = s1 + s1 + s1 + s1 + s1 + s1 + s1 + s1\nconst val s3 = s2 + s2 + s2 + s2 + s2 + s2 + s2 + s2\nconst val s4 = s3 + s3 + s3 + s3 + s3 + s3 + s3 + s3\n\nclass A{\n    @JvmName(s4)\n    fun foo () {}\n}\n"
        },
        {
            "code": "\nclass `My bad class` {\n    fun foo() {}\n}\nfun main(args: Array<String>) {\n\n    val strangeName = `My bad class`()\n    println(strangeName)\n    strangeName.foo()\n    val strangeNameObjectMethodRef = strangeName::foo\n    // OK, but:\n\n    //val strangeNameRef = ::`My bad class` //badaboom #1\n    //val strangeNameMethodRef = `My bad class`::foo //badaboom #2\n}\n"
        },
        {
            "code": "\nimport kotlin.browser.window\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn\nimport kotlin.coroutines.experimental.intrinsics.COROUTINE_SUSPENDED\n\nfun async(f: suspend () -> Unit) {\n    f.startCoroutine(object : Continuation<Unit> {\n        override fun resume(value: Unit) {}\n\n        override fun resumeWithException(value: Throwable) {}\n\n        override val context = EmptyCoroutineContext\n    })\n}\n\nfun main(args: Array<String>) {\n    async {\n        println(\"1\")\n        wait(1000)\n        println(\"2\")\n    }\n}\n\nprivate suspend fun wait(milliseconds: Int): Unit {\n    wait2()\n    println(\"waiting $milliseconds\")\n    return suspendCoroutineOrReturn { c ->\n        window.setTimeout({ c.resume(Unit) }, milliseconds)\n        COROUTINE_SUSPENDED\n    }\n}\n\nprivate suspend fun wait2(): Unit = suspendCoroutineOrReturn { c ->\n    window.setTimeout({ c.resume(Unit) }, 0)\n}\n"
        },
        {
            "code": "\nclass FavoriteSectionWidgetDataProvider @Inject constructor(\n        private val resources: Resources\n) {\n\n    companion object {\n        private const val DATA_ID_SUFFIX = \"favoriteWidget\"\n    }\n\n    fun createData(\n            titleResourceId: Int,\n            articles: List<ArticleTeaser>): List<Any> {\n\n        if (articles.isEmpty())\n            return listOf()\n\n        val sectionArticleIds = articles.map { it.id }\n\n        return listOf<Any>(\n                ListTitleData(\n                        \"startPageFavorites-title-datareferenceId\",\n                        resources.getString(titleResourceId),\n                        action = if (articles.isNotEmpty()) ListTitleDataAction(\n                                SectionIds.VIRTUAL_SECTION_FAVORITE\n                        ) else null\n                )\n        ).plus(\n                articles.map {\n                    ArticleSmallTeaserWidgetData(it, sectionArticleIds, it.id + DATA_ID_SUFFIX, showFavorite = true)\n                }\n        )\n    }\n}\n"
        },
        {
            "code": "\n@RunWith(PowerMockRunner::class)\n@PrepareForTest(\n        HighlightsService::class,\n        ArticleTeasersWidgetizer::class\n)\nclass HighlightsControllerTest {\n\n    @Mock private lateinit var highlightsService: HighlightsService\n    @Mock private lateinit var articleTeasersWidgetizer: ArticleTeasersWidgetizer\n\n    @InjectMocks lateinit var controller: HighlightsController\n\n}\n"
        },
        {
            "code": "\nval a = js(\"0xff000000\")\n"
        },
        {
            "code": "\nvar a = 0xff000000\n"
        },
        {
            "code": "\nvar a = 2147483647\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.*\n\n\nfun main(args: Array<String>) {\n    println(\"Hello, world!\")\n\n    try {\n        async {\n            println(foo(3))\n        }\n    }\n    catch(e: dynamic) {\n        println(e.stack)\n    }\n}\n\nfun async(block: suspend () -> Unit) {\n    block.startCoroutine(completion = object : Continuation<Unit> {\n        override val context = EmptyCoroutineContext\n\n        override fun resume(value: Unit) {\n        }\n\n        override fun resumeWithException(exception: Throwable) {\n            throw exception\n        }\n    })\n}\n\nsuspend fun foo(a: Int): Int {\n    val p = if (a > 0) foo(a - 1) else 0\n    return a + p\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    boom(B())\n}\n\nclass B\n\nfun B.magic() {\n}\n\nfun boom(a: Any) {\n    when (a) {\n        is B -> run(a::magic)\n    }\n}\n"
        },
        {
            "code": "\npublic inline fun calculateSequence(num: Int, fromX: Double, toX: Double, func: (Double)->Double): Pair<List<Double>, List<Double>> {\n\tval yData = ArrayList<Double>(num)\n\tval xData = ArrayList<Double>(num)\n\n\tfor (d in fromX..toX step (toX - fromX) / num) {\n\t\tyData add func(d)\n\t\txData add d\n\t}\n\n\treturn Pair(yData, xData)\n}\n\nfun someFunction(y: DoubleArray, x: DoubleArray, num: Int, percentile: Double = 50.0): Pair<List<Double>, List<Double>> {\n\t// .. code ..\n\n\tvar curIndex = 0 // wrapped in kotlin.jvm.internal.Ref$IntRef\n\tval lastIndex = y.lastIndex\n\treturn calculateSequence(num, x.first(), x.last()) {\n\t\tval prevIndex = curIndex\n\t\tfor (i in curIndex..lastIndex) {\n\t\t\tif (x[i] > it) break\n\t\t\tcurIndex++\n\t\t}\n\t\tval length = curIndex - prevIndex - 1\n\t\tval res = if (length > 0) {\n\t\t\tStatUtils.percentile(y, prevIndex, length, percentile)\n\t\t} else {\n\t\t\ty[prevIndex]\n\t\t}\n\t\tres\n\t}\n}\n"
        },
        {
            "code": "\n fun loop(n: Int): Int {\n        var x = 0\n        repeat(n) {\n            x++\n        }\n        return x\n    }\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.*\n\nfun main(args: Array<String>) {\n    async {\n        val a = foo(23)\n        println(a)\n        val b = foo(42)\n        println(b)\n    }\n    while (!finished) {\n        println(\"-- resuming --\")\n        proceed()\n    }\n}\n\nvar proceed: () -> Unit = { }\nvar finished = false\n\nsuspend fun bar(x: Int): Int = suspendCoroutine { c -> \n    println(\"before resume: $x\")\n    proceed = { c.resume(x) }\n}\n\ninline suspend fun foo(x: Int): Int = bar(x)\n\nfun async(a: suspend ()->Unit) {\n    a.startCoroutine(object : Continuation<Unit> {\n        override fun resume(value: Unit) {\n            proceed = { \n                println(\"-- done --\")\n                finished = true\n            }\n        }\n        \n        override fun resumeWithException(e: Throwable) {\n        }\n        \n        override val context = EmptyCoroutineContext\n    })\n}\n"
        },
        {
            "code": "\nimport kotlin.browser.window\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.*\nimport kotlin.js.Date\nimport kotlin.js.Promise\n\nfun main(args: Array<String>) {\n    async_selfContained {\n        Q.qwe(\"aaaa\")\n        Q.qwe(\"bbbb\")\n    }\n}\n\ninterface I {\n    suspend fun qwe(some: String /*= \"thing\"*/) // For the second test, uncomment default parameter value\n}\n\nobject Q : I {\n    override suspend fun qwe(some: String) {\n        val start = Date().getTime()\n        console.log(\"Entering qwe ($some)\")\n        sleep_selfContained(5000)\n        console.log(\"Leaving qwe ($some). Elapsed: ${(Date().getTime() - start) / 1000}s\")\n    }\n}\n\n\n//----------------------------------- Stuff -----------------------------------\n\n\nsuspend fun sleep_selfContained(ms: Int) {\n    await_selfContained(delay_selfContained(ms))\n}\n\nfun delay_selfContained(ms: Int) = Promise<Unit> {resolve, _ ->\n    window.setTimeout({resolve(Unit)}, ms)\n}\n\nfun <T> async_selfContained(block: suspend () -> T): Promise<T> =\n    Promise {resolve, reject ->\n        block.startCoroutine(object:Continuation<T> {\n            override val context = EmptyCoroutineContext\n            override fun resume(value: T) = resolve(value)\n            override fun resumeWithException(exception: Throwable) = reject(exception)\n        })\n    }\n\nsuspend fun <T> await_selfContained(p: Promise<T>): T =\n    suspendCoroutineOrReturn {c: Continuation<T> ->\n        p.then(onFulfilled = {c.resume(it)},\n               onRejected = {c.resumeWithException(it)})\n        COROUTINE_SUSPENDED\n    }\n"
        },
        {
            "code": "\nenum class DemoEnum(val value : String) {\n    One(\"one\"),\n    Two(\"two\"),\n    Three(\"three\");\n    \n    init {\n        println(\"DemoEnum.<init>\")\n    }\n    \n    companion object {\n        init {\n            println(\"DemoEnum.companion\")\n            val value = DemoEnum.values()[0].value\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val one = DemoEnum.One\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    arrayOf(1, 2, Any())\n    intArrayOf(3, 4, 5)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    getProperty<List<Int>>()\n}\n\nfun < T> getProperty(token: Any = object : TypeToken<T> {}) {\n    token::class.supertypes.forEach {\n        println(it.javaType)\n    }\n}\n\ninterface TypeToken<T>\n"
        },
        {
            "code": "\n    var dNaN1 = 0.0 / 0.0\n    var dNaN2 = 0.0 / 0.0\n    println(dNaN1 == dNaN2)  // JVM: false, JS: false\n\n    var a1: Any = dNaN1\n    var a2: Any = dNaN2\n    \n    println(a1 == a2)        // JVM: true, JS: false\n"
        },
        {
            "code": "\nabstract class Base {\n    abstract inner class Inner\n}\n\nobject Host : Base() {\n    object Inner : Base.Inner()\n}\n"
        },
        {
            "code": "\nclass MutableEntity {\n\n    @Volatile\n    var x: String? = null\n\n    fun faultyGetXOrDefault(): String = if (x != null) x else \"default\"\n\n    fun rightGetXOrDefault() = x ?: \"default\"\n}\n"
        },
        {
            "code": "\nclass MainClass : BaseClass<MyClass>() {\n\n    override fun createP() = MyClass()\n\n    init {    \n        (p::t) // [1]\n    }\n}\n"
        },
        {
            "code": "\nprivate tailrec suspend fun SequenceBuilder<Int>.fromTo(from: Int, to: Int) {\n        if (from > to) return\n        yield(from)\n        return fromTo(from + 1, to)\n    }\n"
        },
        {
            "code": "\ninterface IFoo1<S1, T1> {\n    fun foo(s: S1): T1\n}\n\ninterface IFoo2<S2, T2> {\n    fun foo(s: S2): Collection<T2>\n}\n\ninterface X\ninterface Y\n\ninterface IFoo12<T> : IFoo1<X, T>, IFoo2<Y, T>\n// ^ Error:(14, 11) Kotlin: JavaScript name foo_11rb$ is generated for different inherited members: fun foo(s: X): T and fun foo(s: Y): Collection<T>\n"
        },
        {
            "code": "\nclass Test {\n\n    inline fun foo() {\n        println(prop)\n    }\n\n    @PublishedApi\n    internal val prop: Int = 42\n}\n"
        },
        {
            "code": "\nval value = System.getProperty(\"key\")\nif (value != null) {\n    value.toUpperCase()\n}\n"
        },
        {
            "code": "\nfun isEmpty2(l: List<*>): Boolean = \n        l?.isEmpty() // NB: expression type is 'Boolean'\n"
        },
        {
            "code": "\nfun foo(s: String) = (s as CharSequence)\n"
        },
        {
            "code": "\n@Suppress(\"UNCHECKED_CAST\")\nfun <T> f(o: Any): T = o as T\n"
        },
        {
            "code": "\n\n@Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\", \"CAST_NEVER_SUCCEEDS\")\nprivate val primitiveConversion = fun TypeConverters.ExactConverter.(value: Any): Any {\n    return when (value) {\n        is String -> when (toType) {\n            String::class.java -> value     // identity\n            Short::class.java, java.lang.Short::class.java -> value.toShort()\n            Byte::class.java, java.lang.Byte::class.java -> value.toShort().toByte()\n            Int::class.java, Integer::class.java -> value.toInt()\n            Long::class.java, java.lang.Long::class.java -> value.toLong()\n            Double::class.java, java.lang.Double::class.java -> value.toDouble()\n            Float::class.java, java.lang.Float::class.java -> value.toFloat()\n            BigDecimal::class.java -> BigDecimal(value)\n            BigInteger::class.java -> BigDecimal(value)\n            CharSequence::class.java -> value\n            Boolean::class.java, java.lang.Boolean::class.java -> value.toBoolean()\n            ByteArray::class.java -> value.toByteArray() // UTF-8 always\n            File::class.java -> File(value)\n            URL::class.java -> URL(value)\n            URI::class.java -> URI(value)\n            else -> {\n                val toErased = toType.erasedType()\n                if (toErased.isEnum) {\n                    @Suppress(\"UNCHECKED_CAST\")\n                    val ecls = toErased as Class<Enum<*>>\n                    ecls.getEnumConstants().filter { it.name == value }.first() ?: IllegalStateException(\"Unknown Enum conversion from ${fromType} to ${toType}, no matching value ${value}\")\n                } else {\n                    throw IllegalStateException(\"Unknown String conversion from ${fromType} to ${toType}\")\n                }\n            }\n        }\n        is CharSequence -> when (toType) {\n            CharSequence::class.java -> value // identity\n            String::class.java -> value.toString()\n            ByteArray::class.java -> value.toString().toByteArray() // UTF-8 always\n            else -> throw IllegalStateException(\"Unknown CharSequence conversion from ${fromType} to ${toType}\")\n        }\n        is Number -> when (toType) {\n            Short::class.java, java.lang.Short::class.java -> value.toShort()\n            Byte::class.java, java.lang.Byte::class.java -> value.toByte()\n            Int::class.java, Integer::class.java -> value.toInt()\n            Long::class.java, java.lang.Long::class.java -> value.toLong()\n            Double::class.java, java.lang.Double::class.java -> value.toDouble()\n            Float::class.java, java.lang.Float::class.java -> value.toFloat()\n            BigDecimal::class.java -> BigDecimal(value.toDouble())\n            BigInteger::class.java -> BigDecimal(value.toDouble())\n            String::class.java -> value.toString()\n            Char::class.java, Character::class.java -> value.toChar()\n            Boolean::class.java, java.lang.Boolean::class.java -> value != 0\n            Date::class.java -> Date(value.toLong())\n            else -> {\n                val toErased = toType.erasedType()\n                if (toErased.isEnum) {\n                    @Suppress(\"UNCHECKED_CAST\")\n                    val ecls = toErased as Class<Enum<*>>\n                    ecls.getEnumConstants().get(value.toInt())\n                } else {\n                    throw IllegalStateException(\"Unknown number conversion from ${fromType} to ${toType}\")\n                }\n            }\n        }\n        is Char -> when (toType) {\n            Char::class.java, Character::class.java -> value     // identity\n            Short::class.java, java.lang.Short::class.java -> value.toShort()\n            Byte::class.java, java.lang.Byte::class.java -> value.toByte()\n            Int::class.java, Integer::class.java -> value.toInt()\n            Long::class.java, java.lang.Long::class.java -> value.toLong()\n            Double::class.java, java.lang.Double::class.java -> value.toDouble()\n            Float::class.java, java.lang.Float::class.java -> value.toFloat()\n            BigDecimal::class.java -> BigDecimal(value.toInt())\n            BigInteger::class.java -> BigDecimal(value.toInt())\n            String::class.java -> value.toString()\n            Boolean::class.java, java.lang.Boolean::class.java -> value == '1' || value == 'T' || value == 't'\n            else -> throw IllegalStateException(\"Unknown char conversion from ${fromType} to ${toType}\")\n        }\n        is Boolean -> when (toType) {\n            Boolean::class.java, java.lang.Boolean::class.java -> value      // identity\n            Char::class.java, Character::class.java -> if (value) 'T' else 'F'\n            Short::class.java, java.lang.Short::class.java -> (if (value) 1 else 0).toShort()\n            Byte::class.java, java.lang.Byte::class.java ->  (if (value) 1 else 0).toByte()\n            Int::class.java, Integer::class.java -> (if (value) 1 else 0).toInt()\n            Long::class.java, java.lang.Long::class.java ->  (if (value) 1 else 0).toLong()\n            Double::class.java, java.lang.Double::class.java -> (if (value) 1 else 0).toDouble()\n            Float::class.java, java.lang.Float::class.java -> (if (value) 1 else 0).toFloat()\n            BigDecimal::class.java -> BigDecimal(if (value) 1 else 0)\n            BigInteger::class.java -> BigDecimal(if (value) 1 else 0)\n            String::class.java -> value.toString()\n            else -> throw IllegalStateException(\"Unknown boolean conversion from ${fromType} to ${toType}\")\n        }\n        is Date -> when (toType) {\n            Date::class.java -> value   // identity\n            Long::class.java, java.lang.Long::class.java -> value.time\n            else -> throw IllegalStateException(\"Unknown date conversion from ${fromType} to ${toType}\")\n        }\n        is ByteArray -> when (toType) {\n            ByteArray::class.java -> value // identity\n            String::class.java -> value.toString(Charsets.UTF_8) // always UTF-8\n            else -> throw IllegalStateException(\"Unknown ByteArray conversion from ${fromType} to ${toType}\")\n        }\n        is Enum<*> -> when (toType) {\n            String::class.java -> value.name\n            Byte::class.java, java.lang.Byte::class.java -> value.ordinal.toByte()\n            Short::class.java, java.lang.Short::class.java -> value.ordinal.toShort()\n            Int::class.java, Integer::class.java -> value.ordinal\n            Long::class.java, java.lang.Long::class.java -> value.ordinal.toLong()\n            else -> {\n                val toErased = toType.erasedType()\n                if (toErased.isEnum && TypeConversionConfig.permiteEnumToEnum) {\n                    @Suppress(\"UNCHECKED_CAST\")\n                    val ecls = toErased as Class<Enum<*>>\n                    ecls.getEnumConstants().filter { it.name == value.name }.firstOrNull() ?: IllegalStateException(\"Unknown Enum conversion from ${fromType} to ${toType}, no matching value ${value}\")\n                } else {\n                    throw IllegalStateException(\"Unknown Enum conversion from ${fromType} to ${toType}\")\n                }\n            }\n        }\n        is File -> when (toType) {\n            File::class.java -> value // identity\n            String::class.java -> value.absolutePath\n            else -> throw IllegalStateException(\"Unknown File conversion from ${fromType} to ${toType}\")\n        }\n        is URL -> when (toType) {\n            URL::class.java -> value // identity\n            String::class.java -> value.toString()\n            URI::class.java -> value.toURI()\n            else -> throw IllegalStateException(\"Unknown URL conversion from ${fromType} to ${toType}\")\n        }\n        is URI -> when (toType) {\n            URI::class.java -> value // identity\n            String::class.java -> value.toString()\n            URL::class.java -> value.toURL()\n            else -> throw IllegalStateException(\"Unknown URI conversion from ${fromType} to ${toType}\")\n        }\n        else -> throw IllegalArgumentException(\"No primitive conversion for ${fromType} to ${toType} for value ${value}\")\n    }\n}\n"
        },
        {
            "code": "\n@file:JvmMultifileClass\npackage abc\n\nclass A {\n    private var r: String = \"\"\n\n    public fun getR(): String = \"\"\n}\n\n"
        },
        {
            "code": "\nfun foo(): Array<String> {\n    return emptyArray()\n}\n"
        },
        {
            "code": "\nvar showIconsInMenus by storedProperty(true)\n"
        },
        {
            "code": "\nfun qwe() {\n    async {\n        fun asd() {\n            console.log(\"qqqqqqqqqqqqqqqqqqqq\")\n        }\n        val f = ::asd\n        f()\n    }\n}\n"
        },
        {
            "code": "\nimport java.math.*\n\nfun number(doLong: Boolean): Number = when {\n    doLong -> 1.toLong()\n    else -> BigDecimal.valueOf(0)\n}\n\nfun main(args: Array<String>) {\n    println(number(true))\n}\n"
        },
        {
            "code": "\nfun number(doBigInt: Boolean): Number = when {\n    doBigInt -> BigInteger.valueOf(1)\n    else -> BigDecimal.valueOf(0)\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.KClass\n\nannotation class Test(vararg val values: KClass<*>)\n\n@Test(TestClass::class)\nclass TestClass {\n\n    init {\n        val test = javaClass.getAnnotation(Test::class.java)\n        test.values.forEach {\n            println(it)\n        }\n    }\n\n}\n\nfun main(vararg args: String) {\n    TestClass()\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.KClass\n\nannotation class Test(vararg val values: KClass<*>)\n\n@Test(TestClass::class)\nclass TestClass {\n\n    init {\n        val test = javaClass.getAnnotation(Test::class.java)\n        val values = test.values\n        values.forEach {\n            println(it)\n        }\n    }\n\n}\n\nfun main(vararg args: String) {\n    TestClass()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    async {Q.qwe()}\n}\n\nobject Q {\n    suspend fun qwe() {\n        fun f() = console.log(\"fffffffffffffffff\")\n\n        val g = ::f\n        g()\n\n        asd() // If this line is commented out, it works\n    }\n\n    suspend fun asd() {}\n}\n"
        },
        {
            "code": "\nimport java.util.function.Function\n\nobject Foo {\n    class Requester(val dealToBeOffered: String)\n}\n\nclass Bar {\n    val foo = Function(Foo::Requester)\n}\n"
        },
        {
            "code": "\nobject Foo {\n    class Requester(val dealToBeOffered: String)\n}\n\ninline fun <A, reified R> startFlow(\n        flowConstructor: (A) -> R\n) {}\n\n\nfun main(args: Array<String>) {\n    startFlow(Foo::Requester)\n}\n"
        },
        {
            "code": "\nfun box(): String {\n    val a: String? = \"test\"\n    a + \"!!!\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.KProperty\n\nclass Delegate {\n    operator fun provideDelegate(thisRef: Any?, property: KProperty<*>) = this\n    operator fun getValue(thisRef: Any?, property: KProperty<*>) = Unit\n}\n\nclass TestClass {\n    companion object {\n        val test by Delegate()\n    }\n}\n\nfun main(args: Array<String>) {\n    TestClass.test\n}\n"
        },
        {
            "code": "\nclass A() {\n    var y: String? = null\n\n    constructor(x: Any) : this() {\n        println(if (x == \"foo\") \"!!!\" else { println(x as String); \">>>\" })\n    }\n}\n"
        },
        {
            "code": "\n// FILE: Father.kt\n\nabstract class Father {\n    protected abstract inner class InClass {\n        abstract fun Method1();\n    }\n}\n\n// FILE: Child.kt\n\nclass Child : Father() {\n    protected val ChildInClass = object : Father.InClass() {\n        override fun Method1() {\n        }\n    }\n}\n"
        },
        {
            "code": "\n@Target(CLASS, PROPERTY)\n@Inherited\n@MustBeDocumented\nannotation class Source(val value: String)\n"
        },
        {
            "code": "\ninterface Model {\n\n    @Source(\"test\")\n    var prop: String\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    Class.forName(\"kotlin.text.StringsKt\").getMethods().single { it.name == \"capitalize\" }.invoke(\"\")\n}\n"
        },
        {
            "code": "\n// MODULE: module1(module2)\nimport A.test\n\nfun main(args: Array<String>) {\n    println(\"A.test()\" + A.test())\n    println(\"B.test()\" + B.test()) // \n    println(\"[A.]test()\" + test())\n    println(\"test2()\" + test2())\n    println(\"A.test2()\" + A.test2())\n    println(\"B.test2()\" + B.test2())\n}\n\n"
        },
        {
            "code": "\n// MODULE: module2\nimport A.foo\nimport B.Companion.bar\n\nobject A {\n    fun foo() = 1\n    inline fun test() = foo() + this.foo() + A.foo()\n}\n\nclass B {\n    companion object {\n        fun bar() = 2\n        inline fun test() = bar() + this.bar() + B.bar()\n    }\n}\n\ninline fun test2() = foo() + bar()\ninline fun A.test2() = foo() + B.bar()\ninline fun B.Companion.test2() = bar()\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val l = listOf(\"a\")\n\n    val s = l[0].plus(\"bar\")\n\n    println(s)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(ObjectThisTest.testValue)\n}\n\nobject ObjectThisTest {\n\n    val testValue: Float\n        @JvmStatic get() = this.testValue2\n\n    val testValue2: Float\n        get() = 3.0f\n\n}\n"
        },
        {
            "code": "\n// MODULE: Main(M1)\nfun main(args: Array<String>) {\n    println(M1().foo())\n    println(M1().bar<M1>().simpleName)\n}\n"
        },
        {
            "code": "\n// MODULE: M1(M2)  // in IDEA project model M2 should be marked as export OR Main should depend on M2 too\nclass M1 : M2()\n"
        },
        {
            "code": "\n// MODULE: M2\nopen class M2 {\n    inline fun foo() = 1\n    inline fun <reified T : Any> bar() = T::class\n}\n"
        },
        {
            "code": "\npackage a\n\nopen class Parent {\n    inline fun inlineMethod() {}\n}\n\nclass Child : Parent()\n"
        },
        {
            "code": "\npackage b\n  \nimport a.*\n\nfun function() {\n    Child().inlineMethod()\n}\n\n"
        },
        {
            "code": "\ndata class X(val s: String)\nclass Y\n\nfun foo(body: suspend Y.(X) -> Unit) {}\nfun bar() {\n    foo { (s) ->\n        println(s)\n    }\n}\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.experimental.runBlocking\n\nsuspend fun fluttershy(): String = \"\"\n\nsuspend fun twilight(rarity: String?, rainbow: String): Unit {\n\n}\n\nsuspend fun pinkie() {\n    twilight(null, fluttershy())\n}\n\n\nfun main(args: Array<String>) {\n    runBlocking {\n        try {\n            pinkie()\n        } catch (e: Throwable) {\n            println(\"Pinkie, you broke the wall again\")\n            e.printStackTrace()\n        }\n    }\n}\n"
        },
        {
            "code": "\n// FAILS: Internal error: wrong code generated\nsuspend fun String.ext(): Int = 10\nsuspend fun coroutinebug(v: String?) {\n\tv?.ext()\n}\n\n// WORKS:\n//suspend fun String.ext(): Int = 10\n//suspend fun coroutinebug(v: String?) {\n//\t@Suppress(\"IfThenToSafeAccess\")\n//\tif (v != null) v.ext()\n//}\n\n// WORKS:\n//suspend fun String.ext(): Int = 10\n//suspend fun coroutinebug(v: String?) = v?.ext()\n"
        },
        {
            "code": "\nclass X {\n    suspend operator fun get(f: suspend ()->Unit) {}\n}\n\nfun main(args: Array<String>) {\n    runBlocking {\n        X()[{}]\n    }\n}\n"
        },
        {
            "code": "\n@Test\nfun get() = syncTest {\n\tclass DynamicObj(val obj: Any?) {\n\t\tsuspend operator fun get(key: String) = DynamicObj(Dynamic.getAny(obj, key))\n\n\t\tfun <T> to(): T = obj as T\n\t}\n\n\t//Assert.assertEquals(10, DynamicObj(mapOf(\"a\" to 10))[\"a\"].to<Int>()) // FAILS: Wrong code generated\n\tAssert.assertEquals(10, DynamicObj(mapOf(\"a\" to 10)).get(\"a\").to<Int>()) // WORKS\n}\n"
        },
        {
            "code": "\n// ---- Worked before upgrade ---------------------------------\n\nprivate fun handler(e: Event) {\n    console.log(\"lalala\")\n}\n\nfun qwe_crefInterop_addListener() {\n    window.addEventListener(\"keydown\", ::handler)\n}\n\nfun qwe_crefInterop_removeListener() {\n    window.removeEventListener(\"keydown\", ::handler)\n}\n\n// ---- Better workarounds? ---------------------------------\n\nprivate var uglyHandler = ::handler\n\nfun qwe_crefInterop_addListener_worksButUgly() {\n    window.addEventListener(\"keydown\", uglyHandler)\n}\n\nfun qwe_crefInterop_removeListener_worksButUgly() {\n    window.removeEventListener(\"keydown\", uglyHandler)\n}\n"
        },
        {
            "code": "\nimport testpackage.AsyncStuff.async\nimport testpackage.AsyncStuff.suspendable\n\ninline fun getA(x: Long, handler: (x: Long) -> Unit) = handler(x)\n\nsuspend fun F(y: Long) = suspendable<Long> {\n    getA(y, { x -> return@suspendable y } )\n    return@suspendable 0L\n}\n\nfun main(args: Array<String>) {\n    async<Unit> {\n        println(F(6) + F(9))\n    }\n}\n\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.COROUTINE_SUSPENDED\nimport kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn\n\nclass A() {\n    suspend operator fun getValue(instance: Any?, prop: Any?): String = suspendCoroutineOrReturn { c ->\n        c.resume(\"OK\")\n        COROUTINE_SUSPENDED\n    }\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(object : Continuation<Unit> {\n        override fun resume(value: Unit) { }\n\n        override fun resumeWithException(e: Throwable) {\n            throw e\n        }\n\n        override val context = EmptyCoroutineContext\n    })\n}\n\nfun main(args: Array<String>) {\n    var result = \"fail\"\n    builder {\n        val x by A()\n        result = x\n    }\n    println(result)\n}\n"
        },
        {
            "code": "\nfun foo(c: suspend (A) -> Unit) {}\n\nfun bar() {\n    foo {\n        (x) -> // Error:(9, 10) Kotlin: Suspension functions can be called only within coroutine body\n    }\n}\n"
        },
        {
            "code": "\nfun CharSequence.withReplace(startOffset: Int, endOffset: Int, replacementText: CharSequence): String\n{\n    return \"${subSequence(0,startOffset)}$replacementText${subSequence(endOffset,length)}\"\n}\n"
        },
        {
            "code": "\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.append(this, 0, startIndex)\n    sb.append(replacement)\n    sb.append(this, endIndex, length)\n    return sb\n}\n"
        },
        {
            "code": "\nfun CharSequence.withReplace(startOffset: Int, endOffset: Int, replacementText: CharSequence): CharSequence\n{\n    return \"${subSequence(0,startOffset)}$replacementText${subSequence(endOffset,length)}\" as CharSequence\n}\n"
        },
        {
            "code": "\n    suspend fun intercept(call: ApplicationCall) {\n        val origin = call.request.headers.getAll(HttpHeaders.Origin)?.singleOrNull()\n        if (origin != null && isValidOrigin(origin)) {\n            call.corsCheckOrigins(origin)\n\n            if (call.request.httpMethod == HttpMethod.Options) {\n                call.preFlight(call, origin)\n            }\n\n            call.corsCheckCurrentMethod()\n            call.accessControlAllowOrigin(origin)\n            call.accessControlAllowCredentials()\n\n            if (exposedHeaders != null) {\n                call.response.header(HttpHeaders.AccessControlExposeHeaders, exposedHeaders)\n            }\n        }\n    }\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.experimental.runBlocking\n\nsuspend fun update() {\n\n}\n\nsuspend fun suspendLock(block: suspend () -> Unit) {\n\n}\n\nsuspend fun cancel_operation(text: String): Unit {\n    val args = text.split(\" \")\n\n    val oper_id = try {\n        args[1].toLong()\n    } catch (e: Throwable) {\n        null\n    }\n\n    update()\n\n    if (oper_id == null) {\n        return\n    }\n    suspendLock {\n        println(\"Cancelled operation $oper_id\")\n    }\n}\n"
        },
        {
            "code": "\nfun doubleEquals(a: Double?, b: Double?) = a == b\n"
        },
        {
            "code": "\ntypealias BoolArray = Array<Boolean>\n\nfun main(args: Array<String>) {\n    BoolArray(10) { false }\n}\n"
        },
        {
            "code": "\ndata class Foo( @MyAnnotation val bar : Int)\n"
        },
        {
            "code": "\nimport kotlinx.coroutines.experimental.*\n\nfun main(args: Array<String>) = runBlocking {\n    foo()\n}\n\nprivate suspend fun foo() {}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.COROUTINE_SUSPENDED\nimport kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn\n\nfun builder(c: suspend () -> Unit) {\n    val coroutine = c.createCoroutine(object : Continuation<Unit> {\n        override fun resume(value: Unit) { }\n\n        override fun resumeWithException(e: Throwable) {\n            throw e\n        }\n\n        override val context = EmptyCoroutineContext\n    })\n    coroutine.resume(Unit)\n}\n\nfun main(args: Array<String>) {\n    var result = \"fail\"\n    val f: (Unit) -> Unit = { result = \"OK\" }\n    builder(f as suspend () -> Unit)\n    println(result)\n}\n"
        },
        {
            "code": "\ninline fun font(name: String, size: Int, bold: Boolean = false, italic: Boolean = false) = KFont(name, size, bold, italic)\n\nclass KFont(val name: String, val size: Int, val bold: Boolean, val italic: Boolean)\n"
        },
        {
            "code": "\nfun test1() {\n    font(\"a\", 27, bold = true)\n    font(\"a\", 27, italic = true)\n}\n"
        },
        {
            "code": "\nclass C {\n    val foo by lazy { \"abc\" }\n}\n"
        },
        {
            "code": "\nexternal open class C {\n    fun f(p: Int = noImpl)\n}\n\nclass Impl : C()\n"
        },
        {
            "code": "\nexternal open class C {\n    fun f(p: Int)\n    fun f()\n}\n\nclass Impl : C()\n"
        },
        {
            "code": "\nexternal open class C {\n    fun f(p: Int)\n}\n\ninline fun C.f() = asDynamic().f()\n\nclass Impl : C()\n"
        },
        {
            "code": "\n@JsModule(\"@test-company/test-lib/view\")\n@JsName(\"Control\")\nopen external class Control {\n    companion object {\n        @JsName(\"createControl\")\n        fun create():Control = noImpl\n    }\n}\n\nfun main(args: Array<String>) {\n    val control1 = Control()\n    val control2 = Control.create()\n}\n"
        },
        {
            "code": "\n// WITH_RUNTIME\n// WITH_COROUTINES\nimport kotlin.coroutines.startCoroutine\n\nclass Controller {\n    suspend inline fun suspendInline(v: String): String = throw RuntimeException(v)\n\n    suspend inline fun suspendInline(crossinline b: () -> String): String = suspendInline(b())\n\n    suspend inline fun <reified T : Any> suspendInline(): String = suspendInline({ T::class.simpleName!! })\n}\n\nfun builder(c: suspend Controller.() -> Unit) {\n    c.startCoroutine(Controller(), EmptyContinuation)\n}\n\nclass OK\n\nfun box(): String {\n    var result = \"\"\n\n    builder {\n        result = try { suspendInline(\"56\") } catch (e: RuntimeException) { e.message!! }\n        if (result != \"56\") throw RuntimeException(\"fail 1\")\n\n        result = try { suspendInline { \"57\" } } catch (e: RuntimeException) { e.message!! }\n        if (result != \"57\") throw RuntimeException(\"fail 2\")\n\n        result = try { suspendInline<OK>() } catch (e: RuntimeException) { e.message!! }\n    }\n\n    return result\n}\n"
        },
        {
            "code": "\n@JvmOverloads\nfun Activity.showSnackbar(@StringRes stringResId: Int, @ColorRes colorResId: Int = R.color.material_dark, @BaseTransientBottomBar.Duration duration: Int = Snackbar.LENGTH_SHORT)\n"
        },
        {
            "code": "\nimport java.lang.Exception\n\nfun nyCompiler() {\n    try {\n        return\n    }\n    catch (e: Exception) {}\n    finally {\n        try {}  catch (e: Exception) {}\n    }\n}\n"
        },
        {
            "code": "\nimport java.lang.Exception\n\nfun nyCompiler() {\n    try {\n        return\n    }\n    catch (e: Exception) {}\n    finally {\n        try {}  \n        catch (e: Exception) {}\n    }\n}\n"
        },
        {
            "code": "\nfun foo() {\n    fun bar(x: String) {\n        if (x.isEmpty()) return\n        println(\"foo: ${x[0]}\")\n        bar(x.substring(1))\n    }\n    bar(\"OK\")\n}\n\nfun baz() {\n    fun bar(x: String) {\n        if (x.isEmpty()) return\n        println(\"baz: ${x[0]}\")\n        bar(x.substring(1))\n    }\n    bar(\"OK\")\n}\n\nfun main(args: Array<String>) {\n    foo()\n    baz()\n}\n"
        },
        {
            "code": "\nfun qwe_1() {\n    fun qwe_local(firstCall: Boolean = true) {\n        console.log(\"I am local in qwe_1; firstCall = $firstCall\")\n        if (firstCall) {\n            qwe_local(firstCall = false) // Comment this out as third step\n        }\n    }\n    qwe_local()\n}\n\n// First, try `qwe_1()` with this commented out -- works as expected\n// Second, uncomment this and try `qwe_1()` again -- broken\n// Third, comment out line with recursive call to `qwe_local` above, then try `qwe_1()` again -- works as expected\n//\n//fun qwe_2() {\n//    fun qwe_local(firstCall: Boolean = true) {\n//        console.log(\"I am local in qwe_2; firstCall = $firstCall\")\n//        if (firstCall) {\n//            qwe_local(firstCall = false)\n//        }\n//    }\n//    qwe_local()\n//}\n"
        },
        {
            "code": "\nenum class Test(val x: Int) {\n    ZERO, ONE(1);\n    constructor(): this(0)\n}\n"
        },
        {
            "code": "\n@JsModule(\"foo\")\nexternal class A {\n    class B\n}\n\nfun test(a: A) {\n    A.B::class\n    foo<A.B>()\n}\n\ninline fun <reified T> foo() {}\n"
        },
        {
            "code": "\nenum class Test(vararg xs: Int) {\n    OK;\n    val values = xs\n}\n\nfun box(): String =\n        if (Test.OK.values.size == 0) \"OK\" else \"Fail\"\n"
        },
        {
            "code": "\ninterface I {\n    val resolution: String\n        get() = \"OK\"\n}\n\nclass C : I {\n    override val resolution: String by lazy { super.resolution }\n}\n\nfun main(args: Array<String>) {\n    println(C().resolution)\n}\n"
        }
    ]
}