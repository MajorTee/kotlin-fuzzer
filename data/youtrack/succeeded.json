{
    "count": 843,
    "success": true,
    "codes": [
        {
            "code": "\ninterface CookieJar {\n    companion object {\n        @JvmField\n        val NO_COOKIES: CookieJar = object : CookieJar { }\n    }\n}\n"
        },
        {
            "code": "\nclass Test(private val capture: Map<String, Any>) {\n  fun foo(appendable: Appendable) {\n    appendable.apply {\n      appendln(outer {\n        inner {\n          function(1, capture[\"2\"], capture[\"3\"])\n        }\n        inner {\n        }\n      }.toString())\n      appendln()\n    }\n  }\n}\n\ninterface InnerReceiver {\n  fun function(vararg stuff: Any?)\n}\ninterface OuterReceiver {\n  fun inner(body: InnerReceiver.() -> Unit)\n}\n\nclass InnerReceiverImpl : InnerReceiver {\n  override fun function(vararg stuff: Any?) {}\n}\nclass OuterReceiverImpl : OuterReceiver {\n  override fun inner(body: InnerReceiver.() -> Unit) {}\n}\n\nfun outer(body: OuterReceiver.() -> Unit): Any {\n  return Any()\n}\n"
        },
        {
            "code": "\ninterface A {\n    fun foo(): String = { \"\" }()\n}\n"
        },
        {
            "code": "\nclass CountingString(private val s: String) : CharSequence {\n    var lengthCtr = 0\n    var getCtr = 0\n\n    override val length: Int\n    \tget() = s.length.also { lengthCtr++ }\n    override fun subSequence(startIndex: Int, endIndex: Int) = TODO(\"not implemented\")\n    override fun get(index: Int) = s.get(index).also { getCtr++ }\n\n    fun reset() {\n        lengthCtr = 0\n        getCtr = 0\n    }\n\n    fun printCtrs() {\n        println(\"getCtr: ${getCtr}\")\n        println(\"lengthCtr: ${lengthCtr}\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val cs = CountingString(\"abcd\")\n\n    // INCORRECT behavior\n    for ((_, _) in cs.withIndex()) {}\n    cs.printCtrs()\n    cs.reset()\n\n    // CORRECT behavior\n    val cswi = cs.withIndex()\n    for ((_, _) in cswi) {}\n    cs.printCtrs()\n    cs.reset()\n\n    // Intended behavior of iterating over CharSequence\n    val csit = cs.iterator()\n    while (csit.hasNext()) {\n        csit.next()\n    }\n    cs.printCtrs()\n    cs.reset()    \n\n    // CORRECT behavior when element variable is present in destructuring declaration\n    for ((_, v) in cs.withIndex()) {}\n    cs.printCtrs()\n    cs.reset()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(ButtonState.DOWN)\n}\n\nenum class ButtonState(\n\t\tval isUp: Boolean = false,\n\t\tval isOver: Boolean = false,\n\t\tval isDown: Boolean = false,\n\t\tval isToggled: Boolean = false,\n\t\tval isIndeterminate: Boolean = false,\n\t\tval fallback: ButtonState? = null\n) {\n\tUP(isUp = true, fallback = null),\n\tOVER(isOver = true, fallback = UP),\n\tDOWN(isDown = true, isOver = true, fallback = OVER),\n\tTOGGLED_UP(isUp = true, isToggled = true, fallback = UP),\n\tTOGGLED_OVER(isOver = true, isToggled = true, fallback = TOGGLED_UP),\n\tTOGGLED_DOWN(isDown = true, isOver = true, isToggled = true, fallback = TOGGLED_UP),\n\tINDETERMINATE_UP(isUp = true, isIndeterminate = true, fallback = UP),\n\tINDETERMINATE_OVER(isOver = true, isIndeterminate = true, fallback = INDETERMINATE_UP),\n\tINDETERMINATE_DOWN(isDown = true, isOver = true, isIndeterminate = true, fallback = INDETERMINATE_UP),\n\tDISABLED(fallback = UP);\n}\n"
        },
        {
            "code": "\nimport kotlin.math.absoluteValue\n\nfun main() {\n    1.let(Int::absoluteValue)\n}\n"
        },
        {
            "code": "\nimport kotlin.math.*\n\nfun main() {\n    println(listOf(1L).map(Long::absoluteValue))  // broken (IllegalAccessError)\n    println(listOf(1L).map(Long::sign))  // ok\n}\n"
        },
        {
            "code": "\n@Target(AnnotationTarget.TYPE)\nannotation class Foo\n\nclass A {\n    fun foo(): @Foo String = \"OK\"\n}\n"
        },
        {
            "code": "\nimport java.lang.invoke.MethodHandles\nimport java.lang.invoke.MethodType\n\nclass C {\n    fun foo(s: String) {\n        println(s)\n    }\n}\n\nfun main() {\n    val mh = MethodHandles.lookup().findVirtual(\n        C::class.java, \"foo\",\n        MethodType.methodType(Void.TYPE, String::class.java)\n    )\n\n    // Problem here:\n    // invokevirtual java/lang/invoke/MethodHandle.invokeExact:(LC;Ljava/lang/String;)Ljava/lang/Object;\n    mh.invokeExact(C(), \"Hello\")\n}\n"
        },
        {
            "code": "\ninline fun f(crossinline g: () -> Unit) = object {\n    fun <T> f() = g()\n    fun <T> h() {}\n}\nval x = f { }\n"
        },
        {
            "code": "\nclass Person(\n    val firstName: String,\n    val secondName: String\n) {\n    val fullName by lazy { firstName + \" \" + secondName }\n}\n"
        },
        {
            "code": "\npackage test\n\nclass C {\n    lateinit var a: String\n\n    fun ref() = ::a::isInitialized\n}\n\nfun main() {\n    println(C().ref().get())\n}\n"
        },
        {
            "code": "\nfun foo(x: Int = 42, y: String = \"\", b: Boolean = true) {}\n"
        },
        {
            "code": "\n@JvmOverloads \nfun foo(x: Int = 42, y: String = \"\", b: Boolean = true) {}\n"
        },
        {
            "code": "\n\n// File: A.kt\nopen class A {\n    @JvmOverloads\n    open fun foo(x: Any = 1) {\n        println(\"From Kotlin\")\n    }\n}\n"
        },
        {
            "code": "\nfun main() {\n    println()\n}\n"
        },
        {
            "code": "\nfun String.isNotWorking() = true\n\nopen class Base {\n    fun foo() {\n        \"\".isNotWorking()\n    }\n}\n\nclass Bar() : Base()\n\n"
        },
        {
            "code": "\n    fun foo() {\n        when(val foo = 42UL) {\n            42UL -> println(\"42!\")\n            else -> throw IllegalStateException()\n        }\n    }\n    "
        },
        {
            "code": "\nvar counter = 0\nfun inc() = counter++\n\ntailrec fun test(x: Int = 0, y: Int = inc(), z: Int = inc()) {\n    println(\"y: $y, z: $z\")\n    if (x > 0) test(x - 1)\n}\n\nfun main() {\n    test(1)\n}\n"
        },
        {
            "code": "\nfun main() {\n    A.GOO\n}\n\nenum class A {\n    GOO;\n    val a by lazy { 42 }\n    val b = a\n}\n"
        },
        {
            "code": "\nclass Queue<T>(override val size: Int) : Collection<T> {\n    override fun contains(element: T): Boolean = TODO()\n\n    override fun containsAll(elements: Collection<T>): Boolean = TODO()\n\n    override fun isEmpty(): Boolean = TODO()\n\n    override fun iterator(): Iterator<T> = TODO()\n\n    fun remove(v: T): Any = v as Any // Return-type is Any, it's important\n}\n\nfun box(): String {\n    (Queue<String>(1) as java.util.Collection<String>).remove(\"\") // throws CCE\n\n    return \"OK\"\n}\n\nfun main() {\n    println(box())\n}\n"
        },
        {
            "code": "\nclass X {\n\n    suspend fun suspending() {}\n\n    suspend fun test() {\n        logError(::suspending)\n    }\n\n    suspend inline fun runBlock(block: suspend () -> Unit) {\n        logError(block)\n    }\n\n    suspend inline fun logError(block: suspend () -> Unit) {\n        try {\n            block()\n        } catch (e: Exception) {\n            //Log Exception\n        }\n    }\n}\n\n"
        },
        {
            "code": "\nsuspend fun dummy(): Unit = Unit\n\nsuspend fun test(): Int = 1.also { \n    dummy()\n}\n"
        },
        {
            "code": "\n@file: Suppress(\"NOTHING_TO_INLINE\")\npackage ru.spbstu.wheels\n\ninline fun Int.asBits() = IntBits(this)\n\ninline class IntBits(val data: Int) {\n    companion object {\n        val Zero = 0.asBits()\n    }\n\n    inline fun asInt() = data\n\n    inline infix fun andNot(that: IntBits): IntBits = IntBits(data and that.data.inv())\n\n    inline val popCount: Int get() = Integer.bitCount(data)\n    inline val lowestBitSet get() = Integer.lowestOneBit(data).asBits()\n\n    inline fun forEachOneBit(body: (IntBits) -> Unit) {\n        var mask = this\n        while(mask != Zero) {\n            val bit = mask.lowestBitSet\n            body(bit)\n            mask = mask andNot bit\n        }\n    }\n}\n\ninline fun Bits(data: Int) = data.asBits()\n"
        },
        {
            "code": "\ninline fun <reified T> topMethod() {\n        innerMethod {\n            accessClass<T>()\n        }\n    }\n\n    fun innerMethod(block: () -> Unit) {\n        block()\n    }\n\n    inline fun <reified Z> accessClass() { Z::class.java }\n"
        },
        {
            "code": "\ninline val <reified T> T.foo: () -> Unit\n    get() {\n        println(this is T)\n        return {}\n    }\n\nfun main(args: Array<String>) {\n    6.foo()\n}\n"
        },
        {
            "code": "\nimport kotlin.contracts.*\n\n@ExperimentalContracts\nfun runOnce(action: () -> Unit) {\n    contract {\n        callsInPlace(action, InvocationKind.EXACTLY_ONCE)\n    }\n    action()\n}\n\n@ExperimentalContracts\nclass Foo(foo: Boolean) {\n    val res: String\n    init {\n        runOnce {\n            foo\n            res = \"OK\"\n        }\n    }\n}\n\n@ExperimentalContracts\nfun box(): String {\n    val foo = Foo(true)\n    return foo.res\n}\n\n@ExperimentalContracts\nfun main() {\n    box()\n}\n"
        },
        {
            "code": "\npublic class A {\n    fun get() {\n        listOf(str, str, str)\n    }\n\n    companion object {\n        lateinit var str: String\n    }\n}\n"
        },
        {
            "code": "\n\n\nfun main() {\n    run {\n        val (a, b) = getPair()\n        run {\n            println(\"1: \" + a)\n        }\n    }\n    run {\n        var (a, b) = getPair()  // If these variables have different names than the previous block, bug is not reproduced.\n        println(\"2: \" + a!!)\n        a = null   // Interferes with value from first block.\n    }   \n}\n\nprivate fun getPair(): Pair<Float?, Float> {\n    return Pair(1f, 2f)\n}\n\n"
        },
        {
            "code": "\nfun main() {\n val lk = java.lang.invoke.MethodHandles.lookup()\n val obj = \"test\"\n val mt = java.lang.invoke.MethodType.methodType(Int::class.java)\n val mh = lk.bind(obj, \"length\", mt);\n val len = mh.invoke()\n}\n"
        },
        {
            "code": "\nsealed class Example {\n    constructor(vararg s: String) {\n        println(s)\n    }\n\n    class Examples(vararg s: String) : Example(*s)\n}\n"
        },
        {
            "code": "\npackage com.michaelschlies.test\n\nimport java.lang.ref.WeakReference\n\nfun main(vararg args: String) {\n    val main = Main()\n    val t = Thread(Main())\n    t.run()\n    t.join()\n}\n\nclass Main : Runnable {\n    fun randomThing(lambdaLiteral: () -> Any) {\n        lambdaLiteral.invoke()\n    }\n\n    companion object {\n        @JvmStatic\n        fun x(): String {\n            return \"\"\n        }\n    }\n\n    override fun run() {\n        class MainTwo {\n            var ssid: String? = null\n        }\n\n        val someField = \"random\"\n        while (true) {\n            randomThing {\n                x()\n                var v: WeakReference<MainTwo>? = WeakReference(MainTwo().apply { ssid = \"asdf\" })\n                v?.get()?.ssid\n                val someLastField = \"blagblahblah\"\n                v = null\n                someLastField.length\n            };\n            { fieldOne: String, fieldTwo: String ->\n                someField.length\n            }.invoke(someField, someOtherField);\n            randomThing {\n                this.someOtherField.length\n            }\n            Thread.sleep(30)\n        }\n    }\n    private val someOtherField = String(StringBuilder(\"random2\"))\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class Z(val x: Int)\n"
        },
        {
            "code": "\nval map = mapOf<String, Any?>(\"x\" to null)\n\nval x: String by map\n\nfun main(args: Array<String>) {\n    println(x) // silently prints null, but should be NPE\n}\n"
        },
        {
            "code": "\ninline class Optional<out T> @Deprecated(\n    message = \"Not type-safe, use factory method\",\n    replaceWith = ReplaceWith(\"Inlined.of(_value)\")\n) constructor(private val _value: Any?) {\n    val value: T?\n        get() =\n            @Suppress(\"UNCHECKED_CAST\")\n            if (isPresent) _value as T\n            else null\n\n    val isPresent: Boolean\n        get() = _value != NULL\n\n    companion object {\n        @Suppress(\"DEPRECATION\")\n        fun <T> of(value: T) = Optional<T>(value)\n\n        fun <T : Any> ofNullable(value: T?): Optional<T> =\n            if (value == null) EMPTY\n            else of(value)\n\n        @Suppress(\"DEPRECATION\")\n        val EMPTY = Optional<Nothing>(NULL)\n    }\n\n    private object NULL\n}\n\ninline fun <T> Optional<T>.ifPresent(code: (T) -> Unit) {\n    @Suppress(\"UNCHECKED_CAST\")\n    if (isPresent) return code(value as T)\n}\n\nfun <T> Optional<T>.or(code: () -> T): T {\n    ifPresent { return it }\n    return code()\n}\n\nfun main() {\n    emptyOr { Optional.EMPTY }.value == null\n}\n\nfun <T> emptyOr(other: () -> T): T = Optional.EMPTY.or(other)\n"
        },
        {
            "code": "\nclass Region(\n    val width: Int,\n    val height: Int\n) {\n    fun contains1(x: Int, y: Int) =\n        x in 0 until width && y in 0 until height\n\n    fun contains2(x: Int, y: Int) =\n        x >= 0 && x < width && y >= 0 && y < height\n}\n"
        },
        {
            "code": "\nval map = mapOf<String, Any?>(\"x\" to null)\n\nval x: String by map\n\nfun main(args: Array<String>) {\n    println(x) // silently prints null, but should be NPE\n}\n"
        },
        {
            "code": "\nfun test2(): String = when (String::class) {\n    Int::class -> \"1\"\n    String::class -> \"2\"\n    else -> \"0\"\n}\n"
        },
        {
            "code": "\nval map = mutableMapOf<String, String>()\n\ninline fun <reified T> get(key: String): T? =\n    map[key]?.let {\n        when (T::class) {\n            String::class -> it as T\n            Int::class -> it.toInt() as T\n            Float::class -> it.toFloat() as T\n            Double::class -> it.toDouble() as T\n            else -> throw IllegalArgumentException(\"Not implemented for the given type.\")\n        }\n    }\n\nfun test() {\n    map[\"count\"] = \"1\"\n\n    assert(getAsInt(\"count\") == 1)\n    assert(getAsIntOptimal(\"count\") == 1)\n}\n\n//inlined will all when branches, ~50 lines of bytecode\nprivate fun getAsInt(key: String) = get<Int>(key)\n\n//ideal result, ~10 lines of bytecode\nprivate fun getAsIntOptimal(key: String) = map[key]?.toInt()\n"
        },
        {
            "code": "\ninline fun foo(x: () -> Any) = Pair(x(), x())\n\nfun main() {\n    val (x, y) = foo {\n        class C\n        C()\n    }\n    val (a, b) = foo {\n        object {}\n    }\n\n    println(x.javaClass == y.javaClass) // should print \"true\"\n    println(a.javaClass == b.javaClass) // should print \"true\"\n}\n"
        },
        {
            "code": "\nfun Char.toDigit() = this - '0'\n\nclass MyNumber(val s: String) {\n    companion object {\n        fun fromString(s: String) = MyNumber(s)\n    }\n\n    fun getDigit(index: Int) = s[index].toDigit()\n}\n"
        },
        {
            "code": "\nclass C {\n  val map: Map<String, Any> = mapOf<String, Any>()\n  fun f() {\n    for ((a, b) in map) {\n      println(\"$a $b\")\n    }\n  }\n}\n"
        },
        {
            "code": "\nval hi = \"hi\"\n\nfun main() {\n    println(hi?.length) // unnecessary safe call warning\n}\n"
        },
        {
            "code": "\n// IGNORE_BACKEND: JVM_IR, JVM\nfun i(): Boolean = null.equals(\"non-primitive\")\n\n//0 ACONST_NULL\n//0 INVOKESTATIC\n//1 ICONST_0\n"
        },
        {
            "code": "\nprivate fun foo(s: String?): String? = s?.trim() \n"
        },
        {
            "code": "\nclass KotlinConstPool {\n  init {\n    val x = java.lang.Byte.SIZE\n  }\n}\n"
        },
        {
            "code": "\nfun main() {\n    val x = Thing(42)\n    when (x) {\n        Thing(42) -> {\n            println(\"foo\")\n            x\n        }\n        else -> {\n            println(\"bar\")\n        }\n    }\n}\n\ninline class Thing(val value: Int)\n"
        },
        {
            "code": "\nfun main() {\n    when (val x = Thing(42)) {\n        Thing(42) -> {\n            println(\"foo\")\n            x\n        }\n        else -> {\n            println(\"bar\")\n        }\n    }\n}\n\ninline class Thing(val value: Int)\n"
        },
        {
            "code": "\nclass Foo {\n  fun foo() {\n    \"crashMe\".let {\n      object : Any() {\n        override fun toString() = this@Foo.toString()\n      }\n    }.toString()\n  }\n}\n\nfun main() {\n  Foo().foo()\n}\n"
        },
        {
            "code": "\npackage foo\n\ninterface A\nclass B : A\n\ninline fun <T : A> foo(a: Any) = (a as? T != null).toString()[0]\n\nfun box(): String {\n    val s = \"\" + foo<B>(Any()) + foo<B>(object : A {}) + foo<B>(B())\n    if (s != \"ftt\") return \"fail: $s\"\n    return \"OK\"\n}\n\nfun main(args: Array<String>) {\n    println(box())\n}\n"
        },
        {
            "code": "\ninline class Z(val x: Int)\ninline class S(val s: String)\n\nfun test(a: Z, b: Z) = a == b\nfun test(a: S, b: S) = a == b\n"
        },
        {
            "code": "\ninterface ParentInterface {\n    val child: ChildInterface\n}\n\ninterface ChildInterface {\n    val field: String\n}\n\nfun crash(data: String): ParentInterface =\n    Unit.let {\n        object : ParentInterface {\n            override val child = object : ChildInterface {\n                override val field = data\n            }\n        }\n    }\n\nfun main(arg: Array<String>) {\n    crash(\"test\")\n}\n"
        },
        {
            "code": "\npackage kotlinjs.test\n\nclass Wrapper() {\n    inline fun someInline(x: Int, f: (Int) -> Unit) = f(x*x)\n    fun chainc(): Wrapper {\n        println(\"omitted?\")\n        return Wrapper()\n    }\n}\n\nfun main(args: Array<String>) {\n    Wrapper()\n        .chainc()\n        .someInline(2) {\n            print(\"in lambda $it\")\n        }\n}\n"
        },
        {
            "code": "\nobject `?` // compiles in Linux/JVM, compile crash in Windows/JVM, compile error in JS\nobject `*` // compiles in Linux/JVM, compile crash in Windows/JVM, compile error in JS\nobject `\"` // compiles in Linux/JVM, compile crash in Windows/JVM, compile error in JS\nobject `%JAVA_HOME%` // compiles in Linux/JVM, compiles in Windows/JVM, compile error in JS - but in Windows there can be problems with such file\n"
        },
        {
            "code": "\nannotation class Anno(val x: Array<String> = [\"\"])\n"
        },
        {
            "code": "\npackage test.p1\n\nabstract class Base {\n    protected var x = 42\n        private set\n\n    protected abstract fun foo()\n}\n"
        },
        {
            "code": "\npackage flow\n\ninterface FlowCollector<T> {\n    suspend fun emit(value: T)\n}\n\ninterface Flow<T : Any> {\n    suspend fun collect(collector: FlowCollector<T>)\n}\n\nabstract class FuseableFlow<T : Any, R : Any>() : Flow<R> {}\n\ntypealias Transformer<T, R> = suspend (T) -> R?\n\npublic inline fun <T : Any> flow(crossinline block: suspend FlowCollector<T>.() -> Unit) = object : Flow<T> {\n    override suspend fun collect(collector: FlowCollector<T>) = collector.block()\n}\n\nsuspend inline fun <T : Any> Flow<T>.collect(crossinline action: suspend (T) -> Unit): Unit =\n    collect(object : FlowCollector<T> {\n        override suspend fun emit(value: T) = action(value)\n    })\n\npublic suspend fun <T: Any> Flow<T>.awaitSingle(): T {\n    var result: T? = null\n    collect {\n        if (result != null) error(\"Expected only one element\")\n        result = it\n    }\n\n    return result ?: throw NoSuchElementException(\"Expected at least one element\")\n}\n"
        },
        {
            "code": "\nfun main() {\n    val list = arrayOf(1)\n    println(list[4])\n}\n"
        },
        {
            "code": "\nimport java.util.function.Supplier\n\nfun main() {\n    printAndGetBean {\n        object : AbstractBean() {\n            override fun value() = 42\n        }\n    }\n}\n\nabstract class AbstractBean {\n    abstract fun value(): Int\n}\n\ninline fun <reified T : Any> printAndGetBean(crossinline function: () -> T): T {\n    println(T::class.java.name)\n    return Supplier { function.invoke() }.get()\n}\n"
        },
        {
            "code": "\nfun call(block: () -> Unit): Unit = TODO()\n\nclass A {\n    \n    private fun a(x: String) = run {\n        {\n            x\n            call {\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\npackage a.b.c\n\nfun main() {\n  Class.forName(\"a.b.c.X\")\n}\n\nclass X {\n  val num = 42\n  val map: Int = 1.apply {\n    object : Y({ true }) {\n      override fun fun1() {\n        println(num)\n      }\n    }\n  }\n}\n\nabstract class Y(val lambda: () -> Boolean) {\n  abstract fun fun1()\n}\n"
        },
        {
            "code": "\nopen class A {\n    fun toto() {\n        if (this is B) {\n            C()\n        }\n    }\n}\n\nclass B: A() { inner class C }\n\nfun main(args: Array<String>) {\n    B().toto()\n}\n"
        },
        {
            "code": "\nval x = foo()\nfun foo() {\n    notYetInitialized // val is null due to initialization order, but static analyzer sees 'Nothing' and thinks control flow ends up here\n    println(\"Static analyzer thinks that this code is unreachable, but you will see it in output anyway\") // [UNREACHABLE_CODE] Unreachable code\n}\nval notYetInitialized: Nothing = throw Exception()\n\nfun main() {}\n"
        },
        {
            "code": "\nfun <T> Any?.asGeneric() = this as? T //There is warning about unchecked cast here\n\nfun main()\n{\n\t42.asGeneric<Nothing>()!!\n\tprintln(\"Static analyzer thinks that this code is unreachable, but you will see it in output anyway\") //Unreachable code, but will be executed\n}\n"
        },
        {
            "code": "\nval tryExecUnreachable = execUnreachable() //Initialized before notYetInitialized\nfun execUnreachable()\n{\n\tnotYetInitialized //This variable is null right now, because of initialization order. No access to this variable, so there is no NPE, but static analyzer see 'Nothing' and thinks control flow ends up here\n\tprintln(\"Static analyzer thinks that this code is unreachable, but you will see it in output anyway\") //Unreachable code, but will be executed\n}\n\nval notYetInitialized : Nothing = initFail() //'Instance' of Nothing, by the way, it is meant to be impossible\nfun initFail() : Nothing = throw Exception(\"Crash with exception eventually\") //This example will crash here when it will be time to initialize 'notYetInitialized' variable\n\nfun main()\n{\n\ttryExecUnreachable //Use it somehow\n}\n"
        },
        {
            "code": "\ninterface A\n\ninterface B : A {\n    fun f(s: String = \"default\"): String\n}\n\nclass C : B {\n    override fun f(s: String): String = s\n}\n"
        },
        {
            "code": "\nfun <T> foo(num: T): String = when (num) {\n        is Int -> \"int\"\n        is Double -> \"dbl\"\n\telse -> \"else\"\n}\n\n\nfun main() {\n    val a = 5\n    val d = 3.141593\n    println(foo(a))\n    println(foo(d))\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    var a : Any = 1 // Int\n    if (a is Double) {\n        a += 1.5\n    }\n    println(a)\n}\n"
        },
        {
            "code": "\ninline class Age(val value: Int)\n"
        },
        {
            "code": "\nprivate class Impl(val foo: Int)\n"
        },
        {
            "code": "\ninline  class Texture(val id: Int) {\n\tfun generate() {\n\t\tcheckBound()\n\t}\n\tcompanion object {\n\t\tprivate inline fun Texture.checkBound(){\n\t\t\tcheck(boundTexture == this)\n\t\t}\n\t\tprivate var boundTexture: Texture? = null\n\t}\n}\n"
        },
        {
            "code": "\ninline class ResultOrClosed(val x: Any?)\ninterface A<T> {\n    fun foo(): T\n}\n\nclass B : A<ResultOrClosed> {\n    override fun foo(): ResultOrClosed = ResultOrClosed(\"\")\n}\n\nfun main() {\n    val foo1: Any = ResultOrClosed(\"\")\n    val foo2: Any = (B() as A<ResultOrClosed>).foo()\n\n    println(foo1 is ResultOrClosed) // prints true\n    println(foo2 is ResultOrClosed) // prints false\n}\n"
        },
        {
            "code": "\ninterface A {\n    fun foo(): Any\n}\n\nclass B : A {\n    override fun foo(): String { // Covariant override, return type is more specialized than in the parent\n        return \"\"\n    }\n}\n"
        },
        {
            "code": "\ninterface GenericA<T> {\n    fun foo(): T\n}\n\nclass SpecializedB : GenericA<String> {\n    override fun foo(): String {\n        return \"\"\n    }\n}\n"
        },
        {
            "code": "\ninline class ICAny(val a: Any)\n"
        },
        {
            "code": "\ninline class ICAny(val a: Any)\n\ninterface A {\n    fun foo(): Any\n}\n\nclass B : A {\n    override fun foo(): ICAny {\n        TODO()\n    }\n}\n"
        },
        {
            "code": "\ninterface PrimitiveA {\n    fun foo(): Any\n}\n\nclass PrimitiveB : PrimitiveA {\n    override fun foo(): Int {\n        return 42\n    }\n}\n"
        },
        {
            "code": "\ninline class ICAny(val a: Any)\n\ninterface A {\n    fun foo(): Any\n}\n\nclass B : A {\n    override fun foo(): ICAny {\n        TODO()\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.intrinsics.*\n\nsuspend inline fun foo() = suspendCoroutineUninterceptedOrReturn<String> {\n    error(\"Failed\")\n}\n\n// Extra     INVOKESTATIC kotlin/jvm/internal/InlineMarker.mark (I)V invocation in here\nsuspend fun bar() {\n    foo() \n}\n"
        },
        {
            "code": "\nopen class A\n\ninline fun <T> call(lambda: () -> T): T {\n    return lambda()\n}\n\nfun main(args: Array<String>) {\n    val x = 1\n    val result = call {\n        object : A() {\n            val p = x\n        }\n    }\n\n    result.p\n}\n"
        },
        {
            "code": "\n@JvmOverloads\nfun defFun(d: Boolean = false) { println(d) }\nfun defUse() { defFun() }\n"
        },
        {
            "code": "\n/*\n * Execution fails due to a type error on trying to get the\n * prototype of undefined. It turns out, it tries to access\n * \"Kotlin.kotlin.Number\" (In my own gradle-based build, exact path\n * may vary), which is never actually defined.\n */\n\nfun main(args: Array<String>) {\n    // This should just print \"2\"\n    println(CustomInteger(2))\n}\n\n// Class that extends \"kotlin.Number\"\nclass CustomInteger(private var value: Int = 0) : Number() {\n    override fun toString() = value.toString()\n    override fun toByte() = value.toByte()\n    override fun toShort() = value.toShort()\n    override fun toInt() = value\n    override fun toLong() = value.toLong()\n    override fun toFloat() = value.toFloat()\n    override fun toDouble() = value.toDouble()\n    override fun toChar() = value.toChar()\n}\n"
        },
        {
            "code": "\nfun main() {\n    MyMap<Unit,Unit>().entries\n}\n\nclass MyMap<K,V>: AbstractMap<K, V>() {\n    override val entries: HashSet<Map.Entry<K, V>>\n        get() = hashSetOf()\n    override val keys: Set<K>\n        get() = setOf()\n    override val values: Collection<V>\n        get() = listOf()\n}\n"
        },
        {
            "code": "\nfun main() {\n    MyMap<Unit,Unit>().entries\n}\n\nclass MyMap<K,V>: AbstractMap<K, V>() {\n    fun getEntries(): Set<Map.Entry<K, V>> {\n        println(\"getEntries\")\n        return createEntries()\n    }\n    override val entries: HashSet<Map.Entry<K, V>>\n        get() {\n            println(\"entries\")\n            return createEntries()\n        }\n    private fun createEntries(): HashSet<Map.Entry<K, V>> {\n        return hashSetOf()\n    }\n\n    override val keys: Set<K>\n        get() = hashSetOf()\n    override val values: Collection<V>\n        get() = listOf()\n}\n"
        },
        {
            "code": "\nclass MyMap : AbstractMap<String, String>() {\n    override val entries: HashSet<Map.Entry<String, String>> = HashSet()\n}\n"
        },
        {
            "code": "\nclass MyMap : AbstractMap<String, String>() {\n    override val entries: Set<Map.Entry<String, String>> = HashSet()\n}\n"
        },
        {
            "code": "\ninterface A\nfun main(vararg args: String){\n    println(object: A{}::class.java.simpleName)\n}\n"
        },
        {
            "code": "\n    class C {\n        var s: String = \"aaa\"\n    }\n\n    fun F(c: C?): String\n    {\n        return c?.s ?: \"null\"\n    }\n"
        },
        {
            "code": "\nfun foo(s: String) =\n    s.indexOf(\"foo\").takeIf { it >= 0 } ?: s.length\n"
        },
        {
            "code": "\nclass C(val s: String?)\n\nfun test1(x: C?) =\n        x?.run { s?.length } ?: 0\n\nfun test2(x: C?) =\n        x?.s?.length ?: 0\n"
        },
        {
            "code": "\ninline class WrappingInt(val value: Int) {\n    operator fun inc(): WrappingInt = plus(1)\n    operator fun plus(num: Int): WrappingInt = WrappingInt((value + num) and 0xFFFF)\n}\n\nfun main() {\n    var x = WrappingInt(65535)\n    x++\n    println(x) // prints 0 (correct)\n\n    var y = WrappingInt(65535)\n    ++y\n    println(y) // prints 65536\n}\n"
        },
        {
            "code": "\nclass SomeClass {\n    private val innerObject = InnerObject()\n    class InnerObject {\n        private inline fun bar(action: () -> Unit) {\n            action()\n        }\n\n        fun foo() {\n            bar { println(\"foo\") }\n        }\n    }\n}\n"
        },
        {
            "code": "\nclass Environment(\n    val fieldAccessedInsideChild: Int,\n    val how: Environment.() -> Unit\n)\n\nfun main(args: Array<String>) {\n    Environment(\n        3,\n        {\n            class Child {\n                val a = fieldAccessedInsideChild\n            }\n\n            class Parent {\n                val children: List<Child> =\n                    (0..4).map { Child() }\n            }\n        }\n    )\n}\n\n"
        },
        {
            "code": "\ninterface Inf\n\nclass KotlinBugCase0 {\n    private val outVar = \"ok\"\n\n    val foo = \"anything\".let {\n        object : Inf {\n            init {\n                println(outVar)\n            }\n        }\n    }\n}\n\nclass KotlinBugCase1 {\n    val foo = \"anything\"?.let {\n        object : Inf {\n            init {\n                println(\"ok\")\n            }\n        }\n    }\n}\n\nclass KotlinBugCase2 {\n    private val outVar = \"wrong\"\n\n    val foo = \"anything\"?.let {\n        object : Inf {\n            init {\n                println(outVar)\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    KotlinBugCase0()\n    KotlinBugCase1()\n    KotlinBugCase2()\n}\n"
        },
        {
            "code": "\ntypealias Lambda = (\n    Int, Int, Int, Int, Int, Int, Int, Int,\n    Int, Int, Int, Int, Int, Int, Int, Int,\n    Int, Int, Int, Int, Int, Int, Int\n) -> Unit // 23 arguments\n\nclass A : Lambda {\n    override fun invoke(\n        p1: Int, p2: Int, p3: Int, p4: Int,\n        p5: Int, p6: Int, p7: Int, p8: Int,\n        p9: Int, p10: Int, p11: Int, p12: Int,\n        p13: Int, p14: Int, p15: Int, p16: Int,\n        p17: Int, p18: Int, p19: Int, p20: Int,\n        p21: Int, p22: Int, p23: Int\n    ) {\n    }\n}\n\nfun main() {\n    val a = A()\n    println(a is Lambda)\n}\n"
        },
        {
            "code": "\nfun doit() {\n    print(3)\n}\n"
        },
        {
            "code": "\nfun Double.coerceToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"NaN\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> toLong()\n}\n"
        },
        {
            "code": "\nfun main() = println(true xor false) // prints '1'\n"
        },
        {
            "code": "\ndata class Example @JvmOverloads constructor(\n        var one: String = \"\",\n        var two: String = \"\",\n        var three: String = \"\",\n        var four: String = \"\",\n        var five: String = \"\",\n        var six: String = \"\",\n        var seven: String = \"\",\n        var eight: String = \"\",\n        var nine: String = \"\",\n        var ten: String = \"\",\n        var eleven: String = \"\",\n        var twelve: String = \"\",\n        var thirteen: String = \"\",\n        var fourteen: String = \"\",\n        var fifteen: String = \"\",\n        var sixteen: String = \"\",\n        var seventeen: String = \"\",\n        var eighteen: String = \"\",\n        var nineteen: String = \"\",\n        var twenty: String = \"\",\n        var twentyOne: String = \"\",\n        var twentyTwo: String = \"\",\n        var twentyThree: String = \"\",\n        var twentyFour: String = \"\",\n        var twentyFive: String = \"\",\n        var twentySix: String = \"\",\n        var twentySeven: String = \"\",\n        var twentyEight: String = \"\",\n        var twentyNine: String = \"\",\n        var thirty: String = \"\",\n        var thirtyOne: String = \"\",\n        var thirtyTwo: String = \"\",\n        var thirtyThree: String = \"\",\n        var thirtyFour: String = \"\"\n)\n"
        },
        {
            "code": "\nclass A {\n    companion object {\n// public final static synthetic access$getFoo$cp()I\n        private val foo = 1\n        \n        fun bar() = foo\n    }\n}\n"
        },
        {
            "code": "\nfun <T: Int> cast(origin: Any): T? = origin as? T\n\nfun main() {\n    val castFun = cast<Int>(\"123\")\n    println(castFun)\n}\n"
        },
        {
            "code": "\n    class K<T>() where T : Any, T : CharSequence? {\n        fun f(x: T) {} // No null check\n    }\n    "
        },
        {
            "code": "\n    class K<T>() where T : Any?, T : CharSequence {\n        fun cast(x: Any?) {\n            val a = x as T // No null check\n            println(a)\n        }\n    }\n    "
        },
        {
            "code": "\n    fun <T> foo(s: T): Int where T : String?, T : CharSequence =\n        when (s) { // No null check\n            \"1\" -> 1\n            else -> 0\n        }\n    "
        },
        {
            "code": "\nfun main() {\n    // BUG IS HERE. Expected: [1], Actual []\n    println(\n        sequenceOf(1, 2, 3)\n            .filterNot { (it == 2) or (it == 3) }\n            .toList()\n    )\n    \n    // NOTE 1: Replacing the 'or' operator by || fixes the problem\n    println(\n        sequenceOf(1, 2, 3)\n            .filterNot { (it == 2) || (it == 3) }\n            .toList()\n    )\n\n    // NOTE 2: Using lists rather than sequences also fixes the problem\n    println(\n        listOf(1, 2, 3)\n            .filterNot { (it == 2) || (it == 3) }\n    )\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.*\n\nfun test(k: KClass<*>, a: Any) {\n    println(k.toString())\n    println(k.hashCode())\n    val c = a::class\n    println(c.toString())\n    println(c.hashCode())\n    println()\n}\n\nfun main(args: Array<String>){\ntest(1::class, 1)\ntest(1L::class, 1L)\ntest(1.0::class, 1.0)\ntest(1.1::class, 1.1)\ntest(1.0f::class, 1.0f)\ntest(1.1f::class, 1.1f)\ntest(\"\"::class, \"\")\ntest({}::class, {})\ntest(A()::class, A())\n}\n\nclass A\n"
        },
        {
            "code": "\nfun main() {\n    println(foo(Result.runCatching { 1 }) + 1)\n}\n\nfun <T> foo(a: Result<T>): T = bar(a) { \n    println(it)\n    it.getOrThrow()\n}\n\nfun <T, R> bar(value: T, f: (T) -> R): R {\n    return f(value)\n}\n"
        },
        {
            "code": "\n//import java.util.*\n\nval testData = mapOf (\n        \"Annotation\" to {Annotation::class},\n        \"Any\" to {Any::class},\n        \"Array\" to {Array<Any>::class}, //<Any>\n        \"AssertionError\" to {AssertionError::class},\n        \"Boolean\" to {Boolean::class},\n        \"BooleanArray\" to {BooleanArray::class},\n        \"Byte\" to {Byte::class},\n        \"ByteArray\" to {ByteArray::class},\n        \"Char\" to {Char::class},\n        \"CharArray\" to {CharArray::class},\n        \"CharSequence\" to {CharSequence::class},\n        \"ClassCastException\" to {ClassCastException::class},\n        \"Comparable\" to {Comparable::class},\n        \"Comparator\" to {Comparator::class},\n        \"ConcurrentModificationException\" to {ConcurrentModificationException::class}, //java.util\n        \"Deprecated\" to {Deprecated::class},\n        \"DeprecationLevel\" to {DeprecationLevel::class},\n        \"Double\" to {Double::class},\n        \"DoubleArray\" to {DoubleArray::class},\n        \"DslMarker\" to {DslMarker::class},\n        \"Enum\" to {Enum::class},\n        \"Error\" to {Error::class},\n        \"Exception\" to {Exception::class},\n        \"ExtensionFunctionType\" to {ExtensionFunctionType::class},\n        \"Float\" to {Float::class},\n        \"FloatArray\" to {FloatArray::class},\n        \"Function\" to {Function::class},\n        \"IllegalArgumentException\" to {IllegalArgumentException::class},\n        \"IllegalStateException\" to {IllegalStateException::class},\n        \"IndexOutOfBoundsException\" to {IndexOutOfBoundsException::class},\n        \"Int\" to {Int::class},\n        \"IntArray\" to {IntArray::class},\n        \"KotlinVersion\" to {KotlinVersion::class},\n        \"Lazy\" to {Lazy::class},\n        \"LazyThreadSafetyMode\" to {LazyThreadSafetyMode::class},\n        \"Long\" to {Long::class},\n        \"LongArray\" to {LongArray::class},\n        \"NoSuchElementException\" to {NoSuchElementException::class},\n        \"Nothing\" to {Nothing::class},\n        \"NotImplementedError\" to {NotImplementedError::class},\n        \"NoWhenBranchMatchedException\" to {NoWhenBranchMatchedException::class},\n        \"NullPointerException\" to {NullPointerException::class},\n        \"Number\" to {Number::class},\n        \"NumberFormatException\" to {NumberFormatException::class},\n        \"Pair\" to {Pair::class},\n        \"ParameterName\" to {ParameterName::class},\n        \"PublishedApi\" to {PublishedApi::class},\n        \"ReplaceWith\" to {ReplaceWith::class},\n        \"RuntimeException\" to {RuntimeException::class},\n        \"Short\" to {Short::class},\n        \"ShortArray\" to {ShortArray::class},\n        \"SinceKotlin\" to {SinceKotlin::class},\n        \"String\" to {String::class},\n        \"Suppress\" to {Suppress::class},\n        \"Synchronized\" to {Synchronized::class},\n        \"Throwable\" to {Throwable::class},\n        \"Triple\" to {Triple::class},\n        \"Unit\" to {Unit::class},\n        \"UnsafeVariance\" to {UnsafeVariance::class},\n        \"UnsupportedOperationException\" to {UnsupportedOperationException::class},\n        \"Volatile\" to {Volatile::class}\n)\nfun test(name : String, f: () -> Any) : String = try {\n    f().toString()\n} catch (e : Throwable) {\n    \"!!! - $e\"\n}\n\nfun main(args: Array<String>) {\n\n    for ((name, function) in testData) {\n        val res = test(name, function).toString()\n        val comment = when {\n            res.startsWith(\"!!!\") -> \"Exception!\"\n            !res.contains(name) -> \"No real name\"\n            else -> \"OK\"\n        }\n\n        println(\"|$name|$res|$comment|\")\n    }\n\n}\n"
        },
        {
            "code": "\n    fun main(args: Array<String>) {\n        try {\n            try {\n                return //or break, continue + for\n            } catch (fail: Throwable) {\n                println(\"catch\")\n            }\n        } finally {\n            println(\"finally\")\n            throw RuntimeException()\n        }\n    }\n"
        },
        {
            "code": "\ninline fun inlineFun(block: (String)-> String) {\n    try {\n        try {\n            block(\"lambda\")\n        } catch (fail: Throwable) {\n            println(\"catch\")\n        }\n    } finally {\n        println(\"finally\")\n        throw RuntimeException()\n    }\n\n}\n\nfun test() {\n    inlineFun {\n        println(\"lambda\")\n        return\n    }\n}\n\nfun main(args: Array<String>) {\n    test()\n}\n"
        },
        {
            "code": "\nval map = mapOf<String, Any?>(\"x\" to null)\n\nval x: String by map\n\nfun main(args: Array<String>) {\n    println(x) // silently prints null, but should be NPE\n}\n"
        },
        {
            "code": "\ninterface A {\n    fun foo(x: Int): Int\n}\n\nabstract class B {\n    abstract fun foo(x: Int = 42): Int\n}\n\nclass C : A, B() {\n    override fun foo(x: Int) = x\n}\n\nfun main(args: Array<String>) {\n    println(C().foo())\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    example<Int>()\n}\ninline fun <reified T: Any> example() {\n    println(T::class == \"1\".toInt()::class) // true\n    println(\"1\".toInt()::class == T::class) // false\n    println(Int::class.isInstance(\"1\".toInt())) // true\n    println(T::class.isInstance(\"1\".toInt())) // false\n}\n"
        },
        {
            "code": "\nfun main() {\n    val result = Result.runCatching { \"Test 01\" }\n    val errorResult = Result.runCatching { throw java.io.IOException(\"Some error happened\") }\n    \n    println(\"Test\")\n    println(test(\"Test 01\", result))\n    println(test(\"Some error happened\", errorResult))\n    \n    println()\n    println(\"With generics\")\n    println(match(\"Test 01\", \"Some error happened\").test(result))\n    println(match(\"Test 01\", \"Some error happened\").test(errorResult))\n    \n    println()\n    println(\"With kotlintest dsl-like\")\n    println(result should match(\"Test 01\", \"Some error happened\"))\n    println(errorResult should match(\"Test 01\", \"Some error happened\"))\n}\n\ninfix fun <T> T.should(matcher: Matcher<T>) = matcher.test(this)\n\nfun test(expectedValue: String, result: Result<String>) = if (result.isSuccess) {\n    expectedValue == result.getOrNull()\n} else {\n    expectedValue == result.exceptionOrNull()?.message\n}\n\nfun <T> match(expectedValue: T, errorMessage: String) = object: Matcher<Result<T>> {\n    override fun test(value: Result<T>) = if (value.isSuccess) {\n        print(\"I'm a success\")\n        Pair(\n            value.getOrNull() == expectedValue,\n            Pair(value.getOrNull(), expectedValue)\n        )\n    } else {\n        print(\"I'm an error\")\n        Pair(\n            value.exceptionOrNull()?.message == errorMessage,\n            Pair(value.exceptionOrNull()?.message, errorMessage)\n        )\n    }\n}\n\ninterface Matcher<T> {\n    fun test(value: T): Pair<Boolean, Pair<Any?, Any?>>\n}\n"
        },
        {
            "code": "\nannotation class Annotation {\n    companion object {\n        @JvmStatic val TEST_FIELD = \"\"\n    }\n}\n\nfun main() {\n    println(Annotation.TEST_FIELD)\n}\n"
        },
        {
            "code": "\n\nabstract class ListBase<out E> : List<E> {\n\n    val lastIndex: Int\n        get() = TODO()\n\n    override fun indexOf(element: @UnsafeVariance E): Int {\n        TODO()\n    }\n\n    override fun lastIndexOf(element: @UnsafeVariance E): Int {\n        TODO()\n    }\n\n    override fun contains(element: @UnsafeVariance E): Boolean {\n        TODO()\n    }\n\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean {\n        TODO()\n    }\n\n    override fun isEmpty(): Boolean {\n        TODO()\n    }\n\n    override fun iterator(): Iterator<E> {\n        TODO()\n    }\n\n    override fun listIterator(): ListIterator<E> {\n        TODO()\n    }\n\n    override fun listIterator(index: Int): ListIterator<E> {\n        TODO()\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<E> {\n        TODO()\n    }\n}\n\nabstract class MutableListBase<E> : ListBase<E>(), MutableList<E> {\n\n    override fun add(index: Int, element: E) {\n        TODO()\n    }\n\n    override val size: Int\n        get() = TODO()\n\n    override fun get(index: Int): E = TODO()\n\n    override fun set(index: Int, element: E): E {\n        TODO()\n    }\n\n    override fun add(element: E): Boolean {\n        TODO()\n    }\n\n    override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        TODO()\n    }\n\n    override fun addAll(elements: Collection<E>): Boolean {\n        TODO()\n    }\n\n    override fun remove(element: E): Boolean {\n        TODO()\n    }\n\n    override fun removeAll(elements: Collection<E>): Boolean {\n        TODO()\n    }\n\n    override fun retainAll(elements: Collection<E>): Boolean {\n        TODO()\n    }\n\n    override fun clear() {\n        TODO()\n    }\n\n    override fun iterator(): MutableIterator<E> {\n        TODO()\n    }\n\n    override fun listIterator(): MutableListIterator<E> {\n        TODO()\n    }\n\n    override fun listIterator(index: Int): MutableListIterator<E> {\n        TODO()\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> {\n        TODO()\n    }\n}\n"
        },
        {
            "code": "\nclass Foo(val i: Int) {\n    init {\n        val z = \"42\"\n        val zz = z.toInt()\n    }\n}\n"
        },
        {
            "code": "\npackage test1\n\nprivate interface PrivateInFileInterface\n\nclass Public1 : PrivateInFileInterface\nclass Public2 : PrivateInFileInterface\n"
        },
        {
            "code": "\nval x: List<Int> = y()\n\nval z: List<Int> = listOf(1)\n\nfun y(): List<Int> = z\n\nfun main() {\n  println(x.toString())\n}\n"
        },
        {
            "code": "\nfun <T> something(): T = Any() as T\n\nclass Context<T>\n\nfun <T> Any.decodeIn(typeFrom: Context<in T>): T = something()\n\nfun <T> Any?.decodeOut(typeFrom: Context<out T>): T {\n    return this?.decodeIn(typeFrom) ?: error(\"\")  // decodeIn result is of type Nothing\n}\n\nfun main(args: Array<String>) {\n    val r = \"str\".decodeOut(Context<Any>())\n    println(r)\n}\n"
        },
        {
            "code": "\nenum class X(y : Y) {A(Y.B);\n    init {\n        when (y) {Y.B -> {}}\n    }\n    \n    fun neverCall(x : X) {\n        when(x) {X.A -> {}}\n    }\n}\n\nenum class Y() {B }\n\nfun main(args: Array<String>) {\n    print(X.A)\n}\n"
        },
        {
            "code": "\nfun main() {\n    testSafe(Test(\"Tom\"))\n    testSafe(null)\n\n    println(\"---------\")\n\n    testBug(Test(\"Tom\"))\n    testBug(null)\n}\n\nfun testBug(test: Test?) {\n    println(test?.Inner()?.thing)\n}\n\nfun testSafe(test: Test?) {\n    println(test?.createInner()?.thing)\n}\n\nclass Test(val name: String) {\n    inner class Inner {\n        val thing: String\n            get() = \"Hello, $name\"\n    }\n\n    fun createInner() = Inner()\n}\n"
        },
        {
            "code": "\ndata class Something(\n        val colorsByString: Map<String, Color>\n)\n\nenum class Color {\n    RED, BLUE;\n}\n"
        },
        {
            "code": "\n// module \"core\"\nsuspend fun suspendedCast(arg: String) = arg as Any\n\nsuspend inline fun throwCompilerError(token: String?) {\n    token?.let { suspendedCast(it) }\n}\n\n// module \"sample\"\nsuspend fun main() {\n    // this will throw a compiler error as it is in a separate module\n    throwCompilerError(\"any string or null\")\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n\n    val context = object : Interface, AnotherInterface {\n        override val guy: AnotherInterface get() = this\n    }\n\n    with(context) {\n        TargetClass(\"Here we go!\")\n            .perform()\n    }\n\n}\n\ndata class TargetClass(val value: String)\n\ninterface Interface {\n\n    val guy: AnotherInterface\n\n    fun TargetClass.perform() {\n        println(\"Target class perform\")\n\n        DifferentClass(value)\n            .perform()\n    }\n\n    private fun DifferentClass.perform() = with(guy) {\n        perform()\n    }\n\n}\n\ndata class DifferentClass(val value: String)\n\ninterface AnotherInterface {\n\n    fun DifferentClass.perform() {\n        println(\"DifferentClass perform\")\n    }\n\n}\n"
        },
        {
            "code": "\ndata class Report(val content: String)\ntypealias Reporter = (Report) -> Unit\n\nfun reporterA(report:Report) { println(\"A: $report\")}\nfun reporterB(report:Report) { println(\"B: $report\")}\n\nclass CompositeReporter(val delegates:Array<out Reporter>):Reporter {\n    override fun invoke(report: Report) {\n       delegates.forEach { reporter -> reporter(report) }\n    }\n}\nfun main(){\n    val reporter = CompositeReporter(arrayOf(::reporterA, ::reporterB))\n    reporter(Report(\"Content\"))\n}\n"
        },
        {
            "code": "\nclass KotlinBug {\n    interface Inf {\n        fun print(string: String)\n    }\n\n    class Printer(val name: String) : Inf {\n        override fun print(string: String) {\n            println(\"$name:[$string]\")\n        }\n    }\n\n    companion object {\n        fun <I> function(arg: I, vararg func: (I) -> Unit) {\n            func.forEach { it(arg) }\n            println()\n        }\n\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val a = Printer(\"A\")\n            val b = Printer(\"B\")\n            val arrayFromClass = listOf(a, b).map { it::print }.toTypedArray()\n\n            val x = fun(string: String) { println(\"X:[$string]\") }\n            val y = fun(string: String) { println(\"Y:[$string]\") }\n            val arrayFromAnonymous = listOf(x, y).toTypedArray()\n\n            function(\"Single Class\", a::print)\n            function(\"Anyone From Class Array\", arrayFromClass[0])\n            function(\"Anyone From Class Array\", arrayFromClass[1])\n            function(\"Anonymous Lambda Array\", *arrayFromAnonymous)\n            function(\"Class Array\", *arrayFromClass)\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) = println(testy())\n\n// Typealias with generic parameter\ntypealias Testy<T> = Pair<T, T>\n\n// Inline function calling constructor of typealias\ninline fun testy(): Testy<String> = Testy(\"1\", \"2\")\n\n// This version compiles and executes fine\n// inline fun testy(): Testy<String> = Pair(\"1\", \"2\")\n"
        },
        {
            "code": "\n@file:JvmName(TAG)\n\npackage playground\n\nprivate const val TAG = \"MyBar\"\n"
        },
        {
            "code": "\nabstract class NumberParent: Number(){\n    \n}\n\nclass MyNumber(val v: Double): NumberParent(){\n    override fun toByte(): Byte = v.toByte()\n\n    override fun toChar(): Char = v.toChar()\n\n    override fun toDouble(): Double = v\n\n    override fun toFloat(): Float = v.toFloat()\n\n    override fun toInt(): Int = v.toInt()\n\n    override fun toLong(): Long = v.toLong()\n\n    override fun toShort(): Short = v.toShort()\n}\n\n\nfun main(args: Array<String>) {\n    val myNumber = MyNumber(4.0)\n    println(myNumber)\n\tprintln(myNumber.toDouble())\n}\n"
        },
        {
            "code": "\nfun checkFloatArray(): Boolean {\n    val floatArray = floatArrayOf(1.1f, 2.2f, 3.3f)\n    var sum = 0f\n    for (i in 0..floatArray.size - 1) {\n        sum += floatArray[i]\n    }\n    if (sum != (1.1f + 2.2f + 3.3f)) return false\n    return true\n}\n"
        },
        {
            "code": "\n  val mapa = HashMap<Int, Int>()\n  inline fun teste() = mapa[0] ?: 1\n  "
        },
        {
            "code": "\nfun coroutineBuilder(block: suspend () -> Unit) = Unit\n\nsuspend fun suspending(block: () -> Unit) = Unit\n\nfun main(args: Array<String>) {\n    `test)`()\n}\n\nfun `test)`() {\n    val value = 1\n    coroutineBuilder {\n        suspending {\n            println(value)\n        }\n    }\n}\n"
        },
        {
            "code": "\nimport java.util.*\n\ninterface I {\n    fun test() = object : ArrayList<String>() {}\n}\n\nclass C : I\n\nfun main(args: Array<String>) {\n    val testAnonimousClass = C().test().javaClass\n    println(testAnonimousClass.enclosingClass.canonicalName)//I.DefaultImpls => OK\n    println(testAnonimousClass.name) //I$test$1 =>KO! (should be I.DefaultImpls$test$1\n    //java.lang.Class#getSimpleBinaryName (used by #getSimpleName) does this :\n    //getName().substring(enclosingClass.getName().length()) and the result should start with $ to be valid\n    testAnonimousClass.simpleName //throw InternalError(\"Malformed class name\")\n}\n"
        },
        {
            "code": "\nfun main() {\n    for (x in UByte.MIN_VALUE..UByte.MAX_VALUE) {\n        println(x)\n    }\n}\n"
        },
        {
            "code": "\nfun main() {\n    var n = 0u\n    for (x in UByte.MIN_VALUE..UByte.MAX_VALUE) {\n        n = x\n    }\n    println(n)\n}\n"
        },
        {
            "code": "\nsealed class Base\n\nclass Derived : Base()\n\nobject Instance : Base()\n\nfun foo(base: Base) {\n    when (base) {\n        is Derived -> println(\"Derived\")\n        Instance -> println(\"Instance\")\n    }\n}\n"
        },
        {
            "code": "\ninline fun a(f: () -> Any) =\n    try {\n        f()\n    } finally {\n        throw RuntimeException()\n    }\n\nfun b(vararg functions: () -> Any) = a {\n    for (function in functions) {\n        try {\n            return function()\n        } catch (fail: Throwable) {}\n    }\n}\n\nfun main(args: Array<String>) {\n    b({ println(1); 1 }, { println(2); 2 })\n}\n"
        },
        {
            "code": "\ninterface Headers {\n    var accept: String?\n    var `content-length`: String?\n}\n\nval headers: Headers = TODO(\"value provided by a JS library\")\nval accept = headers.accept\nval length = headers.`content-length`\n"
        },
        {
            "code": "\nopen class Foo(val x: Int)\nclass Bar(val y: Int)\n\nfun foo(bar: Bar): Foo {\n    return object: Foo(bar.y) {}\n}\n\nfun main() {\n    val x = foo(Bar(1))\n    println(x.javaClass.declaredFields.joinToString { it.name })\n}\n"
        },
        {
            "code": "\ninterface I1\ninterface I2\n\nfun <T> foo(x: Any) where T : I1, T : I2 {\n    x as T // Should be checked for I1 and I2, but there's only CHECKCAST I1\n}\n\nclass W : I1, I2\n\nfun main() {\n    foo<W>(object : I1 {}) // CCE should happen, but it doesn't\n}\n"
        },
        {
            "code": "\npackage test\n\nclass ML<T> {\n    val list = ArrayList<T>()\n\n    fun add(x: T) {\n        list.add(x)\n    }\n}\n\ninterface IFoo {\n    fun foo()\n}\n\ninterface IBar {\n    fun bar()\n}\n\nclass C<T> where T : IFoo, T : IBar {\n    fun foo(a: Any, b: Any) {\n        a as ML<IBar>\n        b as T\n        a.add(b)\n    }\n}\n\nclass FooImpl : IFoo {\n    override fun foo() {}\n}\n\nclass FooBar : IFoo, IBar {\n    override fun foo() {}\n    override fun bar() {}\n}\n\nfun main() {\n    val c = C<FooBar>()\n    val ml = ML<IBar>()\n    c.foo(ml, FooImpl())\n    println(ml.list)\n}\n"
        },
        {
            "code": "\nclass case\nclass Case\n\nfun main(args: Array<String>) {\n\n    case()\n    Case()\n\n}\n"
        },
        {
            "code": ""
        },
        {
            "code": "\ninline class InlineString(val v: String)\nfun main() {\n    val x = InlineString(\"\")::javaClass\n    println(x.get()) //output: class java.lang.String\n}\n"
        },
        {
            "code": "\nsuspend fun foo() {}\n\nfun main() {\n    val fooRef: suspend () -> Unit = f@{ \n        return@f foo() \n    }\n}\n"
        },
        {
            "code": "\n// function compiled with -jvm-target: 1.8\ninline fun inlineFun(p: () -> Unit) {\n    p()\n}\n\n// function compiled with -jvm-target: 1.6\nfun test() {\n    inlineFun {} // EROR\n}\n"
        },
        {
            "code": "\n// Base class compiled with -jvm-target 1.8\nopen class Base {\n    inline fun inlineFunBase(p: () -> Unit) {\n        p()\n    }\n}\n\n// Derived class compiled with -jvm-target 1.6\nclass Derived : Base() {\n    fun test() {\n        inlineFunBase {} // no error, missed diagnostic\n    }\n}\n"
        },
        {
            "code": "\nfun foo(param: String = \"bar\") { }\n"
        },
        {
            "code": "\nannotation class MethodAnnotation\nannotation class ParameterAnnotation\n\n@MethodAnnotation\nfun foo(@ParameterAnnotation param: String = \"bar\") { }\n"
        },
        {
            "code": "\n// Module m1:\n\npublic inline fun <reified T> test() {}\n"
        },
        {
            "code": "\nclass C {\n    inline fun <reified T> test() {}\n}\n\nfun main() {\n    println(C::class.java.getMethod(\"test\"))\n}\n"
        },
        {
            "code": "\npublic class ClassWithField {\n    companion object {\n        private val field: Int = 2\n    }\n}\n"
        },
        {
            "code": " val field = \"Hello, World!\""
        },
        {
            "code": "\nprivate fun main(args: Array<String>) {\n}\n"
        },
        {
            "code": "\nprivate fun main() {\n}\n"
        },
        {
            "code": "\nprivate fun main() {\n}\n\npublic fun main(args: Array<String>) = main()  // generated method\n"
        },
        {
            "code": "\nsuspend fun foo() {}\n\nfun fooRef(): suspend () -> Unit = ::foo\n"
        },
        {
            "code": "\n\n"
        },
        {
            "code": "\nvar counter = 0\nfun inc() = counter++\n\ntailrec fun test(x: Int = 0, y: Int = inc(), z: Int = inc()) {\n   if (x * 2 != y || z - y != 1)\n       throw IllegalArgumentException(\"x=$x y=$y z=$z\")\n\n   if (x < 100000)\n       test(x + 1) // default value for `y` initialized after default value for `z` so exception would be thrown on next call\n                           // Code without `tailrec` optimization works as expected\n}\n\nfun main() {\n   test()\n}\n"
        },
        {
            "code": "\nsuspend inline fun inlineMe(crossinline c: suspend () -> Unit) {\n    c()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(causesVerifyErrorSample())\n}\n\nfun causesVerifyErrorSample(): Sample<Boolean> = Sample\n    // Calling Type with generic T\n    .Success(true)\n    .flatMap { Sample.Failure(RuntimeException()) }\n\nsealed class Sample<out T> {\n    companion object {\n        fun <A> just(a: A): Sample<A> = Success(a)\n        fun <A> raise(e: Throwable): Sample<A> = Failure(e)\n    }\n\n    inline fun <R> flatMap(f: (T) -> Sample<R>): Sample<R> =\n        when (this) {\n            // First clause been Type with generic Nothing\n            is Failure -> this\n            is Success -> f(this.value)\n        }\n\n    data class Failure(val exception: Throwable): Sample<Nothing>()\n    data class Success<out T>(val value: T): Sample<T>()\n}\n"
        },
        {
            "code": "\nfun foo(x: (String) -> Unit) {}\n\nfun main(args: Array<String>) {\n    foo {\n        println(it)\n    }\n}\n"
        },
        {
            "code": "\nenum class A {\n  A, B\n}\nenum class B {\n  A, B\n}\nfun main(args: Array<String>) {\n  val a = A.A\n  when (a) {\n    A.A -> println(\"A.A\") // should hit this\n    A.B -> println(\"A.B\")\n    B.A -> println(\"B.A\") // but hitting this branch\n    B.B -> println(\"B.B\")\n  }\n}\n"
        },
        {
            "code": "\nenum class A {\n    A\n}\n\nenum class B {\n    B\n}\n\nfun f() = A.A\n\nfun main (args: Array<String>) {\n    when (f()) {\n        B.B -> println(\"Not ok\")\n        A.A -> println(\"Ok\")\n    }\n}\n"
        },
        {
            "code": "\npackage com.test\n\nclass Example {\n\n    fun pathParam(key: String): String = \"param=$key\"\n    inline fun <reified T : Any> pathParam(key: String) = Holder(T::class.java.getDeclaredConstructor().newInstance())\n\n    data class Holder<T>(val value: T)\n}\n"
        },
        {
            "code": "\nclass Foo(private val bar: String) {\n    private inline fun baz() = bar\n}\n"
        },
        {
            "code": "\nclass X {\n    private var foo = 0\n    \n    private fun y() {\n        x()\n    }\n    \n    private inline fun x() {\n        foo //     INVOKESTATIC kotlinx/io/X.access$getFoo$p (Lkotlinx/io/X;)I\n    }\n}\n"
        },
        {
            "code": "\nabstract class A01 : List<String>\nabstract class A02 : A01()\nabstract class A03 : A02()\nabstract class A04 : A03()\nabstract class A05 : A04()\nabstract class A06 : A05()\nabstract class A07 : A06()\nabstract class A08 : A07()\nabstract class A09 : A08()\nabstract class A10 : A09()\nabstract class A11 : A10()\nabstract class A12 : A11()\nabstract class A13 : A12()\nabstract class A14 : A13()\nabstract class A15 : A14()\n"
        },
        {
            "code": "\nclass Key<T>(val value: T)\n\nclass Project {\n    fun <T> get(k: Key<T>): T = k.value\n}\n\nfun test() {\n    val id = Key<Long>(1L)\n    Project().get(id).equals(1)\n}\n"
        },
        {
            "code": "\npackage test\n\nclass L\n\noperator fun L?.invoke() {\n    println(this)\n}\n\nclass X\n\nval X?.x: L?\n    get() {\n        println(\"get\")\n        return if (this == null) null else L()\n    }\n\nfun test1(nx: X?) = nx?.x()\n\nfun main() {\n    test1(X())\n}\n"
        },
        {
            "code": "\ninline class Foo(val value: Int)\n\ninterface Parent<T> {\n    val member: T\n}\n\nclass Sub(override val member: Foo) : Parent<Foo>\n\nfun main() {\n    val b = Sub(Foo(1))\n    println(b.member)\n}\n"
        },
        {
            "code": "\nclass Test {\n    lateinit var classWithFunction: ClassWithFunction\n\n    val standardLambda1: () -> Unit = { doSth1() }\n    val referencedLambda1: () -> Unit = ::doSth1\n\n    val standardLambda2: () -> Unit = { classWithFunction.doSth2() }\n    val referencedLambda2_1: () -> Unit = classWithFunction::doSth2 // an error occurred because holds reference to the classWithFunction\n    val referencedLambda2_2: () -> Unit = ::classWithFunction.get()::doSth2 // even this throws an error\n    \n    fun doSth1() {}\n\n    class ClassWithFunction {\n        fun doSth2() {}\n    }\n}\n"
        },
        {
            "code": "\npublic inline fun foo(f: () -> Pair<Int, Int>): Int {\n    val (i: Int, r: Int) = f.invoke()\n    return r\n}\n\nval int = foo { 42 to 239 }\n"
        },
        {
            "code": "\nclass Test {\n    companion object {\n\n        lateinit var INSTANCE: String\n\n        fun foo() {\n            INSTANCE\n        }\n    }\n}\n"
        },
        {
            "code": "\nclass Test {\n    companion object {\n\n        private lateinit var INSTANCE: String\n\n        fun foo() = INSTANCE\n    }\n}\n"
        },
        {
            "code": "\nsealed class State {\n    object System : State()\n    object Permission : State()\n    object Error : State()\n    companion object {\n        val stateOrder = listOfNotNull(\n            State.Permission,\n            State.System,\n            State.Error\n        )\n        val unit = println(\"Values $stateOrder\")\n    }\n}\nfun main() {\n    State.Permission\n}\n"
        },
        {
            "code": "\nimport java.io.Writer\n\nclass WriterWrapper(private val writer: Writer) {\n    fun write(s: String) {\n        writer.write(s)\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.*\n\ninterface Flow<T> {\n    suspend fun consumeEach(consumer: FlowConsumer<T>)\n}\n\ninterface FlowConsumer<T> {\n    suspend fun consume(value: T)\n}\n\n// This functions cross-inlines action into an implementation of FlowConsumer interface\nsuspend inline fun <T> Flow<T>.consumeEach(crossinline action: suspend (T) -> Unit) =\n    consumeEach(object : FlowConsumer<T> {\n        override suspend fun consume(value: T) = action(value)\n    })\n"
        },
        {
            "code": "\n@file:JvmMultifileClass\n@file:JvmName(\"Test\")\n\npackage com.example\n\nsealed class Foo\nobject Bar : Foo()\n\nfun main(args: Array<String>) {\n    println(Bar)\n}\n"
        },
        {
            "code": "\npublic fun String.toCharArray(): CharArray = CharArray(length) { this[it] }\n"
        },
        {
            "code": "\nfun test(x: Any, y: Double): Boolean {\n    if (x !is Double) return false\n    val tmp: Double = x\n    return tmp == y\n}\n"
        },
        {
            "code": "\nfun example1(x: Comparable<Double>, y: Double) =\n        x is Double && x < y\n"
        },
        {
            "code": "\nfun example1a(x: Comparable<Double>, y: Double): Boolean {\n    if (x !is Double) return false\n    val tmp: Double = x\n    return tmp < y\n}\n"
        },
        {
            "code": "\nfun example2(x: Any, y: Any) =\n        x is Int && y is Double && x < y // total order comparison\n\nfun example2a(x: Int, y: Double) =\n        x < y // widening conversion for 'x' + IEEE 754 comparison\n"
        },
        {
            "code": "\nfun example3(x: Any) =\n    when (x) {\n        !is Double -> \"!Double\"\n        0.0 -> \"0.0\" // (*)\n        else -> \"other\"\n    }\n\nfun example3a(x: Any) =\n    if (x !is Double) \"!Double\"\n    else if (x == 0.0) \"0.0\"\n    else \"other\"\n\n// example3(-0.0) == \"other\"\n// example3a(-0.0) == \"0.0\"\n"
        },
        {
            "code": "\n// FILE: a.kt\n\npublic inline fun assertFailsWith() {\n    launchIn2 {\n        catch2<Any>(10) {\n        }\n    }\n}\n\nfun foo() {\n    assertFailsWith()\n}\n\npublic fun launchIn2(builder: () -> Unit) {  }\n\npublic inline fun <reified T> catch2(t: T, action: (T) -> Unit) {\n    T::class\n}\n\n\n// FILE: box.kt\n\nfun box() : String {\n    assertFailsWith()\n    return \"OK\"\n}\n"
        },
        {
            "code": "\ninline class Test(val x: Int){\n\tprivate companion object{\n\t\tprivate const val CONSTANT = 0\n\t}\n\t\n\tfun crash(){\n\t\tgetInlineConstant()\n\t}\n\t\n\tprivate inline fun getInlineConstant(): Int{\n\t\treturn CONSTANT\n\t}\n}\n"
        },
        {
            "code": "\ninline class Direction(private val direction: Int) {\n    fun dx() = dx[direction]\n    fun dy() = dy[direction]\n\n    companion object {\n        private val dx = intArrayOf(0, 1, 0, -1)\n        private val dy = intArrayOf(-1, 0, 1, 0)\n    }\n}\n\nfun main(args: Array<String>) {\n    Direction(42).dx()\n}\n"
        },
        {
            "code": "\nenum class SimpleEnum {\n    A(1),\n    B(2),\n    C;\n\n    val myValue:Int\n\n    constructor(value:Int) {\n        myValue = value\n    }\n\n    constructor():this(0)\n\n}\n\n\nfun main() {\n    for(e in SimpleEnum.values()) {\n        println(\"Enum constant ${e.name}\") // \"Enum constant undefined\"\n    }\n}\n"
        },
        {
            "code": "\nenum class Test(vararg xs: Int) {\n    OK {\n        fun foo() {}\n    };\n    val xs = xs\n}\n\nfun box(): String =\n        if (Test.OK.xs.size == 0) \"OK\" else \"Fail\"\n"
        },
        {
            "code": "\ninline fun inlineMe(crossinline y: () -> Unit) =\n        object {\n            inline fun run() { y() }\n        }.run()\n\nfun main() {\n    inlineMe { println(1) }\n}\n"
        },
        {
            "code": "\ndata class A(val x: String, val y: String)\n\nsuspend fun foo(a: A, block: suspend (Int, A, String) -> String): String = block(1, a, \"#\")\n\nsuspend fun test() = foo(A(\"O\", \"K\")) { i_param, (x_param, y_param), v_param ->\n    i_param.toString() + x_param + y_param + v_param\n}\n"
        },
        {
            "code": "\nenum class A {\n  A, B\n}\n\nenum class B {\n  A, B\n}\n\nfun main(args: Array<String>) {\n  val a = A.A\n\n  when (a) {\n    A.A -> println(\"A.A\") // should hit this\n    A.B -> println(\"A.B\")\n    B.A -> println(\"B.A\") // but hitting this branch\n    B.B -> println(\"B.B\")\n  }\n}\n"
        },
        {
            "code": "\nclass Test {\n    fun f(t: Thread.State) {}\n}\n"
        },
        {
            "code": "\nenum class Numbers {\n    ONE,\n    TWO,\n    THREE\n}\n\nfun testNumbersWhen(n: Numbers): Int {\n    return when(n) {\n        Numbers.ONE -> 1\n        Numbers.TWO -> 2\n        Numbers.THREE -> 3\n    }\n}\n"
        },
        {
            "code": "\nval unsigned = 0x8fffffffU\nval good = \"123 \" + unsigned\nval bad = \"123 \" + 0x8fffffffU\n\nfun main() {\n    println(good) //123 2415919103\n    println(bad) //123 -1879048193\n}\n"
        },
        {
            "code": "\nimport kotlin.contracts.ExperimentalContracts\nimport kotlin.contracts.InvocationKind\nimport kotlin.contracts.contract\n\n@ExperimentalContracts\nfun example(block: () -> Unit) {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    block()\n}\n\n// ERROR: Kotlin: [Internal Error] java.lang.IllegalStateException (see stacktrace.txt)\n@ExperimentalContracts\nclass Example(bool: Boolean) {\n    init {\n        example {\n            if (bool) {\n\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\n// No error\nclass Example(bool: Boolean) {\n    init {\n        run {\n            if (bool) {\n\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\ninterface ParentClass<S> {\n    fun ping(message: S)\n}\n"
        },
        {
            "code": "\nfun <T> Result<T>.forEach(consumer: (T) -> Unit) {\n    if (this.isSuccess) {\n        consumer(getOrNull()!!)\n    }\n}\n"
        },
        {
            "code": "\nopen class Foo(val args: String){\n    constructor(arg: Any = 1) : this(arg.toString()) {\n    }\n}\n\nopen class Base(val baseArgs: String)\nopen class Bar(arg: Any = 1) : Base(arg.toString()) {\n    val args = arg.toString()\n}\n\nobject TF : Foo() {}\nobject TF2 : Foo(2) {}\n\nfun main() {\n    val f = object : Foo() {}\n    val f2 = object : Foo(2) {}\n    val b = object : Bar() {}\n    println(\"f.args: \" + f.args)\n    println(\"f2.args: \" + f2.args)\n    println(\"TF.args: \" + TF.args)\n    println(\"TF2.args: \" + TF2.args)\n    println(\"b.args: \" + b.args)\n    println(\"b.baseArgs: \" + b.baseArgs)\n}\n"
        },
        {
            "code": "\ninline class Foo(val x: UIntArray)\n\nfun main() {\n    Foo(UIntArray(5))\n}\n"
        },
        {
            "code": "\npackage flow\n\ninterface FlowCollector<T> {\n    suspend fun emit(value: T)\n}\n\ninterface Flow<T : Any> {\n    suspend fun collect(collector: FlowCollector<T>)\n}\n\npublic inline fun <T : Any> flow(crossinline block: suspend FlowCollector<T>.() -> Unit) = object : Flow<T> {\n    override suspend fun collect(collector: FlowCollector<T>) = collector.block()\n}\n\nsuspend inline fun <T : Any> Flow<T>.collect(crossinline action: suspend (T) -> Unit): Unit =\n    collect(object : FlowCollector<T> {\n        override suspend fun emit(value: T) = action(value)\n    })\n\ninline fun <T : Any, R : Any> Flow<T>.flowWith(crossinline builder: Flow<T>.() -> Flow<R>): Flow<T> =\n    flow {\n        builder(this@flowWith)\n    }\n\nsuspend fun main() {\n    val f = flow<Int> {\n        emit(1)\n    }.flowWith {\n        this\n    }.collect {\n    }\n}\n"
        },
        {
            "code": "\ninline class InlineClass(val string: String)\nclass Foo<T>(inlineString: InlineClass, generic: T)\n"
        },
        {
            "code": "\nsealed class Animal {\n    object Dog : Animal()\n    object Cat : Animal()\n\n    companion object {\n        val all =  setOf(Dog, Cat) \n    }\n}\n\nsealed class Fruit {\n    object Apple : Fruit()\n    object Mango : Fruit()\n\n    companion object {\n        val all get() = setOf(Apple, Mango) \n    }\n}\n\nfun main() {\n    println(Animal.Dog)\n    println(Animal.all)\n\n    println(Fruit.Apple)\n    println(Fruit.all)\n}\n"
        },
        {
            "code": "\n   fun main(args: Array<String>) {\n       var ary = Array(5, {x -> x + 2})\n       println(ary[2])\n   }\n   "
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    navigate(Routes::index)\n}\n\nobject Routes {\n    suspend fun index() {}\n}\n\nfun navigate(route: suspend () -> Unit) {}\n"
        },
        {
            "code": "\ninline class Demo(val a: Int)\n\nfun main() {\n\tval a = Demo(10)\n    println(a.a)\n}\n"
        },
        {
            "code": "\ntypealias StringSupplier = () -> String\n\ntypealias WhateverStringFunction = (Any?) -> String\n\nfun main(args: Array<String>) {\n    whatIs(object : StringSupplier, WhateverStringFunction {\n        override fun invoke() = TODO()\n        override fun invoke(a: Any?): String = TODO()\n        override fun toString(): String = \"object : StringSupplier, WhateverStringFunction\"\n    })\n\n    whatIs(object : WhateverStringFunction, StringSupplier {\n        override fun invoke() = TODO()\n        override fun invoke(a: Any?): String = TODO()\n        override fun toString(): String = \"object : WhateverStringFunction, StringSupplier\"\n    })\n}\n\nfun whatIs(f: Any) {\n    try {\n        f as StringSupplier\n        println(\"$f is a StringSupplier\")\n    } catch (t: Throwable) {\n        println(\"$f is not a StringSupplier\")\n    }\n    try {\n        f as WhateverStringFunction\n        println(\"$f is a WhateverStringFunction\")\n    } catch (t: Throwable) {\n        println(\"$f is not a WhateverStringFunction\")\n    }\n}\n"
        },
        {
            "code": "\ninline class IC(val x: Int)\n\nfun f(z: IC) {\n    IC::class // KClass<out IC> \n    IC::class.simpleName // \"IC\"\n}\n"
        },
        {
            "code": "\nprivate interface Bag<T> {\n\toperator fun contains(element: T): Boolean\n}\n\nprivate interface IntBag : Bag<Int> {\n\toverride fun contains(element: Int): Boolean\n}\n\nprivate fun testIntBag(intBag: IntBag) = 1 in intBag\n"
        },
        {
            "code": "\nabstract class Foo {\n    internal abstract fun foo()\n}\n\nabstract class Bar : Foo() {\n    public abstract override fun foo() // <- escalate visibility\n}\n"
        },
        {
            "code": "\npackage test\n\nfun <T : Int> bar(x: T) {}\n"
        },
        {
            "code": "\nfun test(a: Int, b: Int, flag: Boolean) =\n    (if (flag) a..b else a downTo b).map { it + 1 }\n"
        },
        {
            "code": "\npackage sample\n\nfun main(args: Array<String>) {\n    val temp = SomeClass(5.toUInt())\n    println(temp.v)\n}\n\ninterface SomeIface<T> {\n    val v: T\n}\n\nclass SomeClass(override val v: UInt) : SomeIface<UInt>\n"
        },
        {
            "code": "\npackage test\n\nclass A\n\nvar stored: Any? = null\n\noperator fun A.get(vararg xs: Int): Int {\n    stored = xs\n    return 0\n}\n\noperator fun A.set(vararg xs: Int, v: Int) {\n    if (stored === xs) \n        println(\"Same\") \n    else \n        println(\"$stored !== $xs\")\n}\n\nfun main(args: Array<String>) {\n    A()[1, 2]++\n}\n"
        },
        {
            "code": "\nclass Ex1 {\n    operator fun get(i: Int) = 0\n    operator fun set(i: Int, v: Int) {}\n}\n"
        },
        {
            "code": "\nclass Ex2 {\n    operator fun get(vararg i: Int) = 0\n    operator fun set(i: Int, j: Int, v: Int) {}\n}\n"
        },
        {
            "code": "\nclass Ex3 {\n    operator fun get(vararg i: Int) = 0\n    operator fun set(vararg i: Int, v: Int) {}\n}\n"
        },
        {
            "code": "\nclass Ex4 {\n    operator fun get(vararg i: Any) = 0\n    operator fun set(vararg i: Int, v: Int) {}\n}\n"
        },
        {
            "code": "\noperator fun Int.get(i1: Int, vararg ii: Int) = 0\n\noperator fun Any.set(a1: Any, a2: Any, a3: Any = \"\", v: Int) {}\n"
        },
        {
            "code": "\npackage test\n\noperator fun <T> Array<out T>.set(i: Int, value: T) {\n    println(\"Array<out T>.set: i=$i, value=$value\")\n}\n\nfun test(a: Array<out String>) {\n    a[0] = \"abc\" // (*)\n}\n\nfun main(args: Array<String>) {\n    test(arrayOf(\"0\", \"1\", \"2\"))\n}\n"
        },
        {
            "code": "\nsuspend fun foo() {}\n\nsuspend fun bar(): Int {\n    foo()\n    return 42\n}\n"
        },
        {
            "code": "\npackage sample\n\nfun test() {\n}\n\nfun main(args: Array<String>) {\n    println(::test)\n}\n"
        },
        {
            "code": "\npackage sample\n\ninline class Foo(val v: Int)\n\nfun main(args: Array<String>) {\n    var a = Foo(5)\n    val b = a::v\n    println(\"A: ${a.v} - ${b.get()}\")\n}\n"
        },
        {
            "code": "\nsuspend fun foo(a: Int) {}\nsuspend fun bar(b: Int) {}\n\nsuspend fun baz(a: Int, b: Int): Int {\n    foo(a)\n    bar(b)\n    return 42 // not a tail suspend call to bar\n}\n"
        },
        {
            "code": "\nfun test(a: Any) = a.run { hashCode() }\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(\"abc\")\n}\n"
        },
        {
            "code": "\nopen class Range() {\n companion object {\n    @JvmField val EQUAL: Byte = 0\n    @JvmField val MODIFIED: Byte = 1\n    @JvmField val INSERTED: Byte = 2\n    @JvmField val DELETED: Byte = 3\n  }\n}\n"
        },
        {
            "code": "\nclass SColl(private val s: String) : Collection<String> {\n    override val size: Int\n        get() = 1\n\n    override fun contains(element: String): Boolean {\n        return element.length == s.length && element == s\n    }\n\n    override fun containsAll(elements: Collection<String>): Boolean {\n        return elements.all { it == s }\n    }\n\n    override fun isEmpty(): Boolean {\n        return false\n    }\n\n    override fun iterator(): Iterator<String> {\n        return listOf(s).iterator()\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.intrinsics.*\n\nfun check() = true\n\nsuspend fun f(i: Int): Unit {\n    return f_2()\n}\n\nprivate inline suspend fun f_2(): Unit {\n    if (check()) return\n\n    return suspendCoroutineUninterceptedOrReturn {\n        COROUTINE_SUSPENDED\n    }\n}\n"
        },
        {
            "code": "\nfun main() {\n    println(StrReader(\"a\").peek())\n}\n\ninline fun String.getOrElse(index: Int, default: () -> Char): Char = if (index >= 0 && index < this.length) this[index] else default()\n\nclass StrReader(val str: String, var pos: Int = 0) {\n        // NO BOXING\n\tfun peek2(): Char = if (pos >= 0 && pos < str.length) str[pos] else '\\u0000'\n\t\n\t// BOXING\n\tfun peek(): Char = str.getOrElse(pos) { '\\u0000' }\n}\n"
        },
        {
            "code": "\nfun test1(a: IntArray) {\n    for ((i, x) in a.withIndex()) {\n        println(x)\n    }\n}\n\nfun test2(a: UIntArray) {\n    for ((i, x) in a.withIndex()) {\n        println(x)\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\nclass Delegate(val value: String) {\n    operator fun getValue(thisRef: Any?, kProperty: Any?) = value\n}\n\nfun box(): String {\n    val x by Delegate(\"O\")\n\n    class Local(val y: String) {\n        val fn = { x + y }\n    }\n\n    return Local(\"K\").fn()\n}\n\nfun main(args: Array<String>) {\n    println(box())\n}\n"
        },
        {
            "code": "\nimport kotlin.properties.Delegates.notNull\n\nobject BugsBunny_Fails {\n    @JvmStatic fun main(args: Array<String>) {\n        var bunny by notNull<String>()\n\n        val obj = object {\n            val getBunny = {bunny}\n        }\n\n        bunny = \"Hi there\"\n        println(obj.getBunny())\n    }\n}\n\nobject BugsBunny_Works {\n    var bunny by notNull<String>()\n\n    @JvmStatic fun main(args: Array<String>) {\n        val obj = object {\n            val getBunny = {bunny}\n        }\n\n        bunny = \"Hi there\"\n        println(obj.getBunny())\n    }\n}\n"
        },
        {
            "code": "\nobject Foo2 {\n    operator fun Any?.get(key: String) = 42 as Any\n}\n\nobject Main {\n    val Int.id: Int? get() = 42\n\n    fun bar() = with(Foo2) {\n\n        val x = object {\n            val y = 38[\"Hello!\"]\n            val z = 45.id\n        }\n        println(x)\n    }\n}\n\nfun main(args: Array<String>) {\n    Main.bar()\n}\n"
        },
        {
            "code": "\nconst val s1 = \"1234567890\"\nconst val s2 = s1 + s1 + s1 + s1 + s1 + s1 + s1 + s1 + s1 + s1;\nconst val s3 = s2 + s2 + s2 + s2 + s2 + s2 + s2 + s2 + s2 + s2;\nconst val s4 = s3 + s3 + s3 + s3 + s3 + s3 + s3 + s3 + s3 + s3;\n\nfun main(args: Array<String>) {\n    println(s4.length)\n}\n"
        },
        {
            "code": "\nobject Foo {\n    operator fun Int.get(key: String) = 42\n}\n\nfun bar() = with(Foo) {\n    val x = object {\n        val y = 38[\"Hello!\"]\n    }\n}\n\nfun main(args: Array<String>) {\n    bar()\n}\n"
        },
        {
            "code": "\nenum class Button(val caution: CautionLevel) {\n    POWER(CautionLevel.LOW),\n    RESET(CautionLevel.LOW),\n    VOLTAGE(CautionLevel.HIGH)\n}\n\nenum class CautionLevel(val buttons: List<Button>) {\n    HIGH(listOf(Button.VOLTAGE)),\n    LOW(listOf(Button.POWER, Button.RESET))\n}\n\nfun main(args: Array<String>) {\n   println(\"\\nButtons w/ their caution level:\")\n   Button.values().asSequence()\n     .forEach { \n       println(\"\\tButton: $it Caution: ${it.caution}\") \n     }\n   println(\"\\nCaution Levels w/ associated buttons:\")\n   CautionLevel.values().asSequence()\n     .forEach { \n       println(\"\\tCaution Level: $it Associated Buttons: ${it.buttons}\") \n     }\n}\n"
        },
        {
            "code": "\nfun main() {\n   `doAThing) outer inner`()\n   `doAThing) only`()\n}\n\nclass Thing {\n    private val myThing = 1\n\n    fun thing() = myThing\n}\n\ntypealias MyRunable = () -> Unit\n\nfun doAThing(name: String, myRunable: MyRunable) {\n    println(\"running $name\")\n    myRunable()\n}\n\nfun `doAThing) outer inner`() {\n    val thing = Thing()\n\n    doAThing(\"outer\") { doAThing(\"inner\") { thing.thing() } }\n}\n\nfun `doAThing) only`() {\n    val thing = Thing()\n\n    doAThing(\"only\") { thing.thing() }\n}\n"
        },
        {
            "code": "\ninterface A {\n    private fun foo() {\n      \tprintln(\"Hi!\")  \n    }\n    \n    public fun bar() {\n        foo()\n    }\n}\n\nclass B : A {\n    \n    private fun foo() {\n      \tprintln(\"Hiiiii!\")  \n    }\n    \n}\n\nfun main(args: Array<String>) {\n    val b = B()\n    \n    b.bar()\n}\n"
        },
        {
            "code": "\n// -- kotlinApp.kt\npackage com.demo\n\nclass TestClass() { \n\n  fun concatStrings(left: String, right: String): String {\n    return left + right\n  }\n}\n"
        },
        {
            "code": "\nclass MethodWithParens {\n    fun `(bla)`() {\n        something {\n            something {\n                something {}\n            }\n        }\n    }\n\n    private fun something(function: () -> Any) {\n        function()\n    }\n\n}\n\nfun main() {\n    MethodWithParens().`(bla)`()\n}\n"
        },
        {
            "code": "\ninterface AsyncCloseable {\n\tsuspend fun close()\n}\n\ninline suspend fun <T : AsyncCloseable, R> T.use(callback: T.() -> R): R { // FAILS\n//suspend fun <T : AsyncCloseable, R> T.use(callback: T.() -> R): R { // WORKS\n\ttry {\n\t\treturn callback()\n\t} finally {\n\t\tclose()\n\t}\n}\n\nclass Demo : AsyncCloseable {\n    override suspend fun close() {\n    }\n}\n\nsuspend fun main() {\n    println(Demo().use { 10 })\n}\n"
        },
        {
            "code": "\n// WITH_RUNTIME\n\nfun testUInt(x: UInt) =\n    when (x) {\n        0u -> \"none\"\n        1u -> \"one\"\n        2u -> \"two\"\n        3u -> \"three\"\n        else -> \"many\"\n    }\n\nfun box(): String {\n    val t = testUInt(2u)\n    if (t != \"two\") throw AssertionError(\"$t\")\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "\nfun main() {\n}\n\nclass Test {\n\n    data class C(val a: String)\n\n    class A {\n        fun a(\n            f: (C) -> Int\n        ) {\n\n        }\n    }\n\n    class B {\n        fun b(c: C): Int {\n            return 10\n        }\n    }\n\n    fun f(f: () -> Unit) {\n\n    }\n\n    fun `Method with parentheses ()`() {\n\n        val b = B()\n\n        val a = A()\n\n        f { a.a({ b.b(it) }) }\n\n    }\n\n}\n"
        },
        {
            "code": "\npackage sample\n\nfun test() {\n}\n\nfun main(args: Array<String>) {\n    println(::test)\n}\n"
        },
        {
            "code": "\ninterface A {\n    fun baz() {\n        println(A.hashCode())\n    }\n    private companion object\n}\n\nclass C : A\n\nfun main(args: Array<String>) {\n    C().baz()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val value = Double.NaN\n    println(\"NaN == NaN: ${value == Double.NaN}\")\n    println(\"NaN.equals(NaN): ${value.equals(Double.NaN)}\")\n    println()\n    when (value) {\n        Double.NaN -> println(\"When NaN is NaN?\")\n        else -> println(\"When NaN not NaN?\")\n    }\n}\n"
        },
        {
            "code": "\nclass B\n\nclass A {\n    operator fun get(x: Int, y: B = B()) = x to y\n}\n\nfun main(args: Array<String>) {\n    println(A()[0])\n}\n"
        },
        {
            "code": "\ninterface A {\n    fun foo(x: Int)\n}\nopen class C {\n    open fun foo(x: Int) {\n        println(\"C\")\n    }\n}\n\nclass B : C(),A {\n    @JvmOverloads\n    fun foo(x: Int, y: Int = 42) {\n        println(\"B\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val a : A = B()\n    (B() as A).foo(1)\n    (B() as C).foo(1)\n}\n"
        },
        {
            "code": "\npackage foo\n\nfun main(args: Array<String>) {\n    val xs = listOf(1, 2, 3).flatMap { x ->\n        listOf(3, 4, 5).map { y ->\n            object {\n                val value = x + y\n            }\n        }\n    }\n\n    xs.forEach {\n        println(\"value: \" + it.value)\n    }\n}\n"
        },
        {
            "code": "\nfun isZero(n: UInt?): Boolean = n == 0u\n"
        },
        {
            "code": "\n@ExperimentalUnsignedTypes\nfun main(args: Array<String>) {\n    // Only happens for nullable types, same happens for other unsigned types\n    val nullableShort: UShort? = 1.toUShort()\n    if(nullableShort == UShort.MAX_VALUE) println(\"This won't compile\")\n}\n"
        },
        {
            "code": "\ninterface Digraph<T> { val node: Int }\ninterface AcyclicDigraph<T> : Digraph<T> { }\nfun <T> Digraph<T>.assertAcyclic(): AcyclicDigraph<T> = AcyclicDigraphImpl(this)\nclass AcyclicDigraphImpl<T>(val graph: Digraph<T>) : AcyclicDigraph<T>, Digraph<T> by graph {\n\tinit {\n\t\t// @TODO: check this is acyclic!\n\t}\n}\n"
        },
        {
            "code": "\nopen class MapModel2 : HashMap<String, String> () {\n    companion object{}\n}\nclass abc : MapModel2() {\n}\nfun main(arg: Array<String>) {\n    var a = abc();\n    a[\"aName\"] = \"OK\";\n    println(a[\"Name\"]);\n}\n\n"
        },
        {
            "code": "\nclass A {\n    private val x = object {}\n}\n"
        },
        {
            "code": "\nopen class A() {\n  open fun compareTo(o: Any): Int = 0\n}\nclass B() : A(), Comparable<B> {\n  override fun compareTo(o: B): Int = 0\n}\n\nfun main(args: Array<String>) {\n  println(B().compareTo(Object()))\n}\n"
        },
        {
            "code": "\nclass CompilerBug {\n    internal var `var` = 0\n\n    inner class Inner @JvmOverloads constructor(r: Runnable = Runnable { `var` = 1 })\n\n    companion object {\n\n        @JvmStatic fun main(args: Array<String>) {\n            CompilerBug().Inner()\n        }\n    }\n}\n"
        },
        {
            "code": "\nabstract class Base(number: Int)\n\nclass One : Base(ONE) {\n  companion object {\n    const val ONE = 1\n  }\n}\n\nclass Two : Base(TWO) {\n  companion object {\n    private const val TWO = 2\n  }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    var test = \"Hello\"\n    run {\n        test = \"world\"\n    }\n    println(test)\n}\n"
        },
        {
            "code": "\nfun Collection<Int>.sum(): Int {\n  var r = 0\n  forEach { r += it }\n  return r\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    var i = 0\n    run {\n        println(i)\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\nimport test.CallableRefExample4.foo\nimport kotlin.reflect.KFunction\n\nabstract class Base(val z: KFunction<Unit>)\n\nobject CallableRefExample4 : Base(::foo) {\n    fun foo() { println(this) }\n}\n\nfun main() {\n    CallableRefExample4.z.call()\n}\n"
        },
        {
            "code": "\nfun test(a: UInt) =\n        when (a) {\n            0u -> \"zero\"\n            1u -> \"one\"\n            2u -> \"two\"\n            3u -> \"three\"\n            else -> \"other\"\n        }\n"
        },
        {
            "code": "\nopen class Base {\n    init { f() }\n    open fun f() { }\n}\n\nclass DerivedNull : Base() {\n    var s: String? = null\n    override fun f() { s = \"set in f()\" }\n}\n\nclass DerivedNotNull : Base() {\n    var s: String? = \"set in ctor\"\n    override fun f() { s = \"set in f()\" }\n}\n\nfun main(args: Array<String>) {\n    println(DerivedNull().s)\n    println(DerivedNotNull().s)\n}\n"
        },
        {
            "code": "\nclass A {\n    fun fooLongSyntheticAccessor(capt: Int): String {\n        val o = run {\n            object {\n                fun run(captured: String): String {\n                    return {\n                        callPrivate(capt, captured)\n                    }()\n                }\n\n                private fun callPrivate(x: Int, y: String?): String = \"O\" + x + y\n            }\n        }\n        return o.run(\"K\")\n    }\n}\n\nfun main() {\n    println(A().fooLongSyntheticAccessor(5))\n}\n"
        },
        {
            "code": "\nfun testSigned(a: Long, b: Long) = (a..b).forEach { println(it) }\n\nfun testUnsigned(a: ULong, b: ULong) = (a..b).forEach { println(it) }\n"
        },
        {
            "code": "\ninline fun f(mapper: (Int) -> Number = { it }) {}\n\nfun main(args: Array<String>) = f()\n"
        },
        {
            "code": "\nfun <T> identity(value: T): T = value\n\ninline fun g(mapper: (Int) -> Number = ::identity) {}\n\nfun main(args: Array<String>) = g()\n"
        },
        {
            "code": "\nimport java.util.*\n\n@ExperimentalUnsignedTypes\nfun test(sortedMap: SortedMap<UInt, String>) {\n\n    val key = sortedMap.firstKey()\n}\n\n"
        },
        {
            "code": "\nimport java.util.*\n\n@ExperimentalUnsignedTypes\nfun test(sortedMap: SortedMap<UInt, String>) {\n\n    val key: UInt = sortedMap.firstKey() //val key: UInt? = sortedMap.firstKey() also compiles successfully\n}\n"
        },
        {
            "code": "\nimport java.util.*\n\n@ExperimentalUnsignedTypes\nfun test(sortedMap: SortedMap<UInt, String>) {\n\n    val (key, value) = sortedMap.entries.first()\n}\n"
        },
        {
            "code": "\nimport java.util.*\n\n@ExperimentalUnsignedTypes\nfun test(sortedMap: SortedMap<UInt, String>) {\n\n    val (key: UInt, value) = sortedMap.entries.first()\n}\n"
        },
        {
            "code": "\nfun test1(): String {\n    Array<Int>(1) {\n        return \"OK1;\"\n    }\n    \n    return \"fail1;\"\n}\n\nfun test2(): String {\n    IntArray(1) {\n        return \"OK2;\"\n    }\n    \n    return \"fail2;\"\n}\n\nfun main(args: Array<String>) {\n    println(test1() + test2())\n}\n"
        },
        {
            "code": "\nfun x(f: (Int) -> String) {\n\n}\n\nfun usage() {\n    x(Int::toString)\n}\n\nfun usage2() {\n    x(Int::toString)\n}\n"
        },
        {
            "code": "\nclass A {\n    private companion object {\n        const val B = 1\n    }\n}\n"
        },
        {
            "code": "\nclass Foo {\n    private fun foo() {}\n\n    private inline fun inlined() {\n        foo()\n    }\n}\n"
        },
        {
            "code": "\nsuspend fun doWork() {}\n\nsuspend fun callDoWork() {\n    doWork() // no tail call optimisation\n}\n\nsuspend fun callDoWorkReturn() {\n    return doWork() // optimised, no continuation or state machine\n}\n"
        },
        {
            "code": "\nobject A {\n    fun b(c: List<Int>) {\n        c.map(::d).sum()\n    }\n\n    fun d(e: Int) = e + 1\n}\n"
        },
        {
            "code": "\nclass C {\n\n  fun task() {\n    listOf(1, 2, 3)\n        .map(::intToString)\n  }\n\n  fun intToString(value: Int) = value.toString()\n}\n"
        },
        {
            "code": "\nobject Foo {\n    fun `function with spaces`(): String {\n        data class Bar (val s: String)\n        return Bar(\"xyz\").toString()\n    }\n}\n\nfun main(args: Array<String>) {\n    println(Foo.`function with spaces`())\n}\n"
        },
        {
            "code": "\nclass `foo bar`() {\n    data class baz(val v: Int)\n}\n"
        },
        {
            "code": "\nfun `foo bar`() {\n    data class baz(val v: Int)\n}\n"
        },
        {
            "code": "\nclass C {\n    fun `foo bar`() {\n        data class baz(val v: Int)\n    }\n}\n"
        },
        {
            "code": "\nfun `a b`() { { object {} } }\n"
        },
        {
            "code": "\nfun <`E e e`> z() = 1\n"
        },
        {
            "code": "\nclass Test {\n    private lateinit var prop: Any\n\n    fun test() {\n        if (!::prop.isInitialized) {\n            synchronized(this) {\n                if (!::prop.isInitialized) {\n                    prop = Any()\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\nclass Test {\n    private lateinit var prop: Any\n\n    fun test() {\n        if (!::prop.isInitialized) {\n            synchronized(this) {\n//                if (!::prop.isInitialized) {\n                    prop = Any()\n//                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\nclass MyService(val name: String)\n\nclass MyServiceProvider() {\n    private lateinit var service: MyService\n    private val initLock: Any = Object()\n\n    public fun getOrCreateService(): MyService {\n        synchronized(initLock) {\n            if (!this::service.isInitialized) {\n                service = MyService(\"foo\")\n            }\n            return service\n        }\n    }\n}\n\n\nfun main(args: Array<String>) {\n    println(MyServiceProvider().getOrCreateService().name)\n}\n"
        },
        {
            "code": "\nclass A {\n    fun foo(a: a) {\n        println(a)\n    }\n}\n\nobject a {}\n\nfun main(args: Array<String>) {\n    A().foo(a)\n}\n"
        },
        {
            "code": "\ndata class Foo(val bar: String)\n"
        },
        {
            "code": "\n@ExperimentalUnsignedTypes\nfun main(args: Array<String>) {\n    var a: UByte = 0u\n    --a\n    println(a)  // 255\n}\n"
        },
        {
            "code": "\n@ExperimentalUnsignedTypes\nfun main(args: Array<String>) {\n    var a: UByte = 0u\n    println(--a) // -1\n}\n"
        },
        {
            "code": "\n@ExperimentalUnsignedTypes\nfun main(args: Array<String>) {\n    val a: UByte = 0u\n    val b: UByte = 1u\n    println(a - b) // 4294967295\n}\n"
        },
        {
            "code": "\npackage test\n\nval x = 42\n\nfun main(args: Array<String>) {\n    when (x) {\n        42 -> {\n            println(\"42\")\n            if (x < 0) { // (*) breakpoint\n                println(\"Hmm?\") // (**)\n            }\n        }\n        1 -> println(\"1\")\n        else -> println(\"No\")\n    }\n}\n"
        },
        {
            "code": "\ninterface A {\n\n    fun baz() {\n        println(A.hashCode())\n    }\n    private companion object\n}\n\nclass C : A\n\nfun main(args: Array<String>) {\n    C().baz()\n}\n"
        },
        {
            "code": "\nabstract class C {\n    protected abstract fun ready(): Boolean\n    protected abstract suspend fun slow(): Boolean\n\n    suspend fun optimized(): Boolean {\n        if(ready()){\n            return true\n        }\n        else {\n            return slow()\n        }\n    }\n\n    suspend fun notOptimized(): Boolean {\n        return if(ready()){\n            true\n        }\n        else {\n            slow()\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun main() {\n    val myMap = MyMutableMap<String, Int> { 0 }\n    myMap[\"1\"] = 1  // works\n    myMap[\"2\"]++    // throws exception\n}\n\nclass MyMutableMap<K, V>(\n    private val map: MutableMap<K, V> = mutableMapOf(),\n    private val defaultValueSelector: (K) -> V\n) : MutableMap<K, V> by map {\n\n    override operator fun get(key: K): V =\n        map[key] ?: defaultValueSelector(key).also { map[key] = it }\n}\n"
        },
        {
            "code": "\nabstract class A {\n    abstract fun foo(x: Int = 1, y: Int): Int\n}\n\ninterface B {\n    fun foo(x: Int, y: Int = 2): Int\n}\n\nclass C : A(), B {\n    override fun foo(x: Int, y: Int) = x + y\n}\n\nfun main(args: Array<String>) {\n    println(C().foo())\n}\n"
        },
        {
            "code": "\ninline fun <T, R> fixInlineBug1(crossinline f: (T) -> R): (T) -> R = { f(it) }\ninline fun <R>    fixInlineBug0(crossinline f: () -> R): () -> R = { f() }\n"
        },
        {
            "code": "\nfun printLineNumber() {\n    Throwable().printStackTrace()\n}\n\nfun normalFunction() {\n\n}\n\ninline fun inlineFunction() {\n\n}\n\nfun test1() {\n    inlineFunction()\n    printLineNumber()\n}\n\nfun test2() {\n    normalFunction()\n    printLineNumber()\n}\n\nfun test3() {\n    println()\n    printLineNumber()\n}\n\nfun main(vararg args: String) {\n    test1()\n    test2()\n    test3()\n}\n"
        },
        {
            "code": "\npackage test\n\nfun main(args: Array<String>) {\n    (arrayOf(1, 2, 3)::get)(1)\n}\n"
        },
        {
            "code": "\npackage utils\n\nimport kotlin.reflect.KCallable\n\nabstract class Day(inputs: Day.() -> Unit) {\n    val inputs = mutableListOf<Pair<String?, String>>()\n\n    init {\n        inputs()\n    }\n\n    operator fun String.unaryPlus() = +(null to this)\n    operator fun Pair<String?, String>.unaryPlus() = inputs.add(this)\n\n    fun res(name: String) = name to readResource(name)\n\n    operator fun invoke() {\n        inputs.forEach {\n            println(solve(it.second, true))\n            println(solve(it.second, false))\n        }\n    }\n\n    open fun String.split(): List<String> = splitLines()\n\n    open fun solve(input: String, part1: Boolean) = solve(input.split(), part1)\n    open fun solve(input: List<String>, part1: Boolean): Any? = \"\"\n}\n\n\nprivate class Foo\n\nfun readResource(name: String) = Foo::class.java\n        .getResourceAsStream(\"/\" + name)\n        .bufferedReader()\n        .use { it.readText() }\n\nfun String.splitLines() = split(\"\\\\r?\\\\n\".toRegex())\n"
        },
        {
            "code": "\n@JvmName(\"fooA\")\nprivate fun String?.foo(t: String?): String? = \"\"\nprivate fun String?.foo(t: String): String = \"\"\nfun use() {\n    compareBy<String> {\n        \"\".foo(\"\")\n        \"\".foo(null)\n    }\n}\n"
        },
        {
            "code": "\ninline fun foo(): (Int) -> Int = { it + 1}\n\ninline fun bar(): (Int) -> Int = { it * 2}\n\ninline fun compose(crossinline f: (Int) -> Int,\n                   crossinline g: (Int) -> Int): (Int) -> Int {\n    return { f(g(it)) }\n}\n\nfun test(f: (Int) -> Int) = f(42)\n\nfun go() {\n    test(compose(foo(), bar()))  // :(\n}\n"
        },
        {
            "code": "\npackage foo\n\nimport kotlin.reflect.full.primaryConstructor\n\nclass A(val x: Int, val y: Int)\n\ninline fun <reified T : Any> f() {\n    for (p in T::class.primaryConstructor!!.parameters.sortedBy { it.index }) {\n        println(p)\n    }\n}\n"
        },
        {
            "code": "\nclass A {\n    companion object {\n        // not required, just to make this runnable\n        @JvmStatic\n        fun main(args: Array<String>) {\n        }\n    }\n\n    var field = 0\n\n    inline fun a(f: () -> Any): Any {\n        try {\n            val value = f()\n            return value\n        } finally {\n            field--\n        }\n    }\n\n    private inline fun b(rule: () -> Unit) {\n        try {\n            rule()\n        } catch (fail: Throwable) {}\n    }\n\n    fun c(vararg functions: () -> Any): Any = a {\n        for (function in functions) {\n            b { return function() }\n        }\n        throw Throwable()\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    A().foo {}\n}\n\nclass A {\n    val foo = fun(call: () -> Unit) =\n            ext {\n                fun send() {\n                    call()\n                }\n\n                bar {\n                    send()\n                }\n            }\n\n    fun bar(body: () -> Unit) {\n\n    }\n\n    inline fun A.ext(init: X.() -> Unit) {\n        return X().init()\n    }\n\n    class X\n}\n"
        },
        {
            "code": "\nclass Test {\n    fun test() {\n        try {\n            apply {\n                try {\n                    return test()\n                } catch (e: Exception) {\n\n                } catch (e: Throwable) {\n\n                }\n            }\n        } finally {\n            \n        }\n    }\n}\n"
        },
        {
            "code": "\nclass StateMap private constructor(private val names: Array<String>) {\n  companion object {\n    val EMPTY = StateMap(emptyArray())\n  }\n}\n"
        },
        {
            "code": "\ninline fun f(\n    wait: Int = 0,\n    action: (Int) -> Unit\n): Boolean {\n    var millis: Long = 1\n    try {\n    } catch (e: Throwable) {\n        millis = millis\n    }\n    return false\n}\n\nfun main(args: Array<String>) {\n    var x = 0\n    f {\n        x++\n    }\n}\n"
        },
        {
            "code": "\ninterface A {\n    companion object {\n        const val x = 1\n    }\n}\n"
        },
        {
            "code": "\n\nimport java.lang.ref.WeakReference\nimport java.util.*\n\nclass LabelHolder {\n\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            // just run it, and you'll get VerifyError\n        }\n    }\n\n    private val labels = IdentityHashMap<String?, WeakReference<String>>()\n    private val String?.label: String\n        get(): String = labels.getOrPutWeak(this) { \"hello\" }\n}\n\n// removing 'inline' removes this error\ninline fun <K, V> MutableMap<K, WeakReference<V>>.getOrPutWeak(key: K, defaultValue: ()->V): V {\n    val value = get(key)?.get()\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, WeakReference(answer))\n        answer\n    } else {\n        value // adding 'as V' removes this error\n    }\n}\n"
        },
        {
            "code": "\ninline fun test() {\n    val key = object {}.javaClass\n    println(key)\n  }\n"
        },
        {
            "code": "\nclass B<T> {\n    inline fun bar(value: T) {}\n}\n\nclass A {\n    inline fun <T> foo(block: B<T>.() -> Unit) {}\n}\n\nfun main() {\n  val a = A()\n  val str = \"xyz\"\n  a.foo<String>( { bar(str) } )\n}\n"
        },
        {
            "code": "\nclass C {\n    var inserting: Boolean = false\n    fun nextSlot(): Any? = null\n    fun startNode(key: Any?) {}\n    fun endNode() {}\n    fun emitNode(node: Any?) {}\n    fun useNode(): Any? = null\n    fun skipValue() {}\n    fun updateValue(value: Any?) {}\n}\nclass B<T>(val composer: C, val node: T) {\n    inline fun <V> bar(value: V, block: T.(V) -> Unit) = with(composer) {\n        if (inserting || nextSlot() != value) {\n            updateValue(value)\n            node.block(value)\n        } else skipValue()\n    }\n}\nclass A(val composer: C) {\n    inline fun <T> foo(key: Any, ctor: () -> T, update: B<T>.() -> Unit) = with(composer) {\n        startNode(key)\n        val node = if (inserting)\n            ctor().also { emitNode(it) }\n        else useNode() as T\n        B<T>(this, node).update()\n        endNode()\n    }\n}\nfun main() {\n  val a = A(C())\n  val str = \"xyz\"\n  a.foo<String>(\n      123,\n      { \"abc\" },\n      { bar(str) { } }\n  )\n}\n"
        },
        {
            "code": "\nfun function() {\n    val r = \"\"\n    val a = run {\n        fun f(x: Long, y: String? = null) {\n            r\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun test() {\n    fun b() {}\n    b()\n}\n"
        },
        {
            "code": "\nsuspend fun test() {\n    test()\n    test()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val c = UInt::class.javaObjectType  // Similar exception with `.javaPrimitiveType!!`\n    val x = c.cast(123)\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.*\n\nfun main() {\n    suspend fun Rec.dfs() {}\n    Rec { dfs() }\n}\n\n@RestrictsSuspension\nclass Rec(block: suspend Rec.() -> Unit) {\n    init { block.startCoroutine(this, Continuation(EmptyCoroutineContext) {}) }\n}\n"
        },
        {
            "code": "\npackage foo\n\nimport kotlin.contracts.ExperimentalContracts\nimport kotlin.contracts.InvocationKind\nimport kotlin.contracts.contract\n\n@ExperimentalContracts\nfun foo() {\n    val a: String\n    println(\"aa\")\n    block {\n        a = \"a\"\n    }\n    println(a)\n}\n\n@ExperimentalContracts\nfun block(block: () -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n}\n"
        },
        {
            "code": "\ninline fun test(block: () -> Any = { 1 }) {\n    block()\n}\n    \nfun main() {\n    test()\n}\n"
        },
        {
            "code": "\ninline fun foo(value: Int, action: () -> Any = { \"\" }) {\n    action()\n}\n\nfun main() {\n    foo(1)\n}\n"
        },
        {
            "code": "\npackage sample\n\nimport java.util.concurrent.atomic.AtomicReference\n\nfun main(args: Array<String>) {\n    println(\"A: \" + UByte::class)\n    println(\"B: \" + 0.toUByte().javaClass)\n    println(\"C: \" + 0.toUByte()::class)\n    println(\"D: \" + AtomicReference(0.toUByte()).get()::class)\n    println(\"E: \" + AtomicReference(0.toUByte()).get().javaClass)\n}\n"
        },
        {
            "code": "\nclass Container(val item: Item = Item())\nclass Item(val i: Int = 3)\n\nclass Test {\n    var arrayOfContainers = arrayOf<Container>()\n\n    fun setupAndGet(): Container {\n        setup(1)\n        return arrayOfContainers[0]\n    }\n\n    inline fun setup(number: Int, getItem: ((Int) -> Item?) = { null }) {\n        if (number <= 0) return\n\n        arrayOfContainers = Array(number) {\n            val item = getItem(it)\n            if (item != null)\n                Container(item)\n            else\n                Container()\n        }\n    }\n}\n\n\nfun main(args: Array<String>) {\n    val t = Test()\n    t.setup(3) { Item(4) }\n    t.setupAndGet()\n}\n"
        },
        {
            "code": "\nenum class TarEnum {\n    VAL\n}\ninline fun <reified T : Enum<T>> String?.enumOrNull(): T? {\n    this ?: return null\n    return enumValues<T>().firstOrNull { it.name == this }\n}\n\ninline fun <reified T : Enum<T>> String?.enumOrThrow(handleNull: () -> Throwable = { IllegalArgumentException(\"Enum type ${T::class.java} not contain value=$this\") }): T {\n    return this.enumOrNull<T>() ?: throw handleNull()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    class LeakedType(val source: String)\n    class ClassWithCallback {\n        var someCallback: (() -> Unit)? = null\n\n        fun dumpCallbackFields() =\n            someCallback!!.javaClass.declaredFields\n                .map { it.get(someCallback!!) as LeakedType }\n                .forEach { println(\"From callback fields :: leakedType=${it.source}\") }\n    }\n\n    val classWithCallback = ClassWithCallback()\n\n    val outer = LeakedType(\"Used in callback\")\n    val leaked = LeakedType(\"Used in apply block but not callback\")\n\n    classWithCallback.apply {\n        someCallback = { println(\"In callback :: leakedType=${outer.source}\") }\n        println(\"In apply block using leak arg :: leakedType=${leaked.source}\")\n    }\n    classWithCallback.dumpCallbackFields()\n}\n"
        },
        {
            "code": "\nclass LeakedType(val source: String)\n\nclass SomeClass(private val fromOuterClass: LeakedType) {\n    val classWithCallback = ClassWithCallback()\n\n    fun addCallback() {\n        classWithCallback.apply {\n            someCallback = { println(\"In callback :: leakedType=${fromOuterClass.source}\") }\n        }\n    }\n\n    fun addCallback(leaked: LeakedType) {\n        classWithCallback.apply {\n            someCallback = { println(\"In callback :: leakedType=${fromOuterClass.source}\") }\n            println(\"In apply block using leak arg :: leakedType= ${leaked.source}\")\n        }\n    }\n}\n\nclass ClassWithCallback {\n    var someCallback: (() -> Unit)? = null\n\n    fun dumpCallbackFields() {\n        val someCallback = someCallback!!\n        someCallback::class.java.declaredFields.forEach {\n            println(\"field=$it\")\n            if (it.type == LeakedType::class.java) {\n                it.isAccessible = true\n                val topLevelType = it.get(someCallback) as LeakedType\n                println(\"From callback fields :: leakedType=${topLevelType.source}\")\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val fromCtor = LeakedType(\"Passed via ctor\")\n    val someClass = SomeClass(fromCtor)\n\n    someClass.addCallback()\n    someClass.classWithCallback.someCallback?.invoke()\n    someClass.classWithCallback.dumpCallbackFields()\n\n    println(\"\")\n\n    val passedToFunction = LeakedType(\"Passed as function arg\")\n    someClass.addCallback(passedToFunction)\n    someClass.classWithCallback.someCallback?.invoke()\n    someClass.classWithCallback.dumpCallbackFields()\n}\n"
        },
        {
            "code": "\n@file:Suppress(\"UNSUPPORTED_FEATURE\", \"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\nimport kotlin.internal.*\n\ninline class Result<T>(private val _value: Any?) {\n    companion object {\n        @InlineOnly inline fun <T> success(value: T): Result<T> = Result(value)\n    }\n}\n"
        },
        {
            "code": "\nfun foo(r: Result<String>) {}\n\nfun bar() = foo(Result.success(\"OK\"))\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n  val n = 1\n  repeat(1) {\n    class Foo {\n      fun bar() = n + 1\n    }\n    println(Foo::class.java.getDeclaredConstructor())\n  }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n  val n = 1\n  //  repeat(1) {\n  class Foo {\n    constructor() { println(\"in constructor\") }\n    fun bar() = n + 1\n  }\n  println(Foo::class.java.getDeclaredConstructor())\n//  }\n}\n"
        },
        {
            "code": "\npackage test.base\n\nopen class Base {\n    protected val protectedVariable = \"protected\"\n\n    protected inline fun protectedFunction(crossinline block: () -> Unit) {\n        Runnable { println(protectedVariable); block() }.run()\n    }\n}\n"
        },
        {
            "code": "\nclass Test {\n    val bla = listOf(\"bla\").sortedByDescending { it }\n}\nfun main(args: Array<String>) {\n    println(Class.forName(\"Test\\$\\$special\\$\\$inlined\\$sortedByDescending\\$1\").declaringClass)\n}\n"
        },
        {
            "code": "\nfun main() {\n    val devStatus: UInt? = 0x0u\n    \n    when(devStatus) {\n        (0x0u) -> {\n            println(\"0\")\n        }\n        (0x10u) -> {\n            println(\"1\")\n        }\n        (0x20u) -> {\n            println(\"2\")\n        }\n        else -> {\n            println(\"else\")\n        }\n    }\n}\n"
        },
        {
            "code": "\ninternal var foo: String = \"foo\"\n    private set\n"
        },
        {
            "code": "\nconst val VERIFY_ASSUMPTIONS = false //deploying to production\n\nfun generateValueInBounds(lowerBound: Int, upperBound: Int): Int {\n    assumeTrue(lowerBound <= upperBound)\n    return lowerBound //fake implementation for demo\n}\n\ninline fun assumeTrue(value: Boolean) {\n    if (VERIFY_ASSUMPTIONS) {\n        assert(value)\n    }\n}\n"
        },
        {
            "code": "\nfun String.printAllWrong() {\n  for (c in this) {\n    println(c)\n  }\n}\n"
        },
        {
            "code": "\noperator fun String.iterator(): IntIterator = object : IntIterator() {\n  private var index = 0\n\n  override fun nextInt() = codePointAt(index).also {\n    index += Character.charCount(it)\n  }\n\n  override fun hasNext(): Boolean = index < length\n}\n"
        },
        {
            "code": "\nfun String.printAll() {\n  for (c in iterator()) {\n    println(c)\n  }\n}\n"
        },
        {
            "code": "\nenum class Color(val rgb: Int) {\n        RED(0xFF0000),\n        GREEN(0x00FF00),\n        BLUE(0x0000FF)\n}\n"
        },
        {
            "code": "\ninterface KotlinInterface {\n    fun doSomething(a: String = \"TestA\", b: String = \"TestB\"): String {\n        return a + b;\n    }\n}\n"
        },
        {
            "code": "\n// !LANGUAGE: +PolymorphicSignature\n// TARGET_BACKEND: JVM\n// IGNORE_BACKEND: JVM_IR\n// FULL_JDK\n// SKIP_JDK6\n// WITH_RUNTIME\n\nimport java.lang.invoke.MethodHandles\nimport java.lang.invoke.MethodType\nimport java.lang.invoke.WrongMethodTypeException\n\nclass C {\n    fun string(x: String): Any? = x\n\n    fun varargAny(vararg y: Any?): Any? = y[0]\n}\n\nfun box(): String {\n    val cstr = MethodHandles.lookup().findVirtual(C::class.java, \"string\", MethodType.methodType(Any::class.java, String::class.java))\n\n    val refstr = cstr::invokeExact\n    try {\n        refstr.invoke(arrayOf(\"Hmm\"))\n        return \"Fail\"\n    } catch (e: WrongMethodTypeException) {\n        // OK\n    }\n\n    val cva = MethodHandles.lookup().findVirtual(C::class.java, \"varargAny\", MethodType.methodType(Array<Any>::class.java, Any::class.java))\n    val refva = cva::invokeExact\n\n    return refva.invoke(arrayOf(\"OK\")) as String\n}\n"
        },
        {
            "code": "\npackage test\n\nimport kotlin.reflect.full.declaredMembers\n\ninline fun <reified T> foo() =\n        object {\n            val aClass = T::class // make it specialize\n            fun <X> foo() {}\n        }\n\nprivate fun printTypeParameters(foo: Any) {\n    for (memberFunction in foo::class.declaredMembers) {\n        println(\"-- ${memberFunction.name}:\")\n        for (typeParameter in memberFunction.typeParameters) {\n            println(typeParameter.name)\n        }\n        println(\"----\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val foo = foo<Int>()\n    printTypeParameters(foo)\n}\n"
        },
        {
            "code": "\nfun main() {\n    var uint1 = 1u\n    var uint2 = 2u\n    var uint3 = 3u\n    val uintSet = mutableSetOf(uint1)\n    uintSet.add(uint2)\n    sequenceOf(1).forEach {\n        uintSet.add(uint3)\n        println(\"uintSet contains 1? ${uintSet.contains(1u)}\")\n        println(\"uintSet contains 2? ${uintSet.contains(2u)}\")\n        println(\"uintSet contains 3? ${uintSet.contains(3u)}\")\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\nclass M(size: Int) {\n    val m = IntArray(size) { 0 }\n}\n\ninline operator fun M.get(a: Any, b: Any, ifn: () -> Int) =\n        m[ifn()]\n\ninline operator fun <reified T> M.set(a: T, b: Any, ifn: () -> Int, v: Int) {\n    if (b !is T) throw AssertionError()\n    m[ifn()] = v\n}\n\nfun main() {\n    val m = M(4)\n    m[\"a\", \"b\", { 1 }] += 10\n    println(m.m[1])\n}\n"
        },
        {
            "code": "\ninterface A {\n    val foo: String\n}\n\nclass B : A {\n    override var foo: String = \"Fail\"\n        private set\n\n    fun setOK(other: B) {\n        other.foo = \"OK\"\n    }\n}\n\nfun box(): String {\n    val b = B()\n    b.setOK(b)\n    return b.foo\n}\n\nfun main(args: Array<String>) {\n    println(box())\n}\n"
        },
        {
            "code": "\nclass Test {\n    var string: String = \"\"\n        private set\n\n    fun update(i: Int) {\n        string = i.toString()\n    }\n}\n"
        },
        {
            "code": "\ninline class Ucn(private val i: UInt) {\n    fun toByteArray() = ByteArray(1) { i.toByte() }\n}\n"
        },
        {
            "code": "\nimport java.io.IOException\n\nclass Foo {\n    @get:Throws(IOException::class)\n    @set:Throws(IOException::class)\n    var x: Int = 1\n}\n"
        },
        {
            "code": "\npackage test\n\nfun main(args: Array<String>) {\n    val x = A()\n    println(x.a)\n}\n\nclass A {\n    companion object {\n        private val test = 5\n    }\n\n    val a: Int\n\n    init {\n        a = test // (*) breakpoint\n    }\n}\n"
        },
        {
            "code": "\n  inline val Int.nonZero: Boolean get() = this != 0\n  "
        },
        {
            "code": "\ninline class TestInlineClass(val value: String)\n\nclass TestClassNoInlineClass(\n    val testArg1: Int,\n    val testInlineClass: String\n)\n\nclass TestClassWithInlineClass(\n    val testArg1: Int,\n    val testInlineClass: TestInlineClass\n)\n\nfun main(args: Array<String>) {\n    // prints \"testArg1, testInlineClass\"\n    println(TestClassNoInlineClass::class.java.constructors[0].parameters.map { it.name }.joinToString())\n    // prints \"arg0, arg1, arg2\"\n    println(TestClassWithInlineClass::class.java.constructors[0].parameters.map { it.name }.joinToString())\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val str = \"abcd\"\n    for (c:Char? in str) {\n        println(c)\n    }\n}\n"
        },
        {
            "code": "\nfun main() {\n    val x = sequence {\n        yield(1)\n    }\n}\n"
        },
        {
            "code": "\nsuspend fun doSomething() = 1\n\nsuspend fun f() {\n    repeat(100) {\n        doSomething()\n    }\n}\n"
        },
        {
            "code": "\nsuspend fun foo(a: Int) {}\nsuspend fun bar(b: Int) {}\nsuspend fun baz(c: Int) {}\n\nsuspend fun quix(a: Int, b: Int, c: Int): Int {\n    foo(a)\n    bar(b)\n    baz(c)\n    return 42\n}\n"
        },
        {
            "code": "\ninline class Model(val id: String)\nval model = Model(\"abc\")\n"
        },
        {
            "code": "\nimport kotlin.properties.ReadOnlyProperty\nimport kotlin.reflect.KProperty\n\nclass Foo {\n    val a: Int = 0\n    val b by Delegate(0)\n}\n\ninline class Delegate(val ignored: Int): ReadOnlyProperty<Foo, Int> {\n    override fun getValue(thisRef: Foo, property: KProperty<*>): Int {\n        return thisRef.a\n    }\n}\n"
        },
        {
            "code": "\ninline class Z(val s: String)\n\nfun main(args: Array<String>) {\n    val a = arrayOf(Z(\"x\"))\n    println(a[0].javaClass)  // java.lang.ClassCastException: Z cannot be cast to java.lang.String\n}\n"
        },
        {
            "code": "\ninline class Z(val s: String)\n\nfun main(args: Array<String>) {\n    val a = arrayOf(Z(\"x\"))\n    a[0].javaClass\n}\n"
        },
        {
            "code": "\nclass Foo {\n    private val fld: String = \"O\"\n        get() = { field }() + \"K\"\n\n    val indirectFldGetter: () -> String = { fld }\n\n    fun simpleFldGetter(): String {\n        return fld\n    }\n}\n\nfun main(args: Array<String>) {\n    val v = Foo()\n    println(\"indirectFldGetter: ${v.indirectFldGetter()}\")\n    println(\"simpleFldGetter: ${v.simpleFldGetter()}\")\n}\n"
        },
        {
            "code": "\nenum class MenuEventType {\n    OPTIONS,\n    OVERLAY\n}\n"
        },
        {
            "code": "\nfun main() {\n    println(Z::f)\n}\n\ninline class Z(val t2: Int) {\n    fun f(x: Int) {\n        println(x)\n    }\n}\n"
        },
        {
            "code": "\ninline class IcInt(val i: Int) {\n    fun simple() {}\n}\n\nfun test(i: IcInt) {\n    foo(i::simple) // CCE\n}\n\ninline fun foo(init: () -> Unit){\n    init()\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.resume\nimport kotlin.coroutines.suspendCoroutine\nimport kotlin.reflect.full.memberProperties\n\nabstract class AbstractTest {\n    abstract val x: suspend (Unit) -> Unit\n}\n\nclass Test: AbstractTest() {\n    override val x = ::suspendX\n    private suspend fun suspendX(unit: Unit): Unit = suspendCoroutine {\n        it.resume(unit)\n    }\n}\n\nfun main(args: Array<String>) {\n    val test = Test()\n    test::class.memberProperties.forEach {\n        println(it.getter.call(test))\n    }\n}\n"
        },
        {
            "code": "\ninline class Test(val a: Double)\n\nclass Demo {\n    val a by lazy { Test(0.0) }\n}\n\nfun main(args: Array<String>) {\n    println(Demo().a)\n}\n"
        },
        {
            "code": "\nfun foo(u: Int) {}\nfun foo(u: UInt) {} // No error, because we already mangled name of this function\n"
        },
        {
            "code": "\nsealed class S {\n    companion object {\n        val obj = Obj\n    }\n}\n\nobject Obj : S()\n"
        },
        {
            "code": "\ndata class RGBA(val rgba: Int)\n\ninline class RgbaArray(val array: IntArray) {\n   \tval size: Int get() = array.size\n\tfun fill(value: RGBA, start: Int = 0, end: Int = this.size): Unit = array.fill(value.rgba, start, end)\n}\n\nfun main(args: Array<String>) {\n    RgbaArray(IntArray(16)).fill(RGBA(0))\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class Z(val x: Int) {\n    inner class Inner(val y: Int) {\n        val xx = x\n    }\n}\n\nfun main(args: Array<String>) {\n    println(Z(42).Inner(100).xx)\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class Z(val x: Int) {\n    inner class Inner(val z: Z)\n}\n\nfun main(args: Array<String>) {\n    println(Z(42).Inner(Z(100)).z)\n}\n"
        },
        {
            "code": "\nfun testMethod() {\n  val f: () -> Int = {3}\n\n  class FunClass(\n      val x: Int = 3\n  )\n}\n"
        },
        {
            "code": "\ninline class A(val i: Int)\ninline class B(val a: A)\nval b: B? = null\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(\"Using for-in-array:\")\n    var xs = intArrayOf(1, 2, 3)\n    for (x in xs) {\n        println(x)\n        xs = intArrayOf()\n    }\n\n    println(\"Using array iterator:\")\n    xs = intArrayOf(1, 2, 3)\n    val xsi = xs.iterator()\n    while (xsi.hasNext()) {\n        val x = xsi.nextInt()\n        println(x)\n        xs = intArrayOf()\n    }\n}\n"
        },
        {
            "code": "\nclass C() {\n    var arr = intArrayOf(1, 2, 3)\n\n    fun updateArr() {\n        arr = intArrayOf()\n    }\n}\n\nfun main(args: Array<String>) {\n    println(\"C.arr:\")\n    val c = C()\n    for (x in c.arr) {\n        println(x)\n        c.updateArr()\n    }\n}\n"
        },
        {
            "code": "\ninline val Boolean.byte: Byte get() = if (this) 1.toByte() else 0.toByte()\n"
        },
        {
            "code": "\npackage test\n\ninline class R(private val r: Int) {\n    fun test() = { println(\"lambda\") }()\n}\n\nfun main(args: Array<String>) {\n    R(42).test()\n}\n"
        },
        {
            "code": "\ninline fun <reified T> trickMe(): String? {\n    return T::class.simpleName\n}\n\nfun main() {\n    println(Int::class.simpleName) //1\n    println(trickMe<Int>()) //2\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class S(val string: String)\n\nfun testMangled(s: S) {\n    class Local\n\n    val localKClass = Local::class\n    val localJClass = localKClass.java\n    println(localKClass.simpleName)\n    println(localJClass.simpleName)\n}\n\nfun testNonMangled() {\n    class Local\n\n    val localKClass = Local::class\n    val localJClass = localKClass.java\n    println(localKClass.simpleName)\n    println(localJClass.simpleName)\n}\n\nfun main(args: Array<String>) {\n    testMangled(S(\"\"))\n    testNonMangled()\n}\n"
        },
        {
            "code": "\ninternal class Internal\n\nfun a() {\n    Internal()\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class R(private val r: Int) {\n    fun test() = object {}\n}\n\nfun main(args: Array<String>) {\n    println(R(42).test())\n}\n"
        },
        {
            "code": "\ninline class B(val l: Long)\n\ninline class A(val b: B) {\n    override fun toString(): String {\n        return buildString {\n            append(\"asdsa\")\n            append(b.l + 12)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    println(A(B(12)).toString())\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class Z(val z: Int)\n\nfun test(z: Any = Z(42)) = (z as Z).z\n\nfun main(args: Array<String>) {\n    println(test())\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class Z(val x: Int)\n\nfun <T> id(x: T) = x\n\nfun main(args: Array<String>) {\n    println(Z(42) == id(Z(42)))\n}\n"
        },
        {
            "code": "\nfun f1(): List<Result<Int>> {\n    return listOf(\n        runCatching {\n            println(\"1\")\n            10\n        }\n    )\n}\n\nfun main() {\n    val t0 = f1()\n    val t1 = f1()[0]\n\n    val t2 = runCatching {\n        println(\"1\")\n        10\n    }\n\n    println(t0) // [Success(10)]\n    println(t1) // Success(Success(10))\n    println(t2) // Success(10)\n}\n"
        },
        {
            "code": "\ninline class A(val t: Int)\nsuspend fun produce1() = A(10)\nfun produce2() = A(10)\nsuspend fun main() {\n    println(produce1() == produce1()) // ClassCastException\n    println(produce1() == produce2()) // ClassCastException\n    println(produce1() == A(10)) // ClassCastException\n    println(produce2() == produce2()) // OK\n    println(produce2() == A(10)) // OK\n}\n"
        },
        {
            "code": "\nval u = 42u\nval s = \"$u\" // boxing, but method $Erased.box can be called\n"
        },
        {
            "code": "\ninline class Ucn(private val i: UInt)\n\nclass PPInput(private val s: ByteArray) {\n    fun peek(n: UInt = 0u): Ucn? = if (n >= s.size.toUInt()) null else Ucn(s[n.toInt()].toUInt())\n}\n"
        },
        {
            "code": "\ninline class Ucn(private val i: UInt)\n\ninterface Input<T> {\n    fun peek(n: UInt = 0u): T\n}\n\nclass RawInput(private val s: String) : Input<Ucn> {\n    override fun peek(n: UInt): Ucn = if (n >= s.length.toUInt()) Ucn(0u) else Ucn(s[n.toInt()].toInt().toUInt())\n}\n\nfun main(args: Array<String>) {\n    println(RawInput(\"test\").peek())\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class R(private val r: Int) {\n    fun test() = run { println(\"lambda\") }\n}\n\nfun main(args: Array<String>) {\n    R(42).test()\n}\n"
        },
        {
            "code": "\ninline class Foo(val a: String = \"\")\n"
        },
        {
            "code": "\npublic class PublicClass {\n    private companion object\n}\n"
        },
        {
            "code": "\n// !LANGUAGE: +InlineClasses\n// IGNORE_BACKEND: JVM_IR\n// WITH_RUNTIME\n\ninline class Ucn(private val i: UInt)\n\ninterface Input<T> {\n    fun foo(n: Int = 0): T\n}\n\nfun Char.toUInt() = toInt().toUInt()\n\nclass Kx(val x: UInt) : Input<Ucn> {\n    override fun foo(n: Int): Ucn =\n        if (n < 0) Ucn(0u) else Ucn(x)\n}\n\nfun box(): String {\n    val p = Kx(42u).foo()\n    if (p.toString() != \"Ucn(i=42)\") throw AssertionError()\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "\npackage test.p1\n\nabstract class A {\n    protected val hello: String = \"hello\"\n\n    protected inline fun <reified T> helloType(): () -> Unit = {\n        println(\"$hello ${T::class.java}\")\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\ninterface IFoo {\n    fun foo(): String\n}\n\ninline class InlineFooImpl(val s: String): IFoo {\n    override fun foo(): String = s\n}\n\nclass Test : IFoo by InlineFooImpl(\"abc\")\n"
        },
        {
            "code": "\ninterface IFace {\n    fun foo() = 0\n}\n\ninline class InlineBar(val x: Int) : IFace\n\nfun f(ib: InlineBar) = ib.foo()\n"
        },
        {
            "code": "\ninterface I {\n    val overrideMe: Double\n    fun someFun(that: I) = this.overrideMe + that.overrideMe\n}\n\ninline class C(override val overrideMe: Double) : I\n\nfun main(args: Array<String>) {\n    val x = C(1.0)\n    val y = C(2.0)\n    val z = x.someFun(y)\n}\n"
        },
        {
            "code": "\ninterface A {\n    fun foo()\n}\n\nclass B : A {\n    override fun foo() {\n    }\n}\n\nfun test1() {\n    val b = B()\n    (b as A).foo() // Null-check is absent\n}\n\nfun test2() {\n    val b = getB()\n    (b as A).foo() // Null-check is generated\n}\n\nfun test3() {\n    val b = getB()\n    b.foo() // Null-check is absent\n}\n\nfun getB(): B = B()\n"
        },
        {
            "code": "\nfun testPublic(s: String) = s.substring(1)\nprivate fun testPrivate(s: String) = s.substring(1)\n"
        },
        {
            "code": "\nfun wrongBreakLabel() {\n    var n = 10\n    while (n < 10) {\n        when (n) {\n            4 -> {\n                n++\n            }\n            5 -> {\n                println(5)\n                n++\n            }\n            else -> {\n                n++\n                listOf(1).all { true }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\ninline class S(val x: String) {\n    private fun foo() = x\n\n    fun lambda() = { foo() }\n}\n\nfun main(args: Array<String>) {\n    println(S(\"OK\").lambda()())\n}\n"
        },
        {
            "code": "\ninline class Outer(val x: Int) {\n    inner class Inner {\n        fun foo() = x\n    }\n}\n"
        },
        {
            "code": "\ninline class S(val x: String) {\n    private fun foo() = x\n\n    companion object {\n        fun bar(s: S) = s.foo()\n    }\n}\n\nfun main(args: Array<String>) {\n    println(S.bar(S(\"OK\")))\n}\n"
        },
        {
            "code": "\nsuspend fun f(i: Int): Long {\n    return if (i > 0) 1L else f_2()\n    // if (i > 0) return 1L   // this version doesn't lead to state machine generation\n    // return f_2()\n}\n\nprivate suspend fun f_2(): Long = TODO()\n"
        },
        {
            "code": "\nclass CharacterLiteral(private val prefix: NamelessString, private val s: NamelessString) {\n    override fun toString(): String = \"$prefix'$s'\"\n}\n\ninline class NamelessString(val b: ByteArray) {\n    override fun toString(): String = String(b)\n}\n\nfun main(args: Array<String>) {\n    println(CharacterLiteral(NamelessString(\"u\".toByteArray()), NamelessString(\"test\".toByteArray())))\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(\"with parameters\")\n}\n"
        },
        {
            "code": "\nfun main() {\n    println(\"without parameters\")\n}\n"
        },
        {
            "code": "\nobject MainObject {\n    @JvmStatic fun main(args: Array<String>) {\n        println(\"within object with parameters\")\n    }\n}\n"
        },
        {
            "code": "\nobject MainObjectBare {\n    @JvmStatic fun main() {\n        println(\"within object without parameters\")\n    }\n}\n"
        },
        {
            "code": "\ninline class A(val i: Int) {\n    fun f(): I = object : I {}\n}\ninterface I\n"
        },
        {
            "code": "\ninline class B constructor(val t: String = \"B\") {\n   // this gets an error \"Inline class primary constructor must have only final read-only (val) property parameter\"\n}\n"
        },
        {
            "code": "\ninline class A constructor(val t: String) {\n    constructor(): this(\"A\")\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.KProperty0\nimport kotlin.reflect.KProperty\n\nclass ByteDelegate private constructor(\n    private val position: Int,\n    private val uIntValue: KProperty0<UInt>\n) {\n    operator fun getValue(any: Any?, property: KProperty<*>): UByte {\n        @Suppress(\"CAST_NEVER_SUCCEEDS\")\n        return ((uIntValue.get() as Int).toUInt() shr (position * 8) and 0xffu).toUByte()\n    }\n    companion object {\n        fun byteDelegate(\n            position: Int,\n            uIntValue: KProperty0<UInt>\n        ) = ByteDelegate(\n            position,\n            uIntValue\n        )\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\ninline fun List<String>.foo() = \"list of strings\"\n"
        },
        {
            "code": "\npackage test\n\ninline fun List<Int>.foo() = \"list of ints\"\n"
        },
        {
            "code": "\nclass Test {\n    private companion object {\n        val i = 1\n    }\n}\n\nfun main(args: Array<String>) {\n    println(Test::class)\n}\n"
        },
        {
            "code": "\nclass Foo {\n    fun run() {\n        Nested().foo()\n    }\n\n    private companion object {\n        val x: Int = 42\n    }\n\n    private class Nested {\n        fun foo() {\n            println(x)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    Foo().run() // Compiles fine in 1.2, fails with IAE in 1.3\n}\n"
        },
        {
            "code": "\ninterface A {\n    \n    fun foo(): Unit {\n        Runnable{\n            println(\"called $x\")\n        }.run()\n    }\n    \n    private companion object {\n        val x = 45\n    }\n}\n\nclass B: A\n\nfun main(args: Array<String>) {\n    B().foo()\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class Z(val x: Int)\n\nfun <T : Z> foo(x: T) {}\n"
        },
        {
            "code": "\nclass SampleNotWorking {\n    private val builder = StringBuilder()\n    fun addMessage() {\n        builder.append(\"hello\")\n    }\n\n    override fun toString(): String {\n        return builder.toString()\n    }\n}\n\nclass SampleWorking {\n    private val builder = StringBuilder()\n    fun addMessage() {\n        builder.append(\"hello\")\n    }\n\n    override fun toString() = builder.toString()\n}\n"
        },
        {
            "code": "\nfun computeGrade(score: Int): Grade =\n        when (score) {\n            in 90..100 -> Grade.A\n            in 75 until 90 -> Grade.B\n            in 60 until 75 -> Grade.C\n            in 0 until 60 -> Grade.D\n            else -> throw IllegalStateException(\"Wrong score value!\")\n        }\n\nenum class Grade { A, B, C, D }\n"
        },
        {
            "code": "\ninline val IntArray.foo inline get() = indices\n\nfun main(args: Array<String>) {\n    val arr = IntArray(5)\n\n    for (i in arr.foo) {\n        println(i)\n    }\n}\n"
        },
        {
            "code": "\ninline fun on(body: () -> Unit) {\n    body()\n}\n\nclass A {\n\n    fun baz() {\n        foo()\n    }\n\n    private companion object {\n        private fun foo() {\n            on {\n                println(this::class.java)\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    A().baz()\n}\n"
        },
        {
            "code": "\ninline class Z(val x: Int) {\n    fun f(x: Int) {\n        val f = {\n            println(x)\n        }\n    }\n}\n"
        },
        {
            "code": "\ninline class Z(val x: Int) {\n    fun f(x: Int) {\n        println(x)\n    }\n}\n"
        },
        {
            "code": "\npackage com.github.vmironov\n\nfun main(args: Array<String>) {\n  CrashMe().crashMe()\n}\n\nclass CrashMe {\n  fun crashMe() {\n    \"crashMe\".let {\n      object : Any() {\n        override fun toString() = this@CrashMe.toString()\n      }\n    }.toString()\n  }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n  args?.let {\n    object {\n      val crash = args.toString()\n    }\n  }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val a = \"\"\n    val foo = run {\n        object {\n            val b = a\n        }\n    }\n}\n"
        },
        {
            "code": "\npackage test.internal\n\nimport java.util.*\n\nclass A() {\n    val list = ArrayList<Class<*>>()\n\n    inner class B() {\n        inline fun <reified T : Any> add() = list.add(T::class.java)\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\ninline class R(private val r: Int) {\n    fun test() = { ok() }()\n\n    fun ok() = println(\"OK\")\n}\n\nfun main(args: Array<String>) {\n    R(0).test()\n}\n"
        },
        {
            "code": "\ninline class R(private val r: Int) {\n    fun test() = pf()\n\n    companion object {\n        private fun pf() = \"OK\"\n    }\n}\n\nfun main(args: Array<String>) {\n    println(R(0).test())\n}\n"
        },
        {
            "code": "\n// !LANGUAGE: +InlineClasses\n// IGNORE_BACKEND: JVM_IR\n\ninterface IFoo<T : IFoo<T>> {\n    fun T.foo(): String = bar()\n    fun bar(): String\n}\n\ninline class Z(val x: Int) : IFoo<Z> {\n    override fun bar(): String = \"OK\"\n}\n\ninline class L(val x: Long) : IFoo<L> {\n    override fun bar(): String = \"OK\"\n}\n\ninline class S(val x: String) : IFoo<S> {\n    override fun bar(): String = x\n}\n\nfun Z.testZ() {\n    if (Z(42).foo() != \"OK\") throw AssertionError()\n}\n\nfun L.testL() {\n    if (L(4L).foo() != \"OK\") throw AssertionError()\n}\n\nfun S.testS() {\n    if (S(\"OK\").foo() != \"OK\") throw AssertionError()\n}\n\nfun box(): String {\n    Z(42).testZ()\n    L(4L).testL()\n    S(\"\").testS()\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "\ninterface IFace {\n    fun foo() = 0\n}\n\ninline class InlineClass(val x: String) : IFace\n\nfun main(args: Array<String>) {\n    InlineClass(\"foo\").foo()\n}\n\n"
        },
        {
            "code": "\nfun acceptSuspend(block: suspend () -> Unit) {}\nfun callSuspend() { acceptSuspend {} }\n"
        },
        {
            "code": "\ninline class SnekDirection(private val direction: Int) {\n    companion object {\n        val Up = SnekDirection(0)\n    }\n}\n\nfun testUnbox() : SnekDirection {\n    val list = arrayListOf(SnekDirection.Up)\n    return list[0]\n}\n"
        },
        {
            "code": "\nclass A {\n    private companion object {\n        const val x = 1\n        @JvmField\n        val q = Any()\n    }\n    \n    fun bar() {\n        println(x.toString() + q)\n    }\n}\n"
        },
        {
            "code": "\ninline class Foo(val x: Any?)\n\ninline fun bar(a: Any?) {\n    println(a)\n}\n\nfun test(f: Foo) {\n    bar(f) // no boxing, but should be\n}\n"
        },
        {
            "code": "\ninline class WrappedString(val value: String) {\n    constructor() : this(\"Default\")\n}\n\ninline class WrappedBoolean(val value: Boolean) {\n    constructor() : this(false)\n}\n\ninline class WrappedDouble(val value: Double) {\n    constructor() : this(0.0)\n}\n\nfun main(args: Array<String>) {\n    // val a = WrappedString()\n    // val b = WrappedBoolean()\n    // val c = WrappedDouble()\n}\n"
        },
        {
            "code": "\ninline class Foo<T>(val x: Int)\nclass Bar(val z: Foo<Any>)\n"
        },
        {
            "code": "\npackage test\n\ninterface IFoo<T> {\n    fun foo(): T\n}\n\nopen class CFooInt : IFoo<Int> {\n    override fun foo(): Int = 42\n}\n\nopen class CFooUInt : IFoo<UInt> {\n    override fun foo(): UInt = 42u\n}\n"
        },
        {
            "code": "\nclass Outer {\n    data class Inner(val onSuccess: () -> Unit = {})\n\n    val inner = Runnable {\n        Inner().onSuccess()\n    }\n}\n\nfun main(args: Array<String>) = Outer().inner.run()\n"
        },
        {
            "code": "\nfun test(a: Any?) {\n    (a as String).length\n}\n"
        },
        {
            "code": "\nfun test(a: String) {}\n"
        },
        {
            "code": "\ninline class Z1(val x: Int)\ninline class Z2(val x: Z1)\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val a = listOf(10u, 20u, 30u)\n    a.forEachIndexed { index, uInt ->\n        println(index)\n        println(uInt)\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\nclass Foo {\n    fun bar(obj: Any) {\n        with(obj) {\n            Runnable {\n                obj.hashCode()\n                Runnable { }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\npackage kui\n\nabstract class Component\n\ninterface Renderer<C : Component> {\n    val template: Template\n}\n\nclass Template\n\ninline fun <C : Component> buildTemplate(block: TemplateBuilder<C>.() -> Unit): Template {\n    return BaseTemplateBuilder<C>().apply(block).build()\n}\n\nabstract class TemplateBuilder<C : Component> {\n    inline fun div(block: TemplateElement<C>.() -> Unit) {\n        println(\"hello\")\n        TemplateElement<C>().block()\n    }\n}\n\nclass BaseTemplateBuilder<C : Component> : TemplateBuilder<C>() {\n    fun build(): Template {\n        return Template()\n    }\n}\n\nclass TemplateElement<C : Component> : TemplateBuilder<C>() {\n    inline fun <reified C2 : Component> component(renderer: Renderer<C2>) {\n        println(C2::class.simpleName)\n    }\n}\n"
        },
        {
            "code": "\n@JvmField val x = 1\n"
        },
        {
            "code": "\npackage test\n\nclass Zap<T>\n\ninline val <reified T> Zap<T>.zapper\n    get() = { x: Any -> x as T }\n\nfun main(args: Array<String>) {\n    println(Zap<Int>().zapper(\"abc\"))\n}\n"
        },
        {
            "code": "\ninline fun <reified T> classOf(): Any = { 1 is T }()\n\nfun main(args: Array<String>) {\n    println(classOf<Int>())\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {                          \n    println(\"Hello, world!\")    \n    val v = Vector(1.0, 0.0, 2.0)    \n    println(\"Vector! $v\")\n}\ninline class Vector(val raw: DoubleArray) {\n    constructor(x: Double, y: Double, z: Double): this(doubleArrayOf(x, y, z))\n}\n"
        },
        {
            "code": "\ninline class Z(val x: Int)\n\nvar z = Z(0)\nclass Test(var z: Z)\n"
        },
        {
            "code": "\npublic inline fun <reified T> jaggedArrayOfNulls(rows: Int, cols: Int): Array<Array<T?>>\n        = Array(rows) { arrayOfNulls<T>(cols) }\n\npublic fun jaggedIntArray(rows: Int, cols: Int): Array<IntArray>\n        = Array(rows) { IntArray(cols) }\n\n// etc for primitives\n"
        },
        {
            "code": "\n@Target(AnnotationTarget.PROPERTY_GETTER)\nannotation class Foo\n\nannotation class A(@get:Foo val x: Int)\n"
        },
        {
            "code": "\npackage test\n\nfun nothing_to_do_with_anything() = listOf<String>().associate { it to it }\nfun nothing_to_do_with_anything_either() = listOf<String>().mapNotNull { null }\n\nopen class Parent\n\nclass Child : Parent()\n\nclass StupidThings(map: Map<String, List<Parent>>) {\n\n    private val _map = HashMap<String, List<Child>>()\n\n    init {\n        map.forEach { (key, bindings) ->\n            _map[key] = bindings.map { it as? Child ?: Child() }\n        }\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun foo(): List<Pair<String, List<Child>>> {\n        return _map.keys.map { realKey -> realKey to _map[realKey]!! }\n    }\n\n}\n\nfun main(args: Array<String>) {\n    val test = StupidThings(mapOf(\"coucou\" to listOf(Parent())))\n    test.foo()\n}\n"
        },
        {
            "code": "\nfun test(x: UInt) = \"x: $x\"\n"
        },
        {
            "code": "\ninline class Foo(val abc: String)\n\nfun main(args: Array<String>) {\n    Foo(\"abc\").hashCode()\n}\n"
        },
        {
            "code": "\ninline class Foo(val x:Int)\n\nfun foo(f:Foo){\n    f.hashCode()\n}\n"
        },
        {
            "code": "\nimport kotlin.contracts.*\n\n@ExperimentalContracts\nfun myRun(block: () -> Unit) {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    block()\n}\n\n@ExperimentalContracts\nfun main(args: Array<String>) {\n    val x: String\n    myRun { x = \"abc\" }\n    println(x)\n}\n"
        },
        {
            "code": "\n@Target(AnnotationTarget.TYPE)\nannotation class A\n"
        },
        {
            "code": "\npackage com.company.test\n\nconst val STRING = \"Test\"\n"
        },
        {
            "code": "\nimport kotlin.reflect.KProperty\nimport kotlin.reflect.KProperty0\n\nclass ByteDelegate(\n    private val position: Int,\n    private val uIntValue: KProperty0<UInt>\n) {\n    operator fun getValue(any: Any?, property: KProperty<*>): UByte {\n        val uInt = uIntValue.get() shr (position * 8) and 0xffu\n        return uInt.toUByte()\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.KProperty\nimport kotlin.reflect.KProperty0\n\nclass ByteDelegate(\n    private val position: Int,\n    private val uIntValue: KProperty0<UInt>\n) {\n    operator fun getValue(any: Any?, property: KProperty<*>): UByte {\n        val uInt = (uIntValue.get() as Int).toUInt() shl position and 0xffu\n        return uInt.toUByte()\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n\tprintln(MyThrowable())\n}\n\nclass MyThrowable(message: String?) :  Throwable(\"through primary: \" + message) {\n    constructor() : this(message = \"secondary\") {\n    }\n    \t\n    init { println(\"init block\") }\n}\n// actual output\n// Error: secondary\n\n// expected output\n// init block\n// MyThrowable: through primary: secondary\n"
        },
        {
            "code": "\nclass Err constructor(msg: String?, unused: Any?) {\n    constructor() : this(null, null)\n    constructor(msg: String) : this(msg, null)\n}\n"
        },
        {
            "code": "\nfun dummy() {}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.buildSequence\n\nfun main(args: Array<String>) {\n    buildSequence<Unit> {\n        listOf(1)\n            .groupingBy { it }\n            .reduce { _, a, b -> a + b }\n    }.toList()\n}\n"
        },
        {
            "code": "\ninterface SubMap<K, V> : Map<K, V> {\n    override val values: Set<V>\n}\n"
        },
        {
            "code": "\ninline class Username(val value: String)\n\nfun scenarioB(name: Username?): List<Username?> = listOf(name)\n\nfun main(args: Array<String>) {\n    scenarioB(null)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val arr = Array(5) { 12u }\n    for (i in arr.indices) {\n        println(\"arr[$i] = ${arr[i]}\")\n    }\n}\n"
        },
        {
            "code": "\nvar intN: Int? = 0\nvar uintN: UInt? = 0u\n\nfun test() = intN == 1\n\nfun testU1() = uintN == 1u\n\nfun testU2() = 1u == uintN\n"
        },
        {
            "code": "\ninline class UInt(private val data: Int)\n\nval unull = UInt(1) ?: null // autoboxing to Integer, not UInt\n"
        },
        {
            "code": "\npackage tech.pronghorn\n\nabstract class C {\n    protected abstract fun optional(): String?\n    protected abstract suspend fun slow(): String\n\n    suspend fun optimized(): String {\n        val value = optional()\n        if(value != null){\n            return value\n        }\n        else {\n            return slow()\n        }\n    }\n\n    suspend fun notOptimized(): String {\n        return optional() ?: slow()\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val x = Wrapper(1)\n    println(x)\n}\n\ninline class Wrapper(private val v: Int)\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val x = Wrapper(112u)\n    println(x)\n}\n\ninline class Wrapper(private val v: UInt)\n"
        },
        {
            "code": "\npackage test\n\ninline class Z(val value: Int)\n\nfun eqZ(x: Z, y: Z?) = x == y\n\nfun main(args: Array<String>) {\n    println(eqZ(Z(1), Z(1))) // false\n}\n"
        },
        {
            "code": "\ninline class InlineDouble(val value: Double)\n\ndata class DataDouble(val double: Double)\n\nfun main(args: Array<String>) {\n    println(InlineDouble(0.0) == InlineDouble(-0.0))\n    println(InlineDouble(Double.NaN) == InlineDouble(Double.NaN))\n\n    println(DataDouble(0.0) == DataDouble(-0.0))\n    println(DataDouble(Double.NaN) == DataDouble(Double.NaN))\n}\n"
        },
        {
            "code": "\npackage co\n\n\n@Suppress(\"UNSUPPORTED_FEATURE\")\ninline class Wrapper(val internal: Int)\n\n\ninline fun <T> foo(callback: () -> T): T {\n    return callback()\n}\n\ninline fun bar(callback: () -> Wrapper): Wrapper {\n    return callback()\n}\n\nfun main(args: Array<String>) {\n    println(foo { Wrapper(10) }.internal) // Boxing\n    println(bar { Wrapper(10) }.internal) // Boxing\n}\n\n"
        },
        {
            "code": "\nval x: String by null\n\noperator fun Nothing?.getValue(instance: Any?, metadata: Any?): String = \"OK\"\n\nfun box(): String = x\n\nfun main(args: Array<String>) {\n    println(box())\n}\n"
        },
        {
            "code": "\nsuspend fun foo() {}\n\nsuspend fun bar() {\n    foo()\n    foo()\n}\n"
        },
        {
            "code": "\nsealed class X {\n    class A : X()\n    class B : X()\n}\n\nsuspend fun process(a: X.A) {}\nsuspend fun process(b: X.B) {}\n\nsuspend fun process(x: X) = when (x) {\n    is X.A -> process(x)\n    is X.B -> process(x)\n}\n"
        },
        {
            "code": "\ninline class Foo(val arg: String)\n\nfun main(args: Array<String>) {\n    for (el in listOf(Foo(\"abc\"))) {\n    }\n}\n"
        },
        {
            "code": "\ninline class Foo(val arg: Int)\n\nfun main(args: Array<String>) {\n    for (el in arrayOf<Foo>()) {\n\n    }\n}\n"
        },
        {
            "code": "\ninline class Foo(val x: Int) {\n    fun bar() {}\n}\n"
        },
        {
            "code": "\n// ext.kotlin_version = '1.2.60-eap-7'\n//\n//compileKotlin {\n//    kotlinOptions.jvmTarget = \"1.8\"\n//    kotlinOptions.freeCompilerArgs = [\"-XXLanguage:+InlineClasses\"]\n//    kotlinOptions.languageVersion = \"1.2\"\n//}\n\ninline class Rgba(val value: Int) {\n    inline val r: Int get() = (value shr 0) and 0xFF\n    inline val g: Int get() = (value shr 8) and 0xFF\n    inline val b: Int get() = (value shr 16) and 0xFF\n    inline val a: Int get() = (value shr 24) and 0xFF\n}\n\nfun Rgba(r: Int, g: Int, b: Int, a: Int): Rgba {\n    return Rgba(\n        ((r and 0xFF) shl 0) or ((g and 0xFF) shl 8) or ((b and 0xFF) shl 16) or ((a and 0xFF) shl 24)\n    )\n}\n\nfun Rgba.withR(r: Int) = Rgba(r, g, b, a)\nfun Rgba.withG(g: Int) = Rgba(r, g, b, a)\nfun Rgba.withB(b: Int) = Rgba(r, g, b, a)\nfun Rgba.withA(a: Int) = Rgba(r, g, b, a)\n\ninline class RgbaArray(val array: IntArray) {\n    constructor(size: Int) : this(IntArray(size))\n    operator fun get(index: Int): Rgba = Rgba(array[index])\n    operator fun set(index: Int, color: Rgba) {\n        array[index] = color.value\n    }\n}\n\nfun main(args: Array<String>) {\n    val result = RgbaArray(32) // Cause exception: AFTER mandatory stack transformations: incorrect bytecode Element is unknownThe root cause was thrown at: MethodVerifier.kt:28\n    //val result = RgbaArray(IntArray(32)) // Works\n    val color = Rgba(128, 128, 0, 255)\n    result[0] = color.withG(64).withA(0)\n    println(result[0].value)\n}\n"
        },
        {
            "code": "\ninterface KotlinInterface {\n    fun plugin(id: String)\n}\n"
        },
        {
            "code": "\npackage com.packageA\n\nabstract class A {\n    protected var x: String? = null\n        private set // important that setter is private\n\n\n    open fun set() {\n        x = \"not_important\"\n    }\n}\n"
        },
        {
            "code": "\noperator fun <T, U> T.invoke(x: U) = \":)\"\n\nfun main(args: Array<String>) {\n    \tval a = String { 1 }\n    \tprintln(a)\n}\n"
        },
        {
            "code": "\noperator fun <T, U> T.invoke(x: U) = \":)\"\n\nfun main(args: Array<String>) {\n    \tval a = KotlinVersion { 1 }\n    \tprintln(a)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val x = Wrapper(\"Hello\")\n    println(x.toString())\n}\n\ninline class Wrapper(private val v: String)\n"
        },
        {
            "code": "\nsuspend inline fun <R> inlined(\n    crossinline step: suspend () -> R\n): R = notInlined { step() }\n\nsuspend fun <R> notInlined(\n    block: suspend () -> R\n): R = block()\n"
        },
        {
            "code": "\ninterface Job {\n    public fun cancel(cause: Throwable? = null): Boolean\n}\n"
        },
        {
            "code": "\npackage test\n\nimport test.B.x\n\nobject B {\n    var x = 0\n}\n\nfun test() {\n    x += 42\n}\n"
        },
        {
            "code": "\nsuspend fun dummy(a: Int) {}\n\nsuspend fun foo(a: Int) {\n    dummy(a)\n    dummy(a)\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.*\n\n// var out by atomicRef(listOf<String>()) // works\nfun main(args: Array<String>) {\n\tvar out by atomicRef(listOf<String>()) // fails\n\tval obj = object {\n        init {\n            println(out)\n        }\n    }\n}\n\nclass atomicRef<T>(var initial: T) {\n\tval value = java.util.concurrent.atomic.AtomicReference<T?>(initial)\n\n\tinline operator fun getValue(obj: Any?, property: KProperty<*>): T {\n\t\t@Suppress(\"UNCHECKED_CAST\")\n\t\treturn this.value.get() as T\n\t}\n\n\tinline operator fun setValue(obj: Any?, property: KProperty<*>, v: T) {\n\t\tthis.value.set(v)\n\t}\n}\n"
        },
        {
            "code": "\nsealed class A {\n    companion object {\n        val STATIC = listOf(AA, AB)\n    }\n}\n\nobject AA : A()\nobject AB : A()\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.*\n\nenum class Foo(vararg expected: String) {\n    A(\"start\", \"A\", \"end\"),\n    B(\"start\", \"BCD\", \"end\"),\n    C(\"start\", \"BCD\", \"end\"),\n    D(\"start\", \"BCD\", \"end\"),\n    E(\"start\", \"E\", \"end\"),\n    F(\"start\", \"end\");\n    \n    val expected = expected.toList()\n}\n\nfun main(args: Array<String>) {\n    for (v in Foo.values()) {\n        test(v)\n    }\n}\n\nfun test(c: Foo) {\n    print(\"$c: \")\n\n    val actual = getSequence(c).toList()\n    if (actual == c.expected) {\n        println(\"OK -- ${c.expected}\")\n    } else {\n        println(\"Fail -- ${c.expected} != $actual\")\n    }\n}\n\nfun getSequence(a: Foo) =\n    buildSequence {\n//         println(\"start\")\n        yield(\"start\")\n        when (a) {\n            Foo.A -> {\n//                 println(\"A\")\n                yield(\"A\")\n            }\n            Foo.B,\n            Foo.C,\n            Foo.D-> {\n//                 println(\"BCD\")\n                yield(\"BCD\")\n            }\n            Foo.E-> {\n//                 println(\"E\")\n                yield(\"E\")\n            }\n        }\n//         println(\"end\")\n        yield(\"end\")\n    }\n"
        },
        {
            "code": "\nfun <T> String.parse(): List<T> =\n    this.split(\",\").map {\n        try {\n            it as T\n        } catch (e: ClassCastException) {\n            error(\"fail\") // <-- 1\n        }\n    }\n\nfun main(args: Array<String>) {\n    val list = \"a,b,c\".parse<Int>()\n    println(list)\n    list.forEach {\n        try {\n            it + 1\n        } catch (e: ClassCastException) {\n            error(\"epic fail\") // <-- 2\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    lateinit var s: String\n    println(s)\n}\n"
        },
        {
            "code": "\nclass Bar\n\nclass Foo {\n    val bar = Bar()\n}\n\ninline operator fun Bar.invoke(f: () -> String) { f() }\n\nfun box(): String {\n    Foo().bar { return \"OK\" }\n    return \"fail\"\n}\n\nfun main(args: Array<String>) {\n    println(box())\n}\n"
        },
        {
            "code": "\nval i = 0x9747b28c.toInt()\n"
        },
        {
            "code": "\nfun F(): String\n{\n    val x = \"X\"\n    return \"Some \" +\n        \"very \" +\n        \"long \" +\n        \"string $x\"\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val sb = StringBuilder()\n    val foo = \"Bar\"\n    sb.append(\"My name is $foo.\")\n}\n"
        },
        {
            "code": "\nabstract class Outer {\n    inner class Inner<R>\n    fun <R> foo(): Inner<R>? = null\n}\n\nfun box(): String {\n    Outer::class.java.getDeclaredMethods().single { it.name == \"foo\" }.toGenericString()\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "\n@Target(AnnotationTarget.PROPERTY)\nannotation class Foo\n\nannotation class A(@Foo val x: Int)\n"
        },
        {
            "code": "\nabstract class C {\n    protected abstract fun ready(): Boolean\n    protected abstract suspend fun slow(): Boolean\n\n    suspend fun optimized(): Boolean {\n        if(ready()){\n            return true\n        }\n        else {\n            return slow()\n        }\n    }\n\n    suspend fun notOptimized(): Boolean {\n        return ready() || slow()\n    }\n}\n"
        },
        {
            "code": "\ninterface A\n\ndata class B<out T : A>(val a: T)\n\nfun main(args: Array<String>) {\n  val b1 = B(object : A {})\n  val b2 = B(object : A {})\n  println(b1.hashCode() == b2.hashCode())\n}\n"
        },
        {
            "code": "\nannotation class Anno\n\n@Anno\ndata class DataCls(val a: Anno)\n\nfun box(): String {\n    val anno = DataCls::class.annotations.first() as Anno\n    val d1 = DataCls(anno)\n    val d2 = DataCls(anno)\n    val c1 = d1.equals(d2)\n    val c2 = d1.hashCode() \n    return \"OK\"\n}\n"
        },
        {
            "code": "\n@Target(AnnotationTarget.TYPE)\nannotation class A\n\nfun main(args: Array<String>) {\n    println(A::class.java.declaredAnnotations.toList())\n}\n"
        },
        {
            "code": "\ndata class D(val x: List<String>)\n"
        },
        {
            "code": "\nval o = object : Any() {}\n"
        },
        {
            "code": "\nenum class AnEnum(val aNonNullField: AnEnum) {\n    A_FIRST_CASE(A_FIRST_CASE)\n}\n"
        },
        {
            "code": "\nclass Ref<K : Comparable<K>, V>(val key: K, val value: V) : Comparable<Ref<K, *>> {\n    override fun compareTo(other: Ref<K, *>) = key.compareTo(other.key)\n}\n\nfun <K : Comparable<K>, V> smooth(\n    refs: List<Ref<K, V>>,\n    offset: K,\n    normalizer: (value: K, before: K, after: K) -> Double,\n    interpolator: (origin: V, target: V, ratio: Double) -> V\n): V {\n    val index = refs.binarySearchBy(offset) { it.key }\n    if (index >= 0) return refs[index].value\n    val before = refs.getOrNull(-index - 2)\n    val after = refs.getOrNull(-index - 1)\n    return when {\n        before != null && after != null -> interpolator(\n            before.value,\n            after.value,\n            normalizer(offset, before.key, after.key)\n        )\n        before != null && after == null -> before.value\n        before == null && after != null -> after.value\n        else -> error(\"No refs found at $offset\")\n    }\n}\n\ninterface Info<T> {\n    fun interpolate(origin: T, target: T, ratio: Double): T\n}\n\nfun Double.lerp(target: Double, ratio: Double) = this + (target - this) * ratio\nfun Double.unlerp(min: Double, max: Double) = if (min == max) 0.0 else minus(min) / (max - min)\nfun Int.unlerp(min: Int, max: Int) = toDouble().unlerp(min.toDouble(), max.toDouble())\n\nobject DoubleInfo : Info<Double> {\n    override fun interpolate(origin: Double, target: Double, ratio: Double) = origin.lerp(target, ratio)\n}\n\nclass Prop<T>(val info: Info<T>) {\n    val refs = mutableListOf<Ref<Int, T>>()\n}\n\nclass Container {\n    val smooths = mutableListOf<Prop<*>>()\n}\n\nfun main(args: Array<String>) {\n    val container = Container()\n    val prop = Prop(DoubleInfo)\n    container.smooths += prop\n    prop.refs += Ref(0, 4.0)\n    prop.refs += Ref(10, 9.0)\n\n    val atThree = container.smooths.map {\n        smooth(\n            it.refs as List<Ref<Int, Any>>,\n            3,\n            Int::unlerp,\n            it.info::interpolate as (Any, Any, Double) -> Any\n        )\n    }\n    println(atThree)\n}\n"
        },
        {
            "code": "\ninline fun foo(): Boolean {\n    println(\"FAILED\")\n    return false\n}\n\nfun a() = true\n\nfun main(args: Array<String>) {\n    do {\n        println(\"1\")\n        if (a()) break\n        println(\"2\")\n        if (a()) continue\n        println(\"3\")\n    } \n    while(foo())\n}\n"
        },
        {
            "code": "\ninline fun foo() = false\n\nfun run(x: Boolean) {\n    do {     \n        do { } while (false)         \n        if (x) continue\n    } while(foo())\n}\n\nfun main(args: Array<String>) {\n    run(true)\n}\n"
        },
        {
            "code": "\ninterface SomeInterface<T>\n\nobject Container {\n    private inline fun <reified T> someMethod() = object : SomeInterface<T> { }\n    class SomeClass : SomeInterface<SomeClass> by someMethod()\n}\n\nfun main(args: Array<String>) {\n    Container.SomeClass()\n}\n"
        },
        {
            "code": "\n// Utils.kt\n\n@file:MyJvmName(\"MyUtils\")\n\ntypealias MyJvmName = kotlin.jvm.JvmName\n"
        },
        {
            "code": "\ninline fun runMe(block: () -> Unit) {\n    block.invoke() // fails\n//    block() // works\n}\n\nfun box(): String {\n    runMe {\n        return \"OK\"\n    }\n    return \"fail\"\n}\n\nfun main(args: Array<String>) {\n  println(box())\n}\n"
        },
        {
            "code": "\nclass Inline {\n    fun publicCall(): Int = privateCall() * 2\n\n    @SuppressWarnings(\"nothing_to_inline\")\n    private inline fun privateCall(): Int = 42\n}\n"
        },
        {
            "code": "\nfun test() {\n    val c: suspend () -> Unit = {}\n}\n"
        },
        {
            "code": "\ndata class Vec2f(var x: Float, var y: Float) {\n    inline var r: Float get() = x; set(value) { x = value }\n    inline var g: Float get() = y; set(value) { y = value }\n}\n"
        },
        {
            "code": "\nabstract class A : Collection<String> {\n    // public final foo([Ljava/lang/Object;)[Ljava/lang/Object;\n    protected fun <T> foo(x: Array<T>): Array<T> = x // \n}\n"
        },
        {
            "code": "\noperator fun ByteArray.set(i: Int, v: Int) {\n    println(\"operator set invoked\")\n}\n\nfun main(args: Array<String>) {\n    val b = ByteArray(1)\n    val v = 1 // Int type\n    b[0] = v // this line resolves to operator set, which can be seen in IDEA\n    println(\"Done\")\n}\n"
        },
        {
            "code": "\nclass A {\n    operator fun set(\n            i1: Int,\n            i2: Int = 1,\n            v: Int\n    ) {\n        println(i2)\n    }\n}\n\nfun main(args: Array<String>) {\n    A()[1] = 1 // prints \"0\", expected \"1\"\n}\n\n"
        },
        {
            "code": "\nclass TestTest {\n    abstract class Point {\n        abstract val x: Double\n        abstract val y: Double\n    }\n\n    data class PointImpl(override val x: Double, override val y: Double) : Point()\n\n    interface PointConsumer<T : Point> {\n        var point: T\n        fun consumePoint(point: T)\n        fun transformPoint(point: T): Point\n    }\n\n    class PointConsumerImpl : PointConsumer<PointImpl> {\n        override var point: PointImpl = PointImpl(1.0, 2.0)\n\n        override fun consumePoint(point: PointImpl) {\n            TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n        }\n\n        override fun transformPoint(point: PointImpl): Point {\n            TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n        }\n    }\n}\n"
        },
        {
            "code": "\npackage some.pack\n\ninline infix operator fun <T> Int.times(block: () -> T) =\n\tif (this < 0)\n\t\tthrow IllegalArgumentException(\"Cannot repeat negative times, use 0 or greater\")\n\telse\n\t\t(1..this).map { block() }\n"
        },
        {
            "code": "\nfun String.test(): String {\n  return this\n}\n\nobject Foo {\n  fun bar() {\n    \"hi\".test()\n  }\n}\n"
        },
        {
            "code": "\nprivate const val DAY = 24 * 60 * 60 * 1000L\nfun main(args: Array<String>) { println(1L > DAY) }\n"
        },
        {
            "code": "\nabstract class WorkingMap<K, V> : Map<K, V> {\n  abstract override fun get(key: K): V?\n}\nabstract class BrokenMap<K, V> : Map<K, V>\n"
        },
        {
            "code": "\nfun bar(): String {\n    val foo = 1\n    return \"${foo}bar\"\n}\n"
        },
        {
            "code": "\nclass A{\n    fun foo(): String = \"$this\" + \"test: $this\"\n}\n"
        },
        {
            "code": "\nval zero = object : Function0<Int> {\n    override fun invoke(): Int = 0\n}\n\nfun main(args: Array<String>) {\n    println(zero())\n}\n"
        },
        {
            "code": "\nclass Number(val n: Int) : Function0<Int> {\n    override fun invoke(): Int = n\n}\n\nfun numberAsFunction0(n: Int): Function0<Int> = Number(n)\n\nfun main(args: Array<String>) {\n    // works\n    println(Number(1)()) \n    \n    // crashes\n    println(numberAsFunction0(2)()) \n}\n"
        },
        {
            "code": "\nclass TaggedFunction1<T, R>(val tag: String, val f: (T) -> R): (T) -> R by f\n"
        },
        {
            "code": "\nvar deadline = 10\n\ntailrec fun recursionTest() {\n    if (deadline-- == 0) return\n\n    run {\n        println(\"$deadline\")\n        return recursionTest()\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.concurrent.thread\n\nclass VerifierCrash {\n    init {\n        runOnThread {\n            builder { suspending() }\n        }\n    }\n\n    fun builder(block: suspend () -> Unit) {} /* body does not matter */\n    suspend fun suspending() {} /* body does not matter */\n\n    inline fun runOnThread(crossinline action: () -> Unit) {\n        /* double cross-inline */\n        thread { action() }\n    }\n\n}\n\nfun main(args: Array<String>) {\n    VerifierCrash()\n}\n"
        },
        {
            "code": "\nimport java.io.File\nimport java.io.FileReader\n\nfun main(args: Array<String>) {\n    var file = File(\"removeMe\").apply { createNewFile(); deleteOnExit() }\n    var pop = Array(28, { DoubleArray(32) })\n    val toRz = {\n        synchronized(file) {\n            FileReader(file.path).use { df ->\n                for ((popIdx, paramSet) in pop.withIndex()) {\n                    println(\"foo!\")\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\nopen class A {\n    open fun foo(x: Int = 42) {\n        throw AssertionError()\n    }\n}\n\nclass B : A() {\n    @JvmOverloads\n    override fun foo(x: Int) {\n        if (x != 42) throw AssertionError(x.toString())\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n\n    while (true) {}\n\n}\n"
        },
        {
            "code": "\n//For Simple\ninline fun <T> inlineFunction(crossinline function: () -> T): T = function()\n\n//For Simple\nfun <T> notInlineFunction(function: () -> T): T = function()\n\nfun testFunction(value: Boolean) {\n    inlineFunction {\n        notInlineFunction {\n            if (value) {\n                notInlineFunction {\n                    // this Lambda unresolved references\n                }\n            }\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    Pair(1.0,2.0).first.equals(2.0)\n}\n"
        },
        {
            "code": "\nclass `A)V`\nfun fails(x: String) {\n    `¯|_(ツ)_|¯`(x, `A)V`())\n}\nfun `¯|_(ツ)_|¯`(x: String, i: `A)V`): `A)V` {\n    System.err.println(x)\n    return i\n}\n"
        },
        {
            "code": "\npackage test\n\nclass In<in I>\n\nfun <S> select(x: S, y: S): S = x\n\nfun <T> foo(a: Array<In<T>>, b: Array<In<String>>) =\n        select(a, b)[0].ofType(true)\n\n\ninline fun <reified K> In<K>.ofType(y: Any?) =\n        y is K\n\nfun main(args: Array<String>) {\n    val a1 = arrayOf(In<Int>())\n    val a2 = arrayOf(In<String>())\n    println(foo(a1, a2))\n}\n"
        },
        {
            "code": "\npackage lateinitInCompanionObject\n\nclass Test {\n    companion object {\n        lateinit var buggy: Collection<Int>\n        fun access(): Boolean = this::buggy.isInitialized\n    }\n}\n\nfun main(args: Array<String>) {\n    Test.access()\n}\n"
        },
        {
            "code": "\nfun bar(args: Collection<String>) {\n    args.sortedByDescending { it.length }\n}\n"
        },
        {
            "code": "\nfun main() {\n    foo { it.length }\n    bar { it.size }\n}\n\ninline fun foo(crossinline f: (String) -> Unit) {\n    bar { f(it[0]) }\n}\n\nfun bar(f: (Array<String>) -> Unit) {}\n"
        },
        {
            "code": "\npackage foo\n\ninterface Map<K>\n\nclass C\n"
        },
        {
            "code": "\ninline fun toInline(a: String, b: Int, c: Boolean) : String {\n    return \"hi\"\n}\n\nfun caller() {\n    toInline(\"a\", 2, true)\n}\n"
        },
        {
            "code": "\nclass DelegatedPropertyMap(val map: HashMap<String, String>) {\n    var demo by map\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n\tval i = 1000 * 2\n\tprintln(i)\n\t\n\tval j = 1000.double()\n\tprintln(i)\n}\n\nprivate inline fun Int.double() = this * 2\n"
        },
        {
            "code": "\nfun test() {\n    Foo.print()\n    Bar.print()\n}\n\nclass Foo {\n    companion object {\n        inline fun print() {\n            println(\"Foo:print()\")\n        }\n    }\n}\n\nobject Bar {\n    inline fun print() {\n        println(\"Bar:print()\")\n    }\n}\n"
        },
        {
            "code": "\nclass X {\n    val result: String\n        inline get() = \"OK\"\n\n    fun x() {\n        ::result\n    }\n}\n"
        },
        {
            "code": "\npackage pkg1\n\ninternal class Internals {\n    private fun pvt(limit: Int = 0) {\n    }\n\n    internal inline fun failing() {\n        pvt()\n    }\n\n    internal inline fun working() {\n        pvt(0)\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    createRunnable {\n        object : Runnable {\n            override fun run() {\n                println(SomeClass(\"hello\")) // NoSuchMethodError: RunMeKt$main$1$1$SomeClass.<init>(LRunMeKt$main$$inlined$createRunnable$1$lambda$1;Ljava/lang/String;)V\n            }\n\n            inner class SomeClass(var prop: String)\n        }.run()\n    }.run()\n}\n\ninline fun createRunnable(crossinline code: ()->Unit): Runnable = object : Runnable {\n    override fun run() = code()\n}\n"
        },
        {
            "code": "\nclass CompilerKillingIterator<T, out R>(private val underlying: Iterator<T>, private val transform: suspend (e: T) -> Iterator<R>) {\n    private var currentIt: Iterator<R> = null!!\n\n    suspend tailrec fun next(): R {\n        return if (currentIt.hasNext()) {\n            currentIt.next()\n        } else if (underlying.hasNext()) {\n            currentIt = transform(underlying.next())\n            next()\n        } else {\n            throw IllegalArgumentException(\"Cannot call next() on the empty iterator\")\n        }\n    }\n}\n"
        },
        {
            "code": "\npackage xyz.nulldev\nclass Huh {\n    private interface UriFilter\n\n    open class Filter<V>(val name: String, val state: V) {\n        open class CheckBox(name: String, defValue: Boolean): Filter<Boolean>(name, defValue)\n        open class Select<V>(name: String, state: Array<V>): Filter<Array<V>>(name, state)\n        open class Group<V>(name: String, state: List<V>): Filter<List<V>>(name, state)\n    }\n\n    class AdvancedOption(name: String, defValue: Boolean = false): Filter.CheckBox(name, defValue), UriFilter\n    class RatingOption : Filter.Select<String>(\"\", arrayOf(\"\")), UriFilter\n    class AdvancedGroup : Filter.Group<Filter<*>>(\"\", listOf(\n            AdvancedOption(\"\", true),\n            AdvancedOption(\"\", true),\n            AdvancedOption(\"\"),\n            AdvancedOption(\"\"),\n            AdvancedOption(\"\"),\n            AdvancedOption(\"\"),\n            AdvancedOption(\"\"),\n            AdvancedOption(\"\"),\n            RatingOption()\n    ))\n\n    companion object {\n        @JvmStatic fun main(args: Array<String>) {\n            val test = Huh.AdvancedGroup()\n            println(test.name)\n            println(test.state)\n        }\n    }\n}\n"
        },
        {
            "code": "\n// TODO: muted automatically, investigate should it be ran for JS or not\n"
        },
        {
            "code": "\nimport Foo.x\n\nobject Foo {\n    var x = 5\n}\n\nfun main(args: Array<String>) {\n    ++x // or x += 1\n}\n"
        },
        {
            "code": "\nclass A(val p: String) {\n    var pp = \"\"\n}\n\noperator fun A.plusAssign(s: String) {\n    pp = s\n}\n\nfun main(args: Array<String>) {\n    \"rrr\".let { A(it) } += \"aaa\"\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val name = \"John\"\n    val additionalName = \" Doe\"\n\n    println(\"${name}${additionalName}\")\n}\n"
        },
        {
            "code": "\n    val code = Integer(11)\n    val c = code.toChar()\n"
        },
        {
            "code": "\nclass X {\n    suspend fun execute() {\n        a()\n        b()\n    }\n\n    private suspend fun a() {}\n    private suspend fun b() {}\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(Charsets.UTF_8)\n}\n"
        },
        {
            "code": "\npackage ktor_receivedMessage\n\nimport kotlin.coroutines.experimental.Continuation\nimport kotlin.coroutines.experimental.CoroutineContext\nimport kotlin.coroutines.experimental.EmptyCoroutineContext\nimport kotlin.coroutines.experimental.startCoroutine\n\nprivate var prevSender: String = \"FAIL\"\n\nclass ChatServer {\n    suspend fun who(sender: String) {\n        prevSender = sender\n    }\n    suspend fun sendTo(recipient: String, sender: String, message: String) { }\n    suspend fun memberRenamed(member: String, to: String) { }\n    suspend fun help(sender: String) { }\n    suspend fun message(sender: String, message: String) { }\n}\n\nprivate val server = ChatServer()\n\nprivate suspend fun receivedMessage(id: String, command: String) {\n    when {\n        command.startsWith(\"/who\") -> server.who(id)\n        command.startsWith(\"/user\") -> {\n            val newName = command.removePrefix(\"/user\").trim()\n            when {\n                newName.isEmpty() -> server.sendTo(id, \"server::help\", \"/user [newName]\")\n                newName.length > 50 -> server.sendTo(id, \"server::help\", \"new name is too long: 50 characters limit\")\n                else -> server.memberRenamed(id, newName)\n            }\n        }\n        command.startsWith(\"/help\") -> server.help(id)\n        command.startsWith(\"/\") -> server.sendTo(id, \"server::help\", \"Unknown command ${command.takeWhile { !it.isWhitespace() }}\")\n        else -> server.message(id, command)\n    }\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(object : Continuation<Unit>{\n        override val context: CoroutineContext\n            get() = EmptyCoroutineContext\n\n        override fun resume(value: Unit) {\n        }\n\n        override fun resumeWithException(exception: Throwable) {\n            throw exception\n        }\n    })\n}\n\nfun main(args: Array<String>) {\n    builder {\n        receivedMessage(\"OK\", \"/who\")\n    }\n    println(prevSender)\n}\n"
        },
        {
            "code": "\nclass Foo {\n    companion object {\n        private val bar = \"\"\n    }\n\n    fun hello() {\n        println(bar)\n    }\n}\n"
        },
        {
            "code": "\nfun foo() {}\nval a = foo()\n"
        },
        {
            "code": "\nvar test = 0\n\nfun main(args: Array<String>) {\n    test++\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val x = 10\n    val y = 9\n    if(x == 6) {\n        if(y == 6) {\n            println(\"a\")\n        } else {\n            println(\"b\")\n        }\n    } else {\n        println(\"c\")\n    }\n}\n"
        },
        {
            "code": "\n//Test.kt\n\nfun main(args: Array<String>){\n  val list = listOf(1,2,3)\n  val four = list.first { it == 4 }\n  println(four)\n}\n"
        },
        {
            "code": "\nprivate val listVisitor =\n    { list: MutableList<Char>, action: (MutableList<Char>, Int) -> Unit ->\n        list.withIndex()\n            .reversed()\n            .filter { (_, c) -> c in '0'..'9' }\n            .forEach { (index, _) -> action(list, index) }\n    }\n"
        },
        {
            "code": "\nprivate val listVisitor =\n    { list: MutableList<Char>, action: (MutableList<Char>, Int) -> Unit ->\n                list.indices.reversed()\n                    .filter { list[it] in '0'..'9' }\n                    .forEach { action(list, it) }\n    }\n"
        },
        {
            "code": "\ndata class User(val name: String, val age: Int)\n"
        },
        {
            "code": "\nclass NeverNullMap<K, V>(private val backing: MutableMap<K, V> = mutableMapOf(), val default: () -> V): MutableMap<K, V> by backing {\n    override operator fun get(key: K): V = backing.getOrPut(key, default)\n}\n\nfun main(args: Array<String>) {\n    val myMap = NeverNullMap<String, Int> {0}\n    myMap[\"test\"] +=  10\n}\n"
        },
        {
            "code": "\nclass Test<K, V>(map: MutableMap<K, V>): MutableMap<K, V> by map\n\nfun main(args: Array<String>) {\n    val test = Test(mutableMapOf(1 to \"hello\"))\n    test[1] += \" there\"\n}\n"
        },
        {
            "code": "\nabstract class Base {\n    abstract var value: String\n        internal set\n}\n\nclass Derived : Base() {\n    override var value = \"hello\"\n}\n"
        },
        {
            "code": "\nclass A\n\nfun A.ext() {}\n\nclass B() {\n    fun some() {\n        A().ext()\n    }\n}\n"
        },
        {
            "code": "\nfun main(par:Array<String>){\n\tm@ val f = {\n\t\treturn@m\t\t// NoClassDefFoundError\n\t}\n\tf()\t\t\t\t\t\n}\n"
        },
        {
            "code": "\n// Run with -verbose:gc -Xmx20m\nfun main(args: Array<String>) {\n    while (true) {\n        (0..0).sumBy { it }\n    }\n}\n"
        },
        {
            "code": "\ninline fun f(noinline p:()->Unit) {\t\t// noinline parameter\n\tp()\n\tprintln(\"A\")\n}\nval v = {print(1)}\nfun main(par:Array<String>){\n\tf(v)\t\t\t\t\t\t\t\t// 1A - INLINED\n\tf(v)\t\t\t\t\t\t\t\t// 1A - INLINED\n}\n"
        },
        {
            "code": "\nclass Foo()\n"
        },
        {
            "code": "\nval array:Array<String> = arrayOf(\"1\", \"2\", \"3\")\n\nfun <T> Array<T>.getLength(): Int {\nreturn this.size\n}\n\nfun box(): String {\nif (array.getLength() != 3)\nreturn \"FAILURE\"\nreturn \"OK\"\n}\n"
        },
        {
            "code": "\ninline fun xassert(condition: Boolean, messageCallback: () -> Any = { \"Assertion failed\" }) {\n    if (!condition) {\n        throw AssertionError(messageCallback())\n    }\n}\n"
        },
        {
            "code": "\nclass A { companion object }\n"
        },
        {
            "code": "\npackage test\n\nabstract class Base(val x: Any?)\n\nclass Test {\n    companion object : Base(42)\n}\n"
        },
        {
            "code": "\nclass Foo {\n  fun run(i: Bar): Boolean {\n    return i == Bar.ONE // Use === to avoid call to Intrinsics.areEqual.\n  }\n}\n\nenum class Bar {\n  ONE\n}\n"
        },
        {
            "code": "\nimport java.util.Objects\n\nfun main(args: Array<String>) {\n    defineFunc<String>()\n\n    func(1)\n}\n\nvar func: (Any) -> Unit = {}\n\ninline fun <reified T> defineFunc() {\n    func = {\n        val nullable = it as? T\n\n        if (nullable == null)\n            println(\"== catched it\")\n\n        if (Objects.equals(nullable, null))\n            println(\"objects equals catched it\")\n    }\n}\n"
        },
        {
            "code": "\ninline fun <reified T: Number> function() {\n    (\"\" as? T)?.let { throw IllegalStateException(\"never thrown\") }\n    \n    val lambda = { arg: Any ->\n        (arg as? T)?.let { throw IllegalStateException(\"blows up, but shouldn't\") }\n    }\n    \n    lambda(\"\")\n}\n\nfun main(args: Array<String>) {\n    function<Float>()\n}\n"
        },
        {
            "code": "\npackage cg\n\nimport java.util.concurrent.Callable\n\nclass A {\n    fun f() {\n        listOf(1, 2, 3).forEach {\n            accept(object : Callable<Unit> {\n                override fun call() {\n                    if (Math.random() > 1) {\n                        println(\"ok\")\n                    } else {\n                        try {\n                            x()\n                        } catch(t: Throwable) {\n                        }\n                    }\n                }\n            })\n        }\n    }\n\n    private fun x() {}\n}\n\nfun accept(runnable: Callable<*>) {\n    runnable.call()\n}\n"
        },
        {
            "code": "\nabstract class C {\n\n    protected abstract fun ready(): Boolean\n    protected abstract suspend fun slow()\n\n    suspend fun optimized() {\n        if (!ready()) {\n            return slow()\n        }\n    }\n\n    suspend fun nonOptimized() {\n        when {\n            ready() -> {}\n            else -> slow()\n        }\n    }\n}\n"
        },
        {
            "code": "\nabstract class C {\n\n    protected abstract fun ready(): Boolean\n    protected abstract suspend fun slow()\n\n    suspend fun notOptimized1() {\n        if (ready()) {\n            return\n        } else {\n            slow()\n        }\n    }\n\n    suspend fun notOptimized2() {\n        if (ready()) {\n            return\n        }\n\n        slow()\n    }\n\n    suspend fun optimized() {\n        if (ready()) {\n            return\n        }\n\n        return slow() // notice return\n    }\n}\n"
        },
        {
            "code": "\n// WITH_RUNTIME\n\nfun testUnoptimized(): String {\n    var arr = intArrayOf(1, 2, 3, 4)\n    val sb = StringBuilder()\n    val ixs = arr.withIndex()\n    for ((i, x) in ixs) {\n        sb.append(\"$i:$x;\")\n        arr = intArrayOf(10, 20)\n    }\n    return sb.toString()\n}\n\nfun box(): String {\n    val tn = testUnoptimized()\n\n    var arr = intArrayOf(1, 2, 3, 4)\n    val sb = StringBuilder()\n    for ((i, x) in arr.withIndex()) {\n        sb.append(\"$i:$x;\")\n        arr = intArrayOf(10, 20)\n    }\n\n    val s = sb.toString()\n    if (s != \"0:1;1:2;2:3;3:4;\") return \"Fail: '$s'; unoptimized: '$tn'\"\n\n    return \"OK\"\n}\n"
        },
        {
            "code": "\nfun test(a: Boolean, b: Boolean, c: Boolean): Boolean {\n    return a      // line 42\n            && b  // line 43\n            && c  // line 44\n}\n"
        },
        {
            "code": "\nclass 𝔻 \noperator fun 𝔻.times(that: 𝔻): 𝔻 = 𝔻()\n"
        },
        {
            "code": "\nval strings = ArrayList<String>()\n\ninline fun String.onlyForNotNull() {\n    strings.add(this)\n}\n\nfun platformString() {\n    System.getProperty(\"unknown\").onlyForNotNull()\n}\n"
        },
        {
            "code": "\ninline fun String.onlyForNotNull(): Int {\n    println(\"precondition check passed\")\n    return this.length\n}\n"
        },
        {
            "code": "\nfun function(format: String, vararg args: Any?) = format.format(*args)\n"
        },
        {
            "code": "\nsuspend fun some() {}\n\nsuspend fun test() {\n    try {\n        some()\n    } finally {\n        some()\n    }\n}\n"
        },
        {
            "code": "\ninterface I {\n    fun foo()\n}\n\ninline fun bar(crossinline block: () -> Unit) {\n    object : I {\n        override fun foo() {\n            block()\n        }\n    }\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.KClass\n\ninline fun foo(crossinline f: () -> Unit = {}): KClass<*> {\n    val a = object {\n        val a: Any? = f()\n    }\n    return a::class\n}\n\nfun test1() = foo()\nfun test2() = foo()\n\nfun main(args: Array<String>) {\n    println(test1())\n    println(test2())\n\n    println(test1() === test2())\n    println(test1() === test1())\n}\n"
        },
        {
            "code": "\nsuspend fun test(onFail: suspend () -> Unit) {\n  return onFail()\n  return onFail()\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.*\n\nsuspend fun suspendThere(v: A): A = suspendCoroutineOrReturn { x ->\n    x.resume(v)\n    COROUTINE_SUSPENDED\n}\n\nclass A(val value: String) {\n    operator suspend fun plus(other: A) = suspendThere(A(value + other.value))\n}\n\nfun builder(c: suspend () -> Unit) {\n    c.startCoroutine(object: Continuation<Unit> {\n        override val context: CoroutineContext\n            get() = TODO(\"not implemented\") //To change initializer of created properties use File | Settings | File Templates.\n\n        override fun resume(value: Unit) {\n            TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n        }\n\n        override fun resumeWithException(exception: Throwable) {\n            TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n        }\n    })\n}\n\n\nfun box(): String {\n    var a = A(\"O\")\n\n    builder {\n        a += A(\"K\")\n    }\n\n    return a.value\n}\n\n"
        },
        {
            "code": "\nsuspend fun firstFun() {}\nsuspend fun secondFun() {  firstFun() }\n"
        },
        {
            "code": "\ninline fun ifNotNull(a: Any?) {\n    if (a != null) {\n        println(\"not null\")\n    }\n}\n\nfun test() {\n    val a: String = System.getProperty(\"zzz\")\n    ifNotNull(a)\n}\n"
        },
        {
            "code": "\npublic class Query {}\n"
        },
        {
            "code": "\nopen class A {\n    var parent = \"default value\"\n\n    constructor(parent: String?, state: Int)\n}\n\nclass Foo {\n    inner class B : A {\n        constructor(parent: String?, state: Int) : super(parent, state){\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    println(Foo().B(\"ppp\", 123).parent)\n}\n"
        },
        {
            "code": "\nimport Test.Companion.num\n\nclass Test{\n  companion object {\n    var num = 0\n  }\n}\n\nfun main(args: Array<String>){\n  num++    //error here\n  Test.num++\n}\n"
        },
        {
            "code": "\nfun foo(x: Int, y: Int = 0) {}\n"
        },
        {
            "code": "\ninterface Test {\n    fun methodWithImpl(parameterName: String) {\n        println(\"test\")\n    }\n}\n\nfun main(args: Array<String>) {\n    println(\n            Class.forName(\"Test\\$DefaultImpls\").declaredMethods\n                    .flatMap { it.parameters.asList() }\n                    .map { it.name }\n    )\n}\n"
        },
        {
            "code": "\npackage testinline\n\nclass DomainException(override val message: String = \"\"): Throwable(message)\n\ninline fun verify(test: Boolean, lazyMessage: ()->Any = { \"\" }) {\n    if(!test) {\n        throw DomainException(lazyMessage().toString())\n    }\n}\n\nfun main(args: Array<String>) {\n    verify(true)\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.KClass\nimport kotlin.reflect.jvm.javaType\n\nfun main(args: Array<String>) {\n    println(\"not nullable : \" + object : Type<String> {}.name)\n    //    not nullable : String\n    println(\"nullable : \" + object : Type<String?> {}.name)\n    //    nullable : String?\n    println(\"inline not nullable : \" + Type.of<String>().name)\n    //    inline not nullable : String\n    println(\"inline nullable : \" + Type.of<String?>().name)\n    //    inline nullable : String\n}\n\ninterface Type<T> {\n    companion object {\n        inline fun <reified T> of() = object : Type<T> {}\n    }\n\n    val nullable: Boolean\n        get() = extractType().isMarkedNullable\n\n    val type: Class<T>\n        get() = Class.forName(extractType().javaType.typeName) as Class<T>\n\n    val name: String get() = type.simpleName + if (nullable) \"?\" else \"\"\n\n    private fun extractType() = this::class.supertypes\n            .first { it.classifier.let { it is KClass<*> && it.java == Type::class.java } }\n            .arguments[0].type!!\n}"
        },
        {
            "code": "\nclass MyThrowable : Throwable {\n    constructor() : super()\n    constructor(cause: Throwable?) : super(cause)\n}\n\nfun main(args: Array<String>) {\n    println(MyThrowable().message)\n    println(MyThrowable(cause = null).message)\n}\n// prints:\n// undefined\n// undefined\n"
        },
        {
            "code": "\ninterface A {\n    var bar: Boolean\n        get() = false\n        set(value) { throw AssertionError(\"Fail set\") }\n}\n\ninterface B : A\n\ninterface C : A {\n    override var bar: Boolean\n        get() = true\n        set(value) {}\n}\n\ninterface D : B, C\n\nclass Impl : D\n\nfun box(): String {\n    Impl().bar = false\n    if (!Impl().bar) return \"Fail get\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "\nclass X {\n    fun x() {\n        listOf<Any>().map(::y)\n    }\n    fun y(a: Any) {\n    }\n}\n"
        },
        {
            "code": "\nimport java.io.ByteArrayInputStream\nimport java.io.InputStream\nimport kotlin.properties.ReadOnlyProperty\nimport kotlin.reflect.KProperty\n\nobject DataSourceObject {\n    fun dataValue() = ByteArray(1)\n}\n\nobject DataSourceCache {\n    val dataValue by LazyStream()\n\n    private class LazyStream : ReadOnlyProperty<Any, InputStream> {\n        private lateinit var value: ByteArray\n\n        override fun getValue(thisRef: Any, property: KProperty<*>): InputStream {\n            synchronized(lock) {\n                if (!this::value.isInitialized) {\n                    val source = DataSourceObject::class.java.getDeclaredMethod(property.name)\n                    value = source.invoke(DataSourceObject) as ByteArray\n                }\n            }\n\n            return ByteArrayInputStream(value)\n        }\n    }\n\n    private val lock = Any()\n}\n"
        },
        {
            "code": "\nimport kotlin.Double.Companion.POSITIVE_INFINITY\n\nfun main(args: Array<String>) {\n    println(POSITIVE_INFINITY)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(Double.POSITIVE_INFINITY)\n}\n"
        },
        {
            "code": "\npackage alraune\n\nobject BloodyBug {\n    // If `doStuff` function is commented out, stuff works\n    fun doStuff(f: () -> Unit = {}) = DoStuff()\n\n    class DoStuff(f: () -> Unit = {})\n\n    @JvmStatic fun main(args: Array<String>) {\n        DoStuff {}    ; println(\"First works\")\n        DoStuff()     ; println(\"Second works\")\n    }\n}\n"
        },
        {
            "code": "\npackage bug\n\nimport bug.Position.woops\nimport bug.Position.ok\n\nobject Position\n{\n  var woops: Int = 0\n  var ok: Int = 0\n}\n\nfun error()\n{\n  woops += 0\n}\n\nfun worksFine()\n{\n  Position.ok += 0\n}\n"
        },
        {
            "code": "\nobject obj {\n    var variable:Int = 0\n}\n"
        },
        {
            "code": "\nopen class ClickEvent(val callback: () -> Unit) {\n    fun doThings() {\n        callback()\n    }\n}\n\nclass Foo {\n    val myString: String = \"\"\n\n    private inner class BarClickEvent : ClickEvent({\n        myString.length // This errors out\n    })\n}\n"
        },
        {
            "code": "\npackage test\n\nclass Top(val x: String) {\n    open class In1(val f: () -> String)\n\n    inner class In2 : In1({ x })\n\n    fun test() = In2().f()\n}\n\nfun main(args: Array<String>) {\n    Top(\"OK\").test()\n}\n"
        },
        {
            "code": "\nclass TestClass {\n    fun `test name with spaces`() {\n        data class MyClass(val blah:String)\n    }\n}\n"
        },
        {
            "code": "\nenum class E(val a: String? = null) { // removing \"a\" argument fixes the problem\n    A { // changing to A() fixes the problem\n        override fun f() = \"\" // removing overridden method fixes the problem\n    };\n\n    open fun f() = \"\"\n}\n\nfun main(args: Array<String>) {\n    E.A // generates java.lang.NoSuchMethodError: integration.E: method <init>(Ljava/lang/String;I)V not found\n}\n"
        },
        {
            "code": "\ninline fun foo(f: () -> String): () -> String {\n    val result = f()\n    return { result }\n}\n"
        },
        {
            "code": "\nimport java.util.concurrent.Executors\n\nfun main(args: Array<String>) {\n    val executor = Executors.newSingleThreadExecutor()\n    val execute: (() -> Unit) -> Unit = executor::execute\n    val function = { }\n    execute(function)\n}\n"
        },
        {
            "code": "\nclass X {\n    fun foo(y: Y) {}\n}\n\nsealed class Y\n\nclass Z(val x: X) : Y() {\n    fun bar() {\n        x.foo(this)\n    }\n}\n"
        },
        {
            "code": "\nsuspend fun sid(v: String): String = v\n\ninline suspend fun foo(): String {\n    println(sid(\"1\"))\n    println(sid(\"2\"))\n    return \"OK\"\n}\n\nsuspend fun bar(): String {\n    println(\"before\")\n    return foo()\n}\n"
        },
        {
            "code": "\nsuspend fun <T> foo(v: T): T = v\n\ninline suspend fun boo(v: String): String {\n    foo(\"!$v\")\n    return foo(v)\n}\n\ninline suspend fun bar(v: String) {\n    val x = boo(v)\n    println(\"bar($x)\")\n}\n"
        },
        {
            "code": "\nobject\nnumber\n"
        },
        {
            "code": "\nclass FunRefTest() {\n    fun someFun() {}\n}\n\nfun test(ref: () -> Unit) {\n    println(ref::class.java)\n}\n\nfun main(args: Array<String>) {\n    val test = FunRefTest()\n    test(test::someFun)\n    test(test::someFun)\n}\n"
        },
        {
            "code": "\nopen class Base(val callback: () -> String)\n\nclass Outer {\n    val ok = \"OK\"\n\n    inner class Inner : Base {\n        constructor() : super({ ok })\n    }\n}\n\nfun box(): String =\n        Outer().Inner().callback()\n"
        },
        {
            "code": "\nval a by lazy {\n    1\n}\n\nfun main(args: Array<String>) {\n \tval b by lazy {\n    \t2\n\t}   \n    \n    println(a)\n    println(b)\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.*\n\nobject Ddd {\n    operator fun getValue(thisRef: Any?, p: KProperty<*>): Any {\n        println(\"get\")\n        return 1\n    }\n}\n\nval b by Ddd\n\nfun main(args: Array<String>) {\n    val a by Ddd\n    println(a)\n    println(a)\n    println(b)\n    println(b)\n}\n"
        },
        {
            "code": "\nclass A(var x: Char) {\n    var y: Char = '0'\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val a = object : A {}\n    val c = object : C {}\n    println(a.greet())\n    println(a.greet(\"world\"))\n    println(c.greet())  // <-- crashes here\n    println(c.greet(\"world\"))\n}\n\ninterface A {\n    fun greet(name: String = \"everybody\"): String = \"Hello, $name!\"\n}\n\ninterface B : A {\n    override fun greet(name: String): String\n}\n\ninterface C : B {\n    override fun greet(name: String): String = \"Hi, $name!\"\n}\n"
        },
        {
            "code": "\nfun foo() {\n    bar {\n        try {\n            baz()\n        }\n        catch (e: RuntimeException) {\n            e.toString()\n        }\n    }\n\n    bar {\n        when (boo()) {\n            \"boo\" -> baz()\n            else -> \"111\"\n        }\n    }\n}\n\ninline fun bar(x: () -> String): String {\n    return x()\n}\n\nfun baz() = \"baz\"\n\nfun boo() = \"boo\"\n\nfun main(args: Array<String>) {\n    foo()\n}\n"
        },
        {
            "code": "\nfun foo() {\n    bar { it?.baz() }\n}\n\nfun bar(x: suspend (A?) -> Unit) {}\n\nclass A {\n    suspend fun baz() {}\n}\n"
        },
        {
            "code": "\nfun foo(x: Int) {\n    println(when (x) {\n        1 -> \"one\"\n        2 -> \"two\"\n        else -> \"many\"\n    })\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val a = object : A {}\n    val b = object : B {}\n    println(a.greet())\n    println(a.greet(\"world\"))\n    println(b.greet())\n    println(b.greet(\"world\"))\n}\n\ninterface A {\n    fun greet(name: String = \"everybody\"): String = \"Hello, $name!\"\n}\n\ninterface B : A {\n    override fun greet(name: String): String = \"Hi, $name!\"\n}\n"
        },
        {
            "code": "\ninterface My {\n    fun foo()\n    suspend fun foos()\n}\n\nclass Your : My {\n    override fun foo() {}\n    suspend override fun foos() {}\n}\n"
        },
        {
            "code": "\nopen class Base(o: Any)\n\nopen class Outer {\n    open inner class Inner\n\n    inner class JavacBug : Base(object : Outer.Inner() {})\n}\n\nfun main(args: Array<String>) {\n    Outer().JavacBug()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val dbl = 1.toDouble()\n    println(\"M$dbl\") \n    println(moveTo(1.toDouble()))  \n}\nfun moveTo(x:Double) = \"M$x\"\n"
        },
        {
            "code": "\ninterface I {\n    fun foo(x: Int = 23)\n}\n\nabstract class Base : I\n\nclass C : Base() {\n    override fun foo(x: Int) {\n        println(\"C:$x\")\n    }\n}\n\nfun bar(x: I) {\n    x.foo()\n    x.foo(42)\n}\n\nfun main(args: Array<String>) {\n    bar(C())\n}\n"
        },
        {
            "code": "\nenum class Gender {\n    MALE, FEMALE\n}\n\ninline fun postInline(block: () -> Unit) = block()\n\nfun post(block: () -> Unit) = block()\n\nfun main(args: Array<String>) {\n    postInline { enumValueOf<Gender>(\"MALE\") }\n    post { enumValueOf<Gender>(\"MALE\") }\n}\n"
        },
        {
            "code": "\nfun foo(a: () -> Boolean, b: () -> Boolean) {\n    println(a() or b())\n}\n"
        },
        {
            "code": "\ntypealias ArrayB = Array<Boolean>\n\nfun foo(): Boolean {\n    val ba = ArrayB(1) { return true }\n    \n    return false\n}\n\nfun bar(): Boolean {\n    val ba = Array<Boolean>(1) { return true }\n    \n    return false\n}\n\nfun main(args: Array<String>) {\n    println(foo())\n    println(bar())\n}\n"
        },
        {
            "code": "\nfun main(args : Array<String>) {\n    val testObject = Test()\n    testObject.testFunction() // Line 3\n}\n\nclass Test {\n    inline fun testFunction(): Unit = null!! // Line 7\n}\n// Line 9 (empty)\n"
        },
        {
            "code": "\ninterface IDemo {\n    val Int.twice get() = this * 2\n}\n\nopen class Demo {\n    val Int.twice get() = this * 2\n}\n\n//class MyDemo : Demo() { // WORKS\nclass MyDemo : IDemo { // FAILS\n    fun yay() {\n        println(10.twice)\n    }\n}\n\nfun main(args: Array<String>) {\n    val demo = MyDemo()\n    demo.yay()\n}\n"
        },
        {
            "code": "\nenum class Foo(val bar: String, val closure: () -> String) {\n    VALUE(\"Hello\", {\n        VALUE.bar\n    })\n}\n"
        },
        {
            "code": "\nclass Foo {\n    lateinit var bar: String\n\n    fun callable(): Boolean = true\n\n    fun test(): Boolean {\n        if (!::bar.isInitialized) {\n            bar = \"a\"\n            return false\n        }\n        return (::callable)()\n    }\n}\n\nfun main(args: Array<String>) {\n    val foo = Foo()\n    println(foo.test())\n    println(foo.bar)\n}\n"
        },
        {
            "code": "\nimport java.io.File\n\nfun main(args: Array<String>) {\n    val file1 = File(\"\")\n\n    val filesMap = arrayListOf<Map<File, String>>()\n    fun X.filesMap(): Map<File, String> =\n            files.associateBy({ file1 }, { \"\" })\n\n    X(listOf(file1)).apply {\n        filesMap.add(filesMap())\n    }\n}\n\nprivate class X(val files: Iterable<File>)\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val env = Pair(0, 0)\n    fun point(z: Int) = env.first\n    fun point() = point(0)\n\n    arrayOf(10).forEach {\n        point()\n        point(0)\n    }\n}\n"
        },
        {
            "code": "\npackage bug\n\nopen class A {\n    val foo: Int = 0\n    var bar: Int = 0\n}\n\nclass B : A() {\n    fun test() {\n        super.foo\n        super.bar\n        super.bar = 2\n    }\n }\n\nfun main(args: Array<String>) {\n    B().test()\n}\n"
        },
        {
            "code": "\ninterface A {\n    companion object {\n        private val instance: A? = null\n\n        fun getInstance(): A = instance!!\n    }\n}\n"
        },
        {
            "code": "\nclass A {\n    override fun equals(o: Any?) = super.equals(o)\n    override fun hashCode() = super.hashCode()\n}\n\nfun main(args: Array<String>) {\n    val a = A()\n    val b = A()\n\tprintln(a == a)\n\tprintln(a == b)\n\tprintln(a.hashCode())\n\tprintln(b.hashCode())\n}\n"
        },
        {
            "code": "\nenum class Foo {\n  A;\n  \n  object d {\n    val a = A\n    val b = println(\"1\")\n  }\n    \n  companion object {\n    val a = A\n    val b = println(\"2\")\n  }\n}\n\nfun main(args : Array<String>) {\n  println(Foo.d.a)\n  println(Foo.A)\n}\n"
        },
        {
            "code": "\nopen class A {\n    fun constructor() : Int {\n        println(\"fun\")\n        return 42\n    }\n    init {\n        println(\"init\")\n    }\n}\nclass B : A()\n\nfun main(args: Array<String>) {\n\n    val b = B()\n    val res = b.constructor()\n    println(res)\n\n}\n"
        },
        {
            "code": "\nclass A {\n    companion object prototype\n}\nclass B { \n    object prototype\n}\n"
        },
        {
            "code": "\nclass A {\n    inner class length\n}\n\nfun main(args: Array<String>) {\n    val a= A()\n    println(a.length())\n}\n"
        },
        {
            "code": "\npackage test\n\nclass C {\n    lateinit var zz: String\n\n    fun test() = ::zz.isInitialized\n}\n"
        },
        {
            "code": "\nopen class A(c: Char) {\n    open val c: Char = c\n    fun foo(): Char = 'a'\n    open fun bar(): Char = 'a'\n}\n\ninterface B {\n    val c: Any\n    fun foo(): Any\n    fun bar(): Char\n}\n\nclass C(c: Char) : A(c), B\n\nfun main(args: Array<String>) {\n    val b = (C('c') as B)\n    println(b.c)\n    println(b.foo())\n    println(b.bar())\n}\n"
        },
        {
            "code": "\nfun main(args : Array<String>) {\n    println(Double.MAX_VALUE.toInt())\n    println(Double.MIN_VALUE.toInt())\n    println(Double.NaN.toInt())\n    println(Double.POSITIVE_INFINITY.toInt())\n    println(Double.NEGATIVE_INFINITY.toInt())\n}\n"
        },
        {
            "code": "\ndata class SomeClass(val unit: Unit)\n\ninline fun inlining(block: () -> Unit) {\n    SomeClass(block())\n}\n\nfun noop() {\n}\n\nfun function() {\n    inlining(::noop)\n}\n"
        },
        {
            "code": "\nimport java.util.function.Supplier\n\nfun testSupplier(message: () -> String) {\n    Supplier(message)\n}\n"
        },
        {
            "code": "\nimport java.util.function.Supplier\n\nfun testSupplier(message: () -> String) {\n    Supplier { message() }\n}\n"
        },
        {
            "code": "\nclass TestClass<out T : Any>(@get:JvmName(\"renamedGetter\") val value : T?)\n"
        },
        {
            "code": "\nclass A {\n    val prop: Int\n    constructor(arg: Boolean) {\n        if (arg) {\n            prop = 1\n            run { return }\n            throw RuntimeException(\"fail 0\")\n        }\n        prop = 2\n    }\n}\n"
        },
        {
            "code": "\nclass A {\n    lateinit var a: Any\n}\n\nfun main(args: Array<String>) {\n    println(\"a = \" + A().a)\n}\n"
        },
        {
            "code": "\nval funcReference = ::func\n\nfun func(): Any = true\n\nfun main(args: Array<String>) {\n    val output = funcReference.invoke()\n    when {\n        output is Unit -> print(true)\n        output::class != Boolean::class -> throw Exception()\n        // Here\n        else -> printBool(output as Boolean)\n    }\n}\n\nfun printBool(bool: Boolean) {\n    println(bool)\n}\n"
        },
        {
            "code": "\npackage a\n\nopen class A<T> {\n    protected fun getOK(x: T) = \"OK\"\n}\n"
        },
        {
            "code": "\npackage test\n\nfun foo(vararg xs: Int) {}\n\nfun test() = foo(*intArrayOf(1, 2, 3, 4))\n"
        },
        {
            "code": "\nfun isMutedOn1(emails: List<String>) : Map<String, Boolean> {\n    val mutedEmails = setOf<String>()\n    return emails.associate { it to (it in mutedEmails) }\n}\n"
        },
        {
            "code": "\nfun isMutedOn2(emails: List<String>) : Map<String, Boolean> {\n    val mutedEmails = setOf<String>()\n    return emails.associate { it to mutedEmails.contains(it) }\n}\n"
        },
        {
            "code": "\nval strSet = setOf<String>()\n\nfun xTo(s: String) = s to (s in strSet)\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    0.0f in 0.0f.rangeTo(1.0f)\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.intrinsics.COROUTINE_SUSPENDED\nimport kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn\n\ninline suspend fun suspendThere(v: String): String = suspendCoroutineOrReturn { x ->\n    x.resume(v)\n    COROUTINE_SUSPENDED\n}\n\nsuspend fun complexSuspend(): String {\n    return run { return suspendThere(\"K\") }\n}\n\n"
        },
        {
            "code": "\nfun <T> foo (t : T) : Unit {\n    println(\"$t$t\")\n}\n\nfun bar (i : Int) : Unit {\n    println(\"$i$i\")\n}\n\nfun baz (a : Any) : Unit {\n    println(\"$a$a\")\n}\n\nfun main(args: Array<String>) {\n    foo(21)\n    bar(21)\n    baz(21)\n}\n"
        },
        {
            "code": "\nimport java.lang.ref.WeakReference\n\nfun main(args: Array<String>) {\n    val list = mutableListOf<WeakReference<Any>>()\n    \n    for (i in 1..3) {\n        val obj = Any()\n        list.add(WeakReference(obj))\n    }\n    \n    Runtime.getRuntime().gc()\n    Runtime.getRuntime().runFinalization()\n    Runtime.getRuntime().gc()\n    \n    list.forEach {\n        println(it.get().toString())\n    }\n}\n"
        },
        {
            "code": "\nfun foo() {\n    val x = 1\n    class A {\n        val a = x\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    for (mx in -100L..100) {\n        println(mx)\n    }\n}\n"
        },
        {
            "code": "\nclass Foo : List<String> by emptyList()\n"
        },
        {
            "code": "\nsuspend fun foo() {}\nsuspend fun bar() {\n    return foo()\n}\n"
        },
        {
            "code": "\nfun main(args : Array<String>) {\n    for(i in 10 downTo 0 step 2) {}\n    for(i in 1..20 step 2) {}\n    \n    val p = 1..2\n    for(i in p) {}\n    \n    val p2 = 1..2 step 2\n    for(i in p2) {}\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val (a) = Pair(1, 2)\n    // val (*, b) = Pair(1, 2) // not yet supported\n}\n"
        },
        {
            "code": "\nfun g() {\n    println(\"Something\")\n}\n\nfun main(args: Array<String>) {\n\n    val d = g()\n    println(d)\n    val u = Unit\n    println(u)\n    if (u==d) {\n        println(\"Yes\")\n    } else {\n        println(\"No\")\n    }\n    \n}\n"
        },
        {
            "code": "\npackage foo\n\nopen class Foo {\n    internal inline fun bar(noinline bazz: () -> Unit = {}) {\n    }\n}\n"
        },
        {
            "code": "\nclass Test {\n  internal inline fun test(noinline fn: () -> Unit = {}) = Unit\n}\n"
        },
        {
            "code": "\nval flag = true\n\nfun box(): String {\n  val test = if (flag) {} else Unit\n  return if (test == Unit) \"OK\" else \"Fail: $test\"\n}\n"
        },
        {
            "code": "\nfun test1(): Unit = Unit\n//returns 'undefined'\n//  test1: function () {\n//      Kotlin.kotlin.Unit;\n//  }\n\nfun test2(): Unit? = test1()\n//returns 'undefined'\n//  test2: function () {\n//      return _.test.test1();\n//  }\n\nfun test3(): Unit? = Unit\n//returns 'kotlin.Unit'\n//  test3: function () {\n//      return Kotlin.kotlin.Unit;\n//  }\n"
        },
        {
            "code": "\npackage test\n\nclass C {\n    fun foo() {}\n}\n\nfun test(nc: C?) =\n        nc?.foo()\n"
        },
        {
            "code": "\nfun test() {\n    for (i in 1..5) {\n\t\tval a = if (i%2==0) {/*EMPTY!*/} else {i}\n        println(a)\n    }\n}\n"
        },
        {
            "code": "\nfun test() {\n    for (i in 1..5) {\n\t\tval a = foo(i)\n        println(a)\n    }\n}\ninline fun foo(i : Int) = if (i%2==0) {/*EMPTY!*/} else {i}\n"
        },
        {
            "code": "\nval nx: Any? = '0'\n\nfun box(): String =\n        when {\n            '0' != nx -> \"Fail 0\"\n            else -> \"OK\"\n        }\n"
        },
        {
            "code": "\nfun bar(i: Int) {\n    //do nothing\n}\n\nfun foo1() {\n    for (i in 1..10) {\n        bar(i)\n    }\n}\n\nfun foo2() {\n    for (i in (1..10)) { // difference only in parentheses\n        bar(i)\n    }\n}\n\nfun main(args: Array<String>) {\n    foo1()\n    foo2()\n}\n"
        },
        {
            "code": "\nvar l = \"\"\n\nfun log(message: String) {\n    l += message + \";\"\n}\n\nfun baz(x: String){\n    log(\"baz($x)\")\n}\nfun baz(x: String, i: Int) {\n    log(\"baz($x, $i)\")\n}\n\ninline fun bar() {\n    boo {\n        baz(\"AAA\")\n        foo()\n    }\n}\n\nfun boo(x: () -> Unit) = x()\n\ninline fun foo() {\n    log(\"foo()\")\n    baz(\"BBB\", 333)\n}\n\nfun box(): String {\n    bar()\n    if (l != \"baz(AAA);foo();baz(BBB, 333);\") return \"fail: $l\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "\npackage test\n\nfun main(args: Array<String>) {\n    System.getProperty(\"yay\").length\n}\n"
        },
        {
            "code": "\ninline fun Double.foo(f: (Double) -> Double): Double {\n    return f(this)\n}\n\nfun bar() {\n    0.5.foo(if (true) Math::ceil else Math::floor)\n}\n"
        },
        {
            "code": "\ninline fun Double.foo(f: (Double) -> Double): Double {\n    return f(this)\n}\n\nfun bar(f: (Double) -> Double) {\n    0.5.foo(f)\n}\n"
        },
        {
            "code": "\npackage c\n\nfun c() {}\n"
        },
        {
            "code": "\nprivate fun nullable(): Int? = null\nprivate fun otherwise(): Int = 1\nprivate fun inc(i: Int) = i + 1\n\nprivate fun letElvis(): Int =\n    nullable()?.let { inc(it) } ?: otherwise()\n\nprivate fun ifElse(): Int {\n  val nullable = nullable()\n  return if (nullable != null) inc(nullable)\n  else otherwise()\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    foo(1)\n}\n\ninline fun <reified T : Any> foo(arg: T) {\n    val intClass = Int::class\n    println(T::class == Int::class.java)\n    println(T::class == intClass) \n//     when (null) { Int::class.java, intClass -> { println(\"hello\") } }\n    println(T::class == intClass)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    foo(1)\n}\n\ninline fun <reified T : Any> foo(arg: T) {\n    println(T::class == Int::class.java)\n    println(T::class == Int::class)\n    when (T::class) { Int::class.java, Int::class -> { println(\"hello\") } }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(42.doSwitchInt()) // blam!\n    println(\"\".doSwitchString()) // success\n}\n\ninline fun <reified E> E.doSwitchInt(): String = when(E::class) {\n    Int::class -> \"success!\"\n    else -> \"blam!\"\n}\n\ninline fun <reified E> E.doSwitchString(): String = when(E::class) {\n    String::class -> \"success!\"\n    else -> \"blam!\"\n}\n"
        },
        {
            "code": "\ninline fun bar(crossinline f: () -> Int) = { f() }\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val b = B()\n\n    println(b.getFooA())\n    println(b.getFooB())\n    println(b.getBarA())\n    println(b.getBarB())\n}\n\nopen class A {\n    open val foo by lazy {\n        \"A.foo\"\n    }\n\n    private val bar by lazy {\n        \"A.bar\"\n    }\n\n    fun getBarA() = bar\n}\n\nclass B : A() {\n    override val foo by lazy {\n        \"B.foo\"\n    }\n\n    private val bar by lazy {\n        \"B.bar\"\n    }\n\n    fun getFooB() = foo\n    fun getFooA() = super.foo\n    fun getBarB() = bar\n}\n"
        },
        {
            "code": "\nimport java.util.*\n\nclass MySet : TreeSet<Int>() {\n    override fun remove(element: Int): Boolean {\n        return super.remove(element)\n    }\n}\n\nfun main(args: Array<String>) {\n    MySet()\n}\n"
        },
        {
            "code": "\nopen class A<T> {\n\n    inline suspend fun foo() {\n        bar()\n    }\n}\n\nsuspend fun bar() {\n    TODO()\n}\n\nsuspend fun A<Unit>.baz() = foo()\n"
        },
        {
            "code": "\nfun foo(): Boolean {\n    val map: Map<String, Boolean>? = mapOf()\n    return map?.get(\"\") == true\n}\n"
        },
        {
            "code": "\ndata class ThingsData(val things: List<Thing>) \n{\n  // synthetic property\n  val hasTrueThing get() = things.firstOrNull()?.field == true\n}\n\ndata class Thing(val field: Boolean?)\n\nfun main(args: Array<String>) {\n    val testData = ThingsData(things = listOf(Thing(null)))\n    println(testData.hasTrueThing) // <-- crashes here\n}\n"
        },
        {
            "code": "\nfun tryMe() {\n    try {\n        println(\"I'm trying...\")\n    } finally {\n        println(\"Done trying\")\n    }\n}\n"
        },
        {
            "code": "\npublic inline fun String.indexOf(ch : Char): Int = indexOf(ch.toString())\n"
        },
        {
            "code": "\nobject Singleton {\n    @JvmField val INSTANCE = \"42\"\n}\n"
        },
        {
            "code": "\ninterface MyInterface {\n    fun something() {\n        val thing by lazyOf(1)\n    }\n}\n"
        },
        {
            "code": "\nclass PrivateVarInline {\n    @Volatile\n    private var state: Int = 0\n    \n    private inline fun loopOnState(block: (Int) -> Unit) {\n        while (true) {\n            block(state)\n        }\n    }\n}\n"
        },
        {
            "code": "\ninterface A\ninterface B\n\nclass C1 : A, B\nclass C2 : A, B\n\nopen class SomeClass(a: A)\n\nclass SomeOtherClass : SomeClass(if (true) C1() else C2())\n\nfun main(args: Array<String>) {\n    SomeOtherClass()\n}\n"
        },
        {
            "code": "\npackage test\n\nopen class Base {\n    @JvmField val x = \"O\"\n}\n\nclass Host: Base() {\n    fun foo() = bar(x)\n\n    companion object {\n        val x = \"K\"\n\n        fun bar(s: String) = s + x\n    }\n}\n\nfun main(args: Array<String>) {\n    println(Host().foo())\n}\n"
        },
        {
            "code": "\nabstract class Base(params: Array<Any>)\n\nclass Derived() : Base(arrayOf(1))\n"
        },
        {
            "code": "\nabstract class Base(params: Array<Any> = emptyArray())\n"
        },
        {
            "code": "\nabstract class Base(val params: Array<Any> = emptyArray())\n\nclass Derived() : Base(arrayOf(1))\n\nfun main(args: Array<String>) {\n    println(Derived().params.contentToString()) // prints \"[]\"\n}\n"
        },
        {
            "code": "\npackage test\n\nclass Service {\n    private val disposable = \"\"\n\n    fun doSomeWork() {\n        apply {\n            println(disposable.length)\n        }\n    }\n\n    companion object {\n        val disposable = 5\n    }\n}\n\nfun main(args: Array<String>) {\n    Service().doSomeWork()\n}\n"
        },
        {
            "code": "\nimport Foo.bar0 as bar\n\nobject Foo {\n    val bar0 = \"OK\"\n\n    fun test() = bar\n}\n\nfun main(args: Array<String>) {\n    println(Foo.test())\n}\n"
        },
        {
            "code": "\ntypealias NumberType = Double\n\ninline fun Number.toNumberType() = when (NumberType::class) {\n    Double::class -> this.toDouble() as NumberType\n    Float::class -> this.toFloat() as NumberType\n    Long::class -> this.toLong() as NumberType\n    Int::class -> this.toInt() as NumberType\n    Short::class -> this.toShort() as NumberType\n    Byte::class -> this.toByte() as NumberType\n    else -> throw IllegalArgumentException(\"NumberType must be in [Double, Float, Long, Int, Short, Byte]\")\n}\n"
        },
        {
            "code": "\nfun test(p: Pair<Int, Int>) {\n    val (x, y) = p\n//  ACONST_NULL\n//  ASTORE 3    \n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    var s: String? = \"abc\"\n    println(s + \"d\")\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val map = hashMapOf<String, String>()\n    map[\"foo\"] += \"bar\"\n} \n"
        },
        {
            "code": "\npackage test\n\nfun someCondition(): Boolean? = true\n\nfun test() {\n    if (someCondition() ?: false) { // *\n        println(\"true\")\n    }\n}\n"
        },
        {
            "code": "\npackage test\n\nfun someCondition(): Boolean? = true\n\nfun test() {\n    if (someCondition() == true) {\n        println(\"true\")\n    }\n}\n"
        },
        {
            "code": "\nopen class KFoo {\n    fun foo(): String {\n        if (this is KFooQux) return qux\n        throw AssertionError()\n    }\n}\n\nclass KFooQux : KFoo()\nval KFooQux.qux get() = \"OK\"\n\nfun main(args: Array<String>) {\n    println(KFooQux().foo())\n}\n"
        },
        {
            "code": "\nfun eval(x: Int, message: String): Int {\n    println(message)\n    return x\n}\n\nfun main(args: Array<String>) {\n    if (0 in eval(1, \"low-1\") .. eval(100, \"high-1\"))\n        println(\"yes\")\n    else\n        println(\"no\")\n\n    if ((eval(1, \"low-2\") .. eval(100, \"high-2\")).contains(0))\n        println(\"yes\")\n    else\n        println(\"no\")\n\n    if (0 >= eval(1, \"low-3\") && 0 <= eval(100, \"high-3\"))\n        println(\"yes\")\n    else\n        println(\"no\")\n}\n"
        },
        {
            "code": "\nfun test(x: Int, a: Any) = x == a\n"
        },
        {
            "code": "\npackage test\n\nfun foo(): Any? = 42L\n\nfun test() {\n    val b = foo()\n    if (b is Long && b == 42L) {\n        println(\"magic!\")\n    }\n}\n"
        },
        {
            "code": "\nfun test() {\n    val s = \"\"\n}\n"
        },
        {
            "code": "\nprivate fun when1(number: Int) = when (number) {\n\t0 -> \"zero\"\n\t1 -> \"one\"\n\telse -> \"other\"\n}\n\nprivate fun when2(number: Int): String {\n\treturn when (number) {\n\t\t0 -> \"zero\"\n\t\t1 -> \"one\"\n\t\telse -> \"other\"\n\t}\n}\n\nprivate fun when3(number: Int): String {\n\twhen (number) {\n\t\t0 -> return \"zero\"\n\t\t1 -> return \"one\"\n\t\telse -> return \"other\"\n\t}\n}\n"
        },
        {
            "code": "\nprivate fun if1(number: Int) = if (number == 0) {\n\t\"zero\"\n} else if (number == 1) {\n\t\"one\"\n} else {\n\t\"other\"\n}\n\nprivate fun if2(number: Int): String {\n\treturn if (number == 0) {\n\t\t\"zero\"\n\t} else if (number == 1) {\n\t\t\"one\"\n\t} else {\n\t\t\"other\"\n\t}\n}\n\nprivate fun if3(number: Int): String {\n\tif (number == 0) {\n\t\treturn \"zero\"\n\t} else if (number == 1) {\n\t\treturn \"one\"\n\t} else {\n\t\treturn \"other\"\n\t}\n}\n"
        },
        {
            "code": "\ninterface IA {\n    fun f()\n}\n\nclass ABC {\n    private companion object Comp : IA {\n        override fun f() {}\n    }\n}\n"
        },
        {
            "code": "\nfun test(s: String?) =\n        when (s?.length) {\n            null -> \"null\" \n            0 -> \"empty\"\n            1 -> \"one\"\n            2 -> \"two\"\n            else -> \"many\"\n        }\n"
        },
        {
            "code": "\nfun test1(a: Any?) {\n    val n: Any? = null\n    if (a == n) {\n        println(\"null\")\n    }\n}\n\nfun test2(a: Any?) {\n    if (a == null) {\n        println(\"null\")\n    }\n}\n"
        },
        {
            "code": "\nprivate interface I {\n\tfun method()\n}\n\nprivate class A : I {\n\toverride fun method() {\n\t\tprintln(\"test\")\n\t}\n}\n\nprivate inline fun test(obj: I, function: (I) -> Unit) {\n\tfunction(obj)\n}\n\nfun main(args: Array<String>) {\n\ttest(A(), I::method)\n}\n"
        },
        {
            "code": "\nprivate class IntIterable(private vararg val elements: Int) : Iterable<Int> {\n\toverride fun iterator(): IntIterator = elements.iterator()\n}\n\nprivate inline fun <T> test(elements: Iterable<T>, function: (T) -> Unit) {\n\tfor (element in elements) {\n\t\tfunction(element)\n\t}\n}\n\nfun main(args: Array<String>) {\n\ttest(IntIterable(1, 2, 3)) { println(it) }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    // println(listOf(true).map(true::equals))\n    true::equals\n}\n"
        },
        {
            "code": "\nprivate fun test(list: List<String>) {}\n\nfun main(args: Array<String>) {\n\tval arrayList = ArrayList<String>()\n\ttest(arrayList)\n}\n"
        },
        {
            "code": "\nenum class X { \n    A, B;\n    val isA get() = this === A \n}\n"
        },
        {
            "code": "\nobject OnlyJvmStatic {\n    @JvmStatic\n    val prop = \"Example\"\n\n    @JvmStatic\n    fun someMethod() {\n    }\n}\n"
        },
        {
            "code": "\nval arr = IntArray(20, 10::pow) // compiler crash\nval arr1 = IntArray(20) { 10.pow(it) } // compiles\nval arr2 = Array(20, \"\"::pow) // compiles\n\nfun Int.pow(num: Int) = 5\nfun String.pow(num: Int) = 3\n"
        },
        {
            "code": "\nfun test(x: Long, low: Int, high: Int) = \n        x in low..high\n"
        },
        {
            "code": "\nfun test(a: IntArray) = 42 in a.indices\n"
        },
        {
            "code": "\nfun test1(x: Int, low: Int, high: Int) {\n    if (x in low..high) {\n        println(\"Yes\")\n    }\n}\n"
        },
        {
            "code": "\nfun test2(x: Int, low: Int, high: Int) {\n    if (x >= low && x <= high) {\n        println(\"Yes\")\n    }\n}\n"
        },
        {
            "code": "\nfun testString(x: String, a: String, b: String) =\n        if (x !in a .. b) \"no\" else \"yes\"\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    // Should be KNPE!\n    val f = System.getProperty(\"abcde\")::capitalize\n\n    // This line is successfully executed\n    println(f)\n\n    // NPE only happens here\n    println(f())\n}\n"
        },
        {
            "code": "\nfun test(x: Any) = x.run { hashCode() }\n"
        },
        {
            "code": "\ninline fun <T, R> T.run2(f: T.() -> R) = f()\n\nfun test2(x: Any) = x.run2 { hashCode() }\n"
        },
        {
            "code": "\n//suspend inline fun <reified T : Scene> changeTo(\n// \tvararg injects: Any,\n// time: TimeSpan = 0.seconds,\n// transition: Transition = AlphaTransition\n// ) = changeTo(T::class.java, *injects, time = time, transition = transition)\n"
        },
        {
            "code": "\nfun test(a: Any, b: Any) =\n        if (a != b) \"N\" else \"Y\"\n"
        },
        {
            "code": "\nclass A(initialBigObject: Any) {\n    private val someContainer = object {\n        var ref = initialBigObject\n    }\n\n    fun updateRef(nextBigObject: Any) {\n        someContainer.ref = nextBigObject\n    }\n}\n\nfun main(args: Array<String>) {\n    val a = A(object { val name = \"First\" })\n    a.updateRef(object { val name = \"Second\" })\n}\n"
        },
        {
            "code": "\nval il = listOf(1, 2, 3)\nfun test() = il.maxBy { it }\n"
        },
        {
            "code": "\ninline fun foo( f : () -> Unit ) {\n    a@ for (i in 1..2) {\n        f()\n        break\n    }\n}\n\n\nfun main(args: Array<String>) {\n\n    foo {foo {foo {foo {foo {foo {foo {foo {\n        foo {foo {foo {foo {foo {foo {foo {foo {\n            foo {foo {foo {foo {foo {foo {foo {foo { //here is 24 foo's\n                println(42)\n            }}}}}}}}}}}}}}}}}}}}}}}}\n\n}\n"
        },
        {
            "code": "\nabstract class A {\n    suspend open fun run() { // function need to be non-final to reproduce the bug \n    }\n}\n\nclass C : A()\n"
        },
        {
            "code": "\nconst val TARGET = \"world\"\n\nfun printMessageNormal() {\n    println(\"Hello \" + TARGET + \"!\")\n}\n\nfun printMessageTemplate() {\n    println(\"Hello $TARGET!\")\n}\n"
        },
        {
            "code": "\nfun test1(a: String, b: String, c: String) = \n        a + (b + c)\n"
        },
        {
            "code": "\ninline fun <reified `-`> foo(t : `-`) {\n\tprintln(t)\n    println(`-`::class)\n} \n\nfun main(args: Array<String>) {\n    val a = foo(1)\n}\n"
        },
        {
            "code": "\nobject O {\n    const val a = 1\n    val b = foo()\n    fun foo() : Int {\n        println(a)\n        return 2\n    }\n}\n\nobject P {\n    val b = foo() // in this object declaration of a and b are reversed\n    const val a = 1\n    fun foo() : Int {\n        println(a)\n        return 2\n    }\n}\n\nfun main(args: Array<String>) {\n    println(O.b)\n    println(P.b)\n}\n"
        },
        {
            "code": "\n\n\nimport kotlin.coroutines.experimental.*\n\n\nfun main(args: Array<String>) {\n    val cont = TestContinuation()\n\n    val test: suspend () -> Unit = {\n        println(\"before\")\n        suspendCoroutine<Unit> { c -> c.resume(Unit) }\n        println(\"after\")\n    }\n\n    test.startCoroutine(cont)\n}\n\n\nprivate class TestContinuation : Continuation<Unit> {\n    override val context: CoroutineContext = EmptyCoroutineContext\n\n    override fun resume(value: Unit) {\n        println(\"resume\")\n    }\n\n    override fun resumeWithException(exception: Throwable) {\n        println(\"resume with exception!!!!\")\n        exception.printStackTrace()\n    }\n\n}\n"
        },
        {
            "code": "\nfun testFindBugsWarning(strings: List<String>): List<String> {\n    return strings.filter({ it.length > 5 })\n}\n"
        },
        {
            "code": "\nfun foo() = \"OK\"\n"
        },
        {
            "code": "\ninterface I {\n    fun foo() {println(\"I\")}\n}\ninterface J : I {\n    override fun foo() {println(\"J\")}\n}\nopen class A : I, J \nopen class B : I by A()\n\nfun main(args: Array<String>) {\n    B().foo()\n}\n"
        },
        {
            "code": "\ninterface I {\n    fun foo() {\n        println(\"foo\")\n    }\n}\n\ninterface J : I\n\nclass A : J, I\n"
        },
        {
            "code": "\ninline fun Any?.zap() {\n    if (this != null) println(\"not null\")\n}\n\nfun test() {\n    val heh = System.getProperty(\"heh\")\n    val z = heh!!\n    heh.zap() // (*)\n}\n"
        },
        {
            "code": "\nfun foo(a: Any) {}\n\nfun test() {\n    val heh = System.getProperty(\"heh\")\n    foo(heh)\n    foo(heh)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    `\"`@ while (true) {\n        break@`\"`\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    `console.log(\"Mua-ha-ha\");{//`@ while (true) {\n        break@`console.log(\"Mua-ha-ha\");{//`\n    }\n}\n"
        },
        {
            "code": "\n// charcode in comments\nobject `¢` //162\nobject `£` //163\nobject `¤` //164\nobject `¥` //165\n"
        },
        {
            "code": "\nval d : String? = \"\"\nval s = d + \"1\"\n"
        },
        {
            "code": "\nval d : String = \"\" // d is not null\nval s = d + \"1\"\n"
        },
        {
            "code": "\nclass User(val map: Map<String, Any?>) {\n    val name: String by map\n}\n\nfun main(args: Array<String>) {\n    val user = User(mapOf(\"name\" to 42))\n    println(user.name + user.name) // actually this is number\n}\n"
        },
        {
            "code": "\nfun test(i: Int) {\n    val a: Any = i\n    println(a)\n    println(\"a=$a\")\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val name = run {\"qwe\"}        // Force compiler to actually do some concatenation\n    println(\"${'$'}name = $name\") // Wrong\n    println(\"${\"$\"}name = $name\") // Right\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.suspendCoroutine\n\nopen class A {\n    open suspend fun foo() {\n        suspendCoroutine<Unit> { it.resume(Unit) }\n        println(\"foo\")\n        suspendCoroutine<Unit> { it.resume(Unit) }\n    }\n}\n\nclass B : A() {\n    suspend override fun foo() {\n        super.foo() // doResume of `A::foo` will invoke `B::foo` again\n\n        suspendCoroutine<Unit> { it.resume(Unit) }\n        println(\"bar\")\n        suspendCoroutine<Unit> { it.resume(Unit) }\n    }\n}\n\n"
        },
        {
            "code": "\nval a: String? = null\nval b = a?.isBlank() == true\n"
        },
        {
            "code": "\nval a: String? = null\nval b = a?.isBlank() ?: false\n"
        },
        {
            "code": "\nfun foo(begin: Int, end: Int) {\n    for (x in begin..end) {\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n\n    val t = \"test\"\n\n    val indicies = intArrayOf(1, -1, 10)\n\n    fun checkMethod(sample: String, f: (sample: String, index: Int) -> Unit) {\n        for (i in indicies) {\n            try {\n                f(sample, i)\n            } catch (e: Throwable) {\n                //print(\"\\t$e\") \n                // Actually there is different exceptions. \n                // I replaced all of them by #excp# only for readable output\n                print(\"\\t#excp#\")\n            }\n        }\n    }\n\n    print(\"indicies:\")\n    for (i in indicies) {\n        print(\"\\t$i\")\n    }\n\n    print(\"\\nsample[index]\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample[index]}\") }\n    print(\"\\nsample.elementAt(index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.elementAt(index)}\") }\n    print(\"\\nsample.dropLast(index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.dropLast(index)}\") }\n    print(\"\\nsample.padEnd(index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.padEnd(index)}\") }\n    print(\"\\nsample.padStart(index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.padStart(index)}\") }\n    print(\"\\nsample.take(index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.take(index)}\") }\n    print(\"\\nsample.takeLast(index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.takeLast(index)}\") }\n\n    print(\"\\nsample.removeRange(index..2)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.removeRange(index..2)}\") }\n    print(\"\\nsample.removeRange(2..index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.removeRange(2..index)}\") }\n\n    print(\"\\nsample.replaceRange(index..2, \\\"\\\")\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.replaceRange(index..2, \"\")}\") }\n    print(\"\\nsample.replaceRange(2..index, \\\"\\\")\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.replaceRange(2..index, \"\")}\") }\n\n    print(\"\\nsample.subSequence(index, 2)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.subSequence(index, 2)}\") }\n    print(\"\\nsample.subSequence(2, index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.subSequence(2, index)}\") }\n\n    print(\"\\nsample.slice(index..2)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.slice(index..2)}\") }\n    print(\"\\nsample.slice(2..index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.slice(2..index)}\") }\n\n    print(\"\\nsample.substring(index..2)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.substring(index..2)}\") }\n    print(\"\\nsample.substring(2..index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.substring(2..index)}\") }\n\n    print(\"\\nsample.substring(index,2)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.substring(index,2)}\") }\n    print(\"\\nsample.substring(2,index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.substring(2,index)}\") }\n\n    print(\"\\nsample.substring(index)\")\n    checkMethod(t)  { sample, index -> print(\"\\t${sample.substring(index)}\") }\n\n    println()\n\n}\n"
        },
        {
            "code": "\nfun foo() = 0\n\nfun main(args: Array<String>) {\n\n    val i = 1/foo()\n    println(i)\n\n    val l = 1L/foo()\n    println(l)\n\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n     val x = intArrayOf(42) as Array<Int>\n     println(x[0])\n}\n"
        },
        {
            "code": "\ninline fun foo(s: String = \"s\") {\n    /* body */\n}\n\nfun test() {\n    foo()\n}\n"
        },
        {
            "code": "\nobject SomeObject {\n    var aDefault = 0\n    inline fun inlineWithDefaults(a: Int = aDefault, b: Int? = null) {\n    }\n\n}\n\nfun inlinedUsage() {\n    SomeObject.inlineWithDefaults(a = 1)\n}\n"
        },
        {
            "code": "\nprivate var _value: String = \"old\"\nfun overrideValueAndReturnOld(newValue: String) = _value.also { _value = newValue }\n\nfun main(args: Array<String>) {\n\tprintln(overrideValueAndReturnOld(\"new\"))\n}\n"
        },
        {
            "code": "\nfun zap(s: String) = s\n\ninline fun tryZap(string: String, fn: (String) -> Unit) {\n    fn(try { zap(string) } catch (e: Exception) { \"\" })\n}\n\nfun main(args: Array<String>) {\n    tryZap(\"\") {}\n}\n"
        },
        {
            "code": "\n\nfun returnMaybeNull():String? {\n    return if (System.currentTimeMillis() == 0L) null else \"thing\"\n}\n\ninternal inline fun Array<String>.matchAll(collector: (String) -> Unit) {\n    for (string in this) {\n        // Works:\n        // val returned = returnMaybeNull() ?: continue\n        // collector(returned)\n\n        // Crashes:\n        collector(returnMaybeNull() ?: continue)\n    }\n}\n\nfun main(args: Array<String>) {\n    arrayOf(\"strings\").matchAll {\n    }\n}\n"
        },
        {
            "code": "\nfun zap(s: String) = s\n\ninline fun tryZap(string: String, fn: (String) -> Unit) {\n    fn(try { zap(string) } finally {})\n}\n\nfun main(args: Array<String>) {\n    tryZap(\"\") {}\n}\n"
        },
        {
            "code": "\nfun zap(s: String): String? = s\n\ninline fun tryZap(s: String, fn: (String) -> String): String {\n    return fn(zap(s) ?: return \"null\")\n}\n\nfun box() = tryZap(\"OK\") { it }\n"
        },
        {
            "code": "\ninline fun alwaysOk(s: String, fn: (String) -> String): String {\n    return fn(return \"OK\")\n}\n\nfun box() = alwaysOk(\"OK\") { it }\n"
        },
        {
            "code": "\nclass A {\n    class D(\n            val i: Int? = null,\n            val b: Boolean? = null\n    )\n\n    init {\n        var nflag: Boolean? = null\n\n        val a2: String = \"123\"\n        try {\n            a2.let { a2 ->\n                nflag = false\n            }\n        } finally {\n            a2.hashCode()\n        }\n        D(null, nflag)\n    }\n}\n"
        },
        {
            "code": "\nclass `My bad class` {\n    fun foo() {}\n}\nfun main(args: Array<String>) {\n\n    val strangeName = `My bad class`()\n    println(strangeName)\n    strangeName.foo()\n    val strangeNameObjectMethodRef = strangeName::foo\n    // OK, but:\n\n    //val strangeNameRef = ::`My bad class` //badaboom #1\n    //val strangeNameMethodRef = `My bad class`::foo //badaboom #2\n}\n"
        },
        {
            "code": "\nvar a = 0xff000000\n"
        },
        {
            "code": "\nvar a = 2147483647\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    boom(B())\n}\n\nclass B\n\nfun B.magic() {\n}\n\nfun boom(a: Any) {\n    when (a) {\n        is B -> run(a::magic)\n    }\n}\n"
        },
        {
            "code": "\n fun loop(n: Int): Int {\n        var x = 0\n        repeat(n) {\n            x++\n        }\n        return x\n    }\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.*\n\nfun main(args: Array<String>) {\n    async {\n        val a = foo(23)\n        println(a)\n        val b = foo(42)\n        println(b)\n    }\n    while (!finished) {\n        println(\"-- resuming --\")\n        proceed()\n    }\n}\n\nvar proceed: () -> Unit = { }\nvar finished = false\n\nsuspend fun bar(x: Int): Int = suspendCoroutine { c -> \n    println(\"before resume: $x\")\n    proceed = { c.resume(x) }\n}\n\ninline suspend fun foo(x: Int): Int = bar(x)\n\nfun async(a: suspend ()->Unit) {\n    a.startCoroutine(object : Continuation<Unit> {\n        override fun resume(value: Unit) {\n            proceed = { \n                println(\"-- done --\")\n                finished = true\n            }\n        }\n        \n        override fun resumeWithException(e: Throwable) {\n        }\n        \n        override val context = EmptyCoroutineContext\n    })\n}\n"
        },
        {
            "code": "\nenum class DemoEnum(val value : String) {\n    One(\"one\"),\n    Two(\"two\"),\n    Three(\"three\");\n    \n    init {\n        println(\"DemoEnum.<init>\")\n    }\n    \n    companion object {\n        init {\n            println(\"DemoEnum.companion\")\n            val value = DemoEnum.values()[0].value\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val one = DemoEnum.One\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    arrayOf(1, 2, Any())\n    intArrayOf(3, 4, 5)\n}\n"
        },
        {
            "code": "\ninterface IFoo1<S1, T1> {\n    fun foo(s: S1): T1\n}\n\ninterface IFoo2<S2, T2> {\n    fun foo(s: S2): Collection<T2>\n}\n\ninterface X\ninterface Y\n\ninterface IFoo12<T> : IFoo1<X, T>, IFoo2<Y, T>\n// ^ Error:(14, 11) Kotlin: JavaScript name foo_11rb$ is generated for different inherited members: fun foo(s: X): T and fun foo(s: Y): Collection<T>\n"
        },
        {
            "code": "\nclass Test {\n\n    inline fun foo() {\n        println(prop)\n    }\n\n    @PublishedApi\n    internal val prop: Int = 42\n}\n"
        },
        {
            "code": "\nfun isEmpty2(l: List<*>): Boolean = \n        l?.isEmpty() // NB: expression type is 'Boolean'\n"
        },
        {
            "code": "\nfun foo(s: String) = (s as CharSequence)\n"
        },
        {
            "code": "\n@Suppress(\"UNCHECKED_CAST\")\nfun <T> f(o: Any): T = o as T\n"
        },
        {
            "code": "\n@file:JvmMultifileClass\npackage abc\n\nclass A {\n    private var r: String = \"\"\n\n    public fun getR(): String = \"\"\n}\n\n"
        },
        {
            "code": "\nfun foo(): Array<String> {\n    return emptyArray()\n}\n"
        },
        {
            "code": "\nimport java.math.*\n\nfun number(doLong: Boolean): Number = when {\n    doLong -> 1.toLong()\n    else -> BigDecimal.valueOf(0)\n}\n\nfun main(args: Array<String>) {\n    println(number(true))\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.KClass\n\nannotation class Test(vararg val values: KClass<*>)\n\n@Test(TestClass::class)\nclass TestClass {\n\n    init {\n        val test = javaClass.getAnnotation(Test::class.java)\n        test.values.forEach {\n            println(it)\n        }\n    }\n\n}\n\nfun main(vararg args: String) {\n    TestClass()\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.KClass\n\nannotation class Test(vararg val values: KClass<*>)\n\n@Test(TestClass::class)\nclass TestClass {\n\n    init {\n        val test = javaClass.getAnnotation(Test::class.java)\n        val values = test.values\n        values.forEach {\n            println(it)\n        }\n    }\n\n}\n\nfun main(vararg args: String) {\n    TestClass()\n}\n"
        },
        {
            "code": "\nimport java.util.function.Function\n\nobject Foo {\n    class Requester(val dealToBeOffered: String)\n}\n\nclass Bar {\n    val foo = Function(Foo::Requester)\n}\n"
        },
        {
            "code": "\nobject Foo {\n    class Requester(val dealToBeOffered: String)\n}\n\ninline fun <A, reified R> startFlow(\n        flowConstructor: (A) -> R\n) {}\n\n\nfun main(args: Array<String>) {\n    startFlow(Foo::Requester)\n}\n"
        },
        {
            "code": "\nfun box(): String {\n    val a: String? = \"test\"\n    a + \"!!!\"\n    return \"OK\"\n}\n"
        },
        {
            "code": "\nimport kotlin.reflect.KProperty\n\nclass Delegate {\n    operator fun provideDelegate(thisRef: Any?, property: KProperty<*>) = this\n    operator fun getValue(thisRef: Any?, property: KProperty<*>) = Unit\n}\n\nclass TestClass {\n    companion object {\n        val test by Delegate()\n    }\n}\n\nfun main(args: Array<String>) {\n    TestClass.test\n}\n"
        },
        {
            "code": "\nclass A() {\n    var y: String? = null\n\n    constructor(x: Any) : this() {\n        println(if (x == \"foo\") \"!!!\" else { println(x as String); \">>>\" })\n    }\n}\n"
        },
        {
            "code": "\n// FILE: Father.kt\n\nabstract class Father {\n    protected abstract inner class InClass {\n        abstract fun Method1();\n    }\n}\n\n// FILE: Child.kt\n\nclass Child : Father() {\n    protected val ChildInClass = object : Father.InClass() {\n        override fun Method1() {\n        }\n    }\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    Class.forName(\"kotlin.text.StringsKt\").getMethods().single { it.name == \"capitalize\" }.invoke(\"\")\n}\n"
        },
        {
            "code": "\n// MODULE: module2\nimport A.foo\nimport B.Companion.bar\n\nobject A {\n    fun foo() = 1\n    inline fun test() = foo() + this.foo() + A.foo()\n}\n\nclass B {\n    companion object {\n        fun bar() = 2\n        inline fun test() = bar() + this.bar() + B.bar()\n    }\n}\n\ninline fun test2() = foo() + bar()\ninline fun A.test2() = foo() + B.bar()\ninline fun B.Companion.test2() = bar()\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    val l = listOf(\"a\")\n\n    val s = l[0].plus(\"bar\")\n\n    println(s)\n}\n"
        },
        {
            "code": "\nfun main(args: Array<String>) {\n    println(ObjectThisTest.testValue)\n}\n\nobject ObjectThisTest {\n\n    val testValue: Float\n        @JvmStatic get() = this.testValue2\n\n    val testValue2: Float\n        get() = 3.0f\n\n}\n"
        },
        {
            "code": "\n// MODULE: M2\nopen class M2 {\n    inline fun foo() = 1\n    inline fun <reified T : Any> bar() = T::class\n}\n"
        },
        {
            "code": "\npackage a\n\nopen class Parent {\n    inline fun inlineMethod() {}\n}\n\nclass Child : Parent()\n"
        },
        {
            "code": "\ndata class X(val s: String)\nclass Y\n\nfun foo(body: suspend Y.(X) -> Unit) {}\nfun bar() {\n    foo { (s) ->\n        println(s)\n    }\n}\n"
        },
        {
            "code": "\n// FAILS: Internal error: wrong code generated\nsuspend fun String.ext(): Int = 10\nsuspend fun coroutinebug(v: String?) {\n\tv?.ext()\n}\n\n// WORKS:\n//suspend fun String.ext(): Int = 10\n//suspend fun coroutinebug(v: String?) {\n//\t@Suppress(\"IfThenToSafeAccess\")\n//\tif (v != null) v.ext()\n//}\n\n// WORKS:\n//suspend fun String.ext(): Int = 10\n//suspend fun coroutinebug(v: String?) = v?.ext()\n"
        },
        {
            "code": "\nfun CharSequence.withReplace(startOffset: Int, endOffset: Int, replacementText: CharSequence): String\n{\n    return \"${subSequence(0,startOffset)}$replacementText${subSequence(endOffset,length)}\"\n}\n"
        },
        {
            "code": "\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.append(this, 0, startIndex)\n    sb.append(replacement)\n    sb.append(this, endIndex, length)\n    return sb\n}\n"
        },
        {
            "code": "\nfun CharSequence.withReplace(startOffset: Int, endOffset: Int, replacementText: CharSequence): CharSequence\n{\n    return \"${subSequence(0,startOffset)}$replacementText${subSequence(endOffset,length)}\" as CharSequence\n}\n"
        },
        {
            "code": "\nfun doubleEquals(a: Double?, b: Double?) = a == b\n"
        },
        {
            "code": "\ntypealias BoolArray = Array<Boolean>\n\nfun main(args: Array<String>) {\n    BoolArray(10) { false }\n}\n"
        },
        {
            "code": "\nimport kotlin.coroutines.experimental.*\nimport kotlin.coroutines.experimental.intrinsics.COROUTINE_SUSPENDED\nimport kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn\n\nfun builder(c: suspend () -> Unit) {\n    val coroutine = c.createCoroutine(object : Continuation<Unit> {\n        override fun resume(value: Unit) { }\n\n        override fun resumeWithException(e: Throwable) {\n            throw e\n        }\n\n        override val context = EmptyCoroutineContext\n    })\n    coroutine.resume(Unit)\n}\n\nfun main(args: Array<String>) {\n    var result = \"fail\"\n    val f: (Unit) -> Unit = { result = \"OK\" }\n    builder(f as suspend () -> Unit)\n    println(result)\n}\n"
        },
        {
            "code": "\ninline fun font(name: String, size: Int, bold: Boolean = false, italic: Boolean = false) = KFont(name, size, bold, italic)\n\nclass KFont(val name: String, val size: Int, val bold: Boolean, val italic: Boolean)\n"
        },
        {
            "code": "\nclass C {\n    val foo by lazy { \"abc\" }\n}\n"
        },
        {
            "code": "\nimport java.lang.Exception\n\nfun nyCompiler() {\n    try {\n        return\n    }\n    catch (e: Exception) {}\n    finally {\n        try {}  catch (e: Exception) {}\n    }\n}\n"
        },
        {
            "code": "\nimport java.lang.Exception\n\nfun nyCompiler() {\n    try {\n        return\n    }\n    catch (e: Exception) {}\n    finally {\n        try {}  \n        catch (e: Exception) {}\n    }\n}\n"
        },
        {
            "code": "\nfun foo() {\n    fun bar(x: String) {\n        if (x.isEmpty()) return\n        println(\"foo: ${x[0]}\")\n        bar(x.substring(1))\n    }\n    bar(\"OK\")\n}\n\nfun baz() {\n    fun bar(x: String) {\n        if (x.isEmpty()) return\n        println(\"baz: ${x[0]}\")\n        bar(x.substring(1))\n    }\n    bar(\"OK\")\n}\n\nfun main(args: Array<String>) {\n    foo()\n    baz()\n}\n"
        },
        {
            "code": "\nenum class Test(val x: Int) {\n    ZERO, ONE(1);\n    constructor(): this(0)\n}\n"
        },
        {
            "code": "\nenum class Test(vararg xs: Int) {\n    OK;\n    val values = xs\n}\n\nfun box(): String =\n        if (Test.OK.values.size == 0) \"OK\" else \"Fail\"\n"
        },
        {
            "code": "\ninterface I {\n    val resolution: String\n        get() = \"OK\"\n}\n\nclass C : I {\n    override val resolution: String by lazy { super.resolution }\n}\n\nfun main(args: Array<String>) {\n    println(C().resolution)\n}\n"
        }
    ]
}